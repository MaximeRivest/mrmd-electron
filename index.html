<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: ws://127.0.0.1:* http://127.0.0.1:*; connect-src 'self' ws://127.0.0.1:* http://127.0.0.1:* https: http: data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://esm.sh https://unpkg.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com blob:; font-src 'self' https://fonts.gstatic.com https://www.openresponses.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https:; img-src 'self' data: blob: https: http:; frame-src 'self' blob: data:">
  <title>mrmd</title>
  <link rel="icon" type="image/png" sizes="32x32" href="./assets/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./assets/icon-16.png">

  <!-- Typography: Monaspace Neon (code) + Literata (prose) -->
  <!-- Also load Courier Prime + EB Garamond for Grayscale themes -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">

  <!-- Bundled fonts: Monaspace Neon + Literata (variable fonts) -->
  <style>
    @font-face {
      font-family: 'Monaspace Neon Var';
      font-style: normal;
      font-weight: 100 900;
      font-display: swap;
      src: url('./assets/fonts/MonaspaceNeon-Variable.woff2') format('woff2');
    }

    @font-face {
      font-family: 'Literata';
      font-style: normal;
      font-weight: 200 900;
      font-display: swap;
      src: url('./assets/fonts/Literata-Variable.ttf') format('truetype');
      font-optical-sizing: auto;
    }

    @font-face {
      font-family: 'Literata';
      font-style: italic;
      font-weight: 200 900;
      font-display: swap;
      src: url('./assets/fonts/Literata-Italic-Variable.ttf') format('truetype');
      font-optical-sizing: auto;
    }
  </style>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    /* Theme variables - will be set by applyTheme() */
    :root {
      --bg: var(--mrmd-bg, #0d1117);
      --bg-secondary: var(--mrmd-panel-bg, #161b22);
      --bg-tertiary: var(--mrmd-hover-bg, #21262d);
      --border: var(--mrmd-border, #30363d);
      --text: var(--mrmd-fg, #c9d1d9);
      --text-muted: var(--mrmd-fg-muted, #8b949e);
      --text-dim: var(--mrmd-fg-dim, #6e7681);
      --accent: var(--mrmd-accent, #58a6ff);
      --success: var(--mrmd-success, #3fb950);
      --warning: var(--mrmd-warning, #d29922);
      --error: var(--mrmd-error, #f85149);

      /* Soft interaction colors (dark theme default) */
      --hover-bg: rgba(255, 255, 255, 0.04);
      --selected-bg: rgba(255, 255, 255, 0.08);
    }

    /* Light theme overrides */
    .light-theme {
      --hover-bg: rgba(0, 0, 0, 0.04);
      --selected-bg: rgba(0, 0, 0, 0.06);
    }

    html, body {
      height: 100%;
      background: var(--editor-background, var(--bg));
      color: var(--text);
      font-family: var(--mrmd-ui-font, -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif);
      font-size: var(--mrmd-ui-font-size, 13px);
      font-weight: var(--widget-font-weight, 400);
    }

    /* Custom scrollbar - subtle (dark theme default) */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.15);
    }
    ::-webkit-scrollbar-corner {
      background: transparent;
    }

    /* Light theme scrollbar */
    .light-theme ::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.15);
    }
    .light-theme ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.25);
    }

    /* =======================================================================
       OPENRESPONSES THEME - Matches openresponses.org styling
       Only applies when theme-openresponses class is on body
       ======================================================================= */

    /* Openresponses theme - slate-50 backgrounds like openresponses.org */
    body.theme-openresponses {
      --bg: #f8fafc; /* slate-50 */
      --bg-secondary: #f8fafc; /* slate-50 */
      --hover-bg: #f1f5f9; /* slate-100 */
      --border: #e2e8f0; /* slate-200 */
      --text: #0f172a; /* slate-900 */
      --text-muted: #64748b; /* slate-500 */
      --text-dim: #94a3b8; /* slate-400 */
      --accent: #ea580c; /* orange-600 */
    }

    body.theme-openresponses .app {
      background: #f8fafc !important; /* slate-50 */
    }

    body.theme-openresponses .nav-sidebar {
      background: #f8fafc !important; /* slate-50 */
      border-color: #e2e8f0 !important; /* slate-200 */
    }

    body.theme-openresponses .toc-sidebar {
      background: #f8fafc !important; /* slate-50 */
      border-left: 1px solid #e2e8f0 !important; /* slate-200 */
    }

    body.theme-openresponses .nav-header {
      border-color: #e2e8f0 !important; /* slate-200 */
    }

    body.theme-openresponses .titlebar {
      background: #f8fafc !important; /* slate-50 */
      border-color: #e2e8f0 !important; /* slate-200 */
    }

    body.theme-openresponses .content {
      background: #f8fafc !important; /* slate-50 */
    }

    /* Openresponses nav items - matches openresponses.org style */
    body.theme-openresponses .nav-item {
      border-left: none !important;
      border-radius: 0.75rem;
      margin: 2px 8px;
      padding: 8px 12px;
      font-size: 14px;
      color: #64748b; /* slate-500 */
      background: transparent;
    }

    body.theme-openresponses .nav-item:hover {
      background: #f1f5f9 !important; /* slate-100 */
      color: #334155; /* slate-700 */
    }

    body.theme-openresponses .nav-item.selected {
      background: #f1f5f9 !important; /* slate-100 - subtle gray like openresponses.org */
      color: #0f172a !important; /* slate-900 */
      border-left: none !important;
    }

    body.theme-openresponses .nav-item.folder {
      font-size: 10px;
      letter-spacing: 0.08em;
      color: #94a3b8; /* slate-400 */
      padding: 8px 12px;
      margin-top: 16px;
      background: transparent !important;
      text-transform: uppercase;
    }

    /* Openresponses TOC - matches openresponses.org style */
    body.theme-openresponses .toc-header {
      font-size: 10px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #94a3b8; /* slate-400 */
      padding: 20px 16px 12px 16px;
    }

    body.theme-openresponses .toc-item {
      border-left: 1px solid #e2e8f0; /* slate-200 */
      padding: 4px 0 4px 16px;
      margin-left: 16px;
      font-size: 14px;
      color: #64748b; /* slate-500 */
      background: transparent !important;
    }

    body.theme-openresponses .toc-item:hover {
      color: #334155; /* slate-700 */
      background: transparent !important;
    }

    body.theme-openresponses .toc-item.active {
      color: #ea580c !important; /* orange-600 */
      border-left: 2px solid #ea580c !important; /* orange-600 */
      background: transparent !important;
    }

    /* Status bar for openresponses */
    body.theme-openresponses .status-bar {
      background: #f8fafc !important; /* slate-50 */
      border-color: #e2e8f0 !important;
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    /* Titlebar */
    .titlebar {
      -webkit-app-region: drag;
      height: 38px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .titlebar-title {
      font-size: 13px;
      color: var(--text-dim);
      font-weight: 400;
    }

    .titlebar-btn {
      -webkit-app-region: no-drag;
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 28px;
      height: 28px;
      background: transparent;
      border: none;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-muted);
      transition: background 0.1s, color 0.1s;
    }

    .titlebar-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .titlebar-btn.active {
      color: var(--accent);
    }

    /* Main content */
    .content {
      flex: 1;
      display: flex;
      align-items: stretch;
      overflow-y: auto;
      overflow-x: visible;
      position: relative;
      background: var(--editor-background, var(--bg));
    }

    #editor-container {
      flex: 1;
      min-height: 100%;
      padding: 40px 20px 40px 20px;
      padding-right: 10px; /* Account for scrollbar */
      display: none;
      overflow-y: auto;
      position: relative;
    }

    /* Center the editor within its container */
    #editor-container > #editor {
      max-width: 800px;
      margin: 0 auto;
    }

    #editor {
      min-height: 100%;
      border-radius: 0;
      overflow: visible;
    }

    /* Navigation Sidebar */
    .nav-sidebar {
      width: 240px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: none;
      flex-direction: column;
      flex-shrink: 0;
      position: relative;
      transition: width 0.2s ease;
      overflow: visible;
    }

    .nav-sidebar.visible {
      display: flex;
    }

    .nav-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav-title {
      flex: 1;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      padding: 2px 4px;
      margin: -2px -4px;
      border-radius: 3px;
    }

    .nav-title:hover {
      color: var(--text);
      background: var(--hover-bg);
    }

    .nav-action {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 14px;
    }

    .nav-action:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .nav-tree {
      flex: 1;
      overflow-y: auto;
      padding: 12px 0;
    }

    /* Documentation-style navigation */
    .nav-item {
      display: flex;
      align-items: center;
      padding: 6px 16px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text-muted);
      gap: 6px;
      user-select: none;
      border-left: 2px solid transparent;
      margin-left: 0;
      transition: color 0.1s, border-color 0.1s, background 0.1s;
    }

    .nav-item:hover {
      color: var(--text);
      background: var(--hover-bg);
    }

    .nav-item.selected {
      color: var(--accent);
      border-left-color: var(--accent);
      background: rgba(88, 166, 255, 0.08);
    }

    .nav-item.selected .nav-item-label {
      font-weight: 500;
    }

    /* Folder/section headers */
    .nav-item.folder {
      color: var(--text);
      font-weight: 500;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-top: 16px;
      padding-top: 8px;
      padding-bottom: 8px;
      border-left-color: transparent !important;
      background: transparent !important;
    }

    .nav-item.folder:first-child {
      margin-top: 0;
    }

    .nav-item.folder:hover {
      color: var(--text);
      background: transparent;
    }

    .nav-item.folder.selected {
      color: var(--text);
    }

    /* Expand/collapse arrow - subtle */
    .nav-expand {
      width: 14px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      color: var(--text-dim);
      transition: transform 0.15s ease;
      flex-shrink: 0;
      opacity: 0.6;
    }

    .nav-item:hover .nav-expand {
      opacity: 1;
    }

    .nav-expand.expanded {
      transform: rotate(90deg);
    }

    .nav-expand.hidden {
      width: 14px; /* Keep spacing consistent */
      visibility: hidden;
    }

    .nav-item-label {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Nested items get more indent */
    .nav-children .nav-item:not(.folder) {
      font-size: 13px;
      font-weight: 400;
      text-transform: none;
      letter-spacing: normal;
      margin-top: 0;
    }

    /* Inline rename input */
    .nav-rename-input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--accent);
      border-radius: 2px;
      padding: 2px 4px;
      font-size: 13px;
      color: var(--text);
      outline: none;
      min-width: 0;
    }

    .nav-children {
      /* Children are indented via padding-left on items */
    }

    .nav-children.collapsed {
      display: none;
    }

    /* Drag and drop states */
    .nav-item.dragging {
      opacity: 0.4;
    }

    .nav-item.drop-target {
      background: color-mix(in srgb, var(--accent) 15%, transparent) !important;
      border-left-color: var(--accent) !important;
    }

    .nav-item.drop-above::before {
      content: '';
      position: absolute;
      left: 16px;
      right: 0;
      top: -1px;
      height: 2px;
      background: var(--accent);
      border-radius: 1px;
    }

    .nav-item.drop-below::after {
      content: '';
      position: absolute;
      left: 16px;
      right: 0;
      bottom: -1px;
      height: 2px;
      background: var(--accent);
      border-radius: 1px;
    }

    .nav-item {
      position: relative;
    }

    /* Context menu */
    .nav-context-menu {
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 0;
      min-width: 160px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: none;
    }

    .nav-context-menu.visible {
      display: block;
    }

    .nav-context-item {
      padding: 8px 12px;
      font-size: 13px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav-context-item:hover {
      background: var(--hover-bg);
    }

    .nav-context-item.danger {
      color: var(--error);
    }

    .nav-context-separator {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    /* Status bar */
    .status-bar {
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      padding: 8px 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      font-size: 12px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px 8px;
      margin: -4px -8px;
      border-radius: 4px;
    }

    .status-item:hover { background: var(--hover-bg); }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-dim);
      opacity: 0.5;
    }

    .status-dot.ready { background: var(--success); opacity: 0.8; }
    .status-dot.loading { background: var(--warning); opacity: 0.8; }
    .status-dot.error { background: var(--error); opacity: 0.8; }

    /* Session controls moved to CodeLens in editor */

    .status-spacer { flex: 1; }

    .status-file {
      color: var(--text-dim);
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .status-theme {
      color: var(--text-dim);
      cursor: pointer;
      padding: 4px 8px;
      margin: -4px -8px;
      border-radius: 4px;
    }
    .status-theme:hover { background: var(--hover-bg); }

    /* Table of Contents Sidebar (Right) */
    .toc-sidebar {
      width: 220px;
      flex-shrink: 0;
      display: none;
      flex-direction: column;
      position: relative;
      height: calc(100vh - 38px); /* Subtract titlebar */
      overflow: visible;
      transition: width 0.2s ease;
    }

    .toc-sidebar.visible {
      display: flex;
    }

    .toc-header {
      padding: 20px 16px 12px 16px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }

    .toc-list {
      flex: 1;
      overflow-y: auto;
      padding: 0 0 20px 0;
    }

    .toc-item {
      display: block;
      padding: 6px 16px;
      font-size: 13px;
      color: var(--text-muted);
      cursor: pointer;
      border-left: 2px solid transparent;
      text-decoration: none;
      line-height: 1.4;
      transition: color 0.1s, border-color 0.1s, background 0.1s;
    }

    .toc-item:hover {
      color: var(--text);
      background: var(--hover-bg);
    }

    .toc-item.active {
      color: var(--accent);
      border-left-color: var(--accent);
    }

    /* Indent based on heading level */
    .toc-item[data-level="1"] { padding-left: 16px; }
    .toc-item[data-level="2"] { padding-left: 16px; }
    .toc-item[data-level="3"] { padding-left: 28px; font-size: 12px; }
    .toc-item[data-level="4"] { padding-left: 40px; font-size: 12px; }
    .toc-item[data-level="5"] { padding-left: 52px; font-size: 12px; }
    .toc-item[data-level="6"] { padding-left: 64px; font-size: 12px; }

    .toc-empty {
      padding: 16px;
      color: var(--text-dim);
      font-size: 12px;
      font-style: italic;
    }

    /* =========================================================================
       SIDEBAR COLLAPSE TOGGLES
       Minimal arrow-only toggles for collapsing nav and TOC sidebars
       ========================================================================= */

    /* Shared toggle button styles - just an arrow, no chrome */
    .sidebar-toggle {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 24px;
      height: 32px;
      background: transparent;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-dim);
      font-size: 14px;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.2s, color 0.15s;
      padding: 0;
      margin: 0;
    }

    .sidebar-toggle:hover {
      color: var(--text);
    }

    /* Show on sidebar hover */
    .nav-sidebar:hover > .nav-toggle,
    .toc-sidebar:hover > .toc-toggle {
      opacity: 0.6;
    }

    .nav-sidebar:hover > .nav-toggle:hover,
    .toc-sidebar:hover > .toc-toggle:hover {
      opacity: 1;
    }

    /* Left nav toggle - inside right edge */
    .nav-toggle {
      right: 4px;
    }

    /* Right TOC toggle - inside left edge */
    .toc-toggle {
      left: 4px;
    }

    /* Collapsed nav sidebar */
    .nav-sidebar.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      border-right: none !important;
    }

    .nav-sidebar.collapsed > .nav-header,
    .nav-sidebar.collapsed > .nav-tree {
      display: none !important;
    }

    .nav-sidebar.collapsed > .nav-toggle {
      display: none !important;
    }

    /* Collapsed TOC sidebar */
    .toc-sidebar.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
    }

    .toc-sidebar.collapsed > .toc-header,
    .toc-sidebar.collapsed > .toc-list {
      display: none !important;
    }

    .toc-sidebar.collapsed > .toc-toggle {
      display: none !important;
    }

    /* Floating toggles (when sidebar collapsed) - also just arrows */
    .sidebar-toggle-floating {
      position: fixed;
      top: calc(50% + 19px);
      transform: translateY(-50%);
      width: 24px;
      height: 32px;
      background: transparent;
      border: none;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-dim);
      font-size: 14px;
      z-index: 200;
      padding: 0;
      margin: 0;
      transition: color 0.15s, opacity 0.15s;
      opacity: 0.4;
    }

    .sidebar-toggle-floating:hover {
      color: var(--text);
      opacity: 1;
    }

    .nav-toggle-floating {
      left: 4px;
    }

    .nav-toggle-floating.visible {
      display: flex;
    }

    .toc-toggle-floating {
      right: 4px;
    }

    .toc-toggle-floating.visible {
      display: flex;
    }

    /* =========================================================================
       SIDE RAIL SYSTEM
       A floating toggle button that expands into a side rail with tool panels
       ========================================================================= */

    /* Side rail - the vertical bar with icons */
    .side-rail {
      position: fixed;
      top: 38px; /* Below titlebar */
      right: 0;
      bottom: 0;
      width: 48px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      padding: 8px 0;
      z-index: 100;
      transform: translateX(100%);
      transition: transform 0.2s ease;
    }

    .side-rail.open {
      transform: translateX(0);
    }

    /* When rail is open, shift content left to make room */
    .content.rail-open {
      margin-right: 48px;
      transition: margin-right 0.2s ease;
    }

    /* Rail icon buttons */
    .rail-btn {
      width: 48px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 16px;
      position: relative;
      transition: color 0.1s, background 0.1s;
    }

    .rail-btn:hover {
      color: var(--text);
      background: var(--hover-bg);
    }

    .rail-btn.active {
      color: var(--accent);
    }

    /* Active indicator dot */
    .rail-btn.active::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      width: 3px;
      height: 16px;
      background: var(--accent);
      border-radius: 2px;
    }

    /* Spacer to push items to bottom */
    .rail-spacer {
      flex: 1;
    }

    /* Rail section divider */
    .rail-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 8px;
    }

    /* Panel overlay - slides in from right */
    .rail-panel {
      position: fixed;
      top: 38px;
      right: 48px; /* Next to rail */
      bottom: 0;
      width: 280px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      z-index: 99;
      transform: translateX(calc(100% + 48px));
      transition: transform 0.2s ease;
      box-shadow: -4px 0 16px rgba(0, 0, 0, 0.1);
    }

    .rail-panel.open {
      transform: translateX(0);
    }

    /* Panel header */
    .rail-panel-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .rail-panel-title {
      flex: 1;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text);
    }

    .rail-panel-close {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
    }

    .rail-panel-close:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .rail-panel-refresh {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
      transition: transform 0.3s;
    }

    .rail-panel-refresh:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .rail-panel-refresh:active {
      transform: rotate(180deg);
    }

    /* Panel content */
    .rail-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px 0;
    }

    /* Wide panel variant (for source code) */
    .rail-panel-wide {
      width: 500px;
    }

    /* Artifact panel - larger for preview */
    .rail-panel-artifact {
      width: 45vw;
      max-width: 800px;
      min-width: 400px;
      display: flex;
      flex-direction: column;
    }

    .artifact-content {
      flex: 1;
      padding: 0;
      overflow: hidden;
      background: #fff;
      border-radius: 4px;
      margin: 8px;
    }

    .artifact-content iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: #fff;
    }

    .artifact-status {
      padding: 8px 16px;
      border-top: 1px solid var(--border);
      font-size: 11px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .artifact-status-indicator {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-dim);
    }

    .artifact-status-indicator.active {
      background: #10b981;
    }

    .rail-panel-btn {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
    }

    .rail-panel-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    /* Source panel styles */
    .source-back-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s;
    }
    .source-back-btn:hover:not(:disabled) {
      background: var(--hover-bg);
      color: var(--text);
    }
    .source-back-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    .source-file-path {
      padding: 8px 16px;
      font-size: 11px;
      color: var(--text-dim);
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      font-family: var(--font-mono);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .source-content {
      padding: 0 !important;
    }
    .source-code {
      margin: 0;
      padding: 16px;
      font-family: var(--font-mono);
      font-size: 12px;
      line-height: 1.5;
      overflow-x: auto;
      background: var(--bg-primary);
      color: var(--text);
      white-space: pre;
      tab-size: 4;
    }
    .source-code code {
      font-family: inherit;
    }
    /* Clickable type references in source */
    .source-type-ref {
      color: var(--accent);
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 2px;
    }
    .source-type-ref:hover {
      text-decoration-style: solid;
    }
    /* Python syntax highlighting (basic) */
    .source-code .kw { color: #ff7b72; }  /* keywords */
    .source-code .str { color: #a5d6ff; } /* strings */
    .source-code .num { color: #79c0ff; } /* numbers */
    .source-code .cm { color: #8b949e; }  /* comments */
    .source-code .fn { color: #d2a8ff; }  /* function names */
    .source-code .cls { color: #ffa657; } /* class names */
    .source-code .dec { color: #ffa657; } /* decorators */
    .source-code .type { color: #79c0ff; } /* type annotations */

    /* Panel section */
    .rail-panel-section {
      padding: 0 16px;
      margin-bottom: 16px;
    }

    .rail-panel-section-title {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 8px;
    }

    /* Panel list items */
    .rail-panel-item {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      margin: 0 -12px;
      border-radius: 4px;
      cursor: pointer;
      gap: 10px;
      font-size: 13px;
      color: var(--text);
      transition: background 0.1s;
    }

    .rail-panel-item:hover {
      background: var(--hover-bg);
    }

    .rail-panel-item-icon {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: var(--accent);
      flex-shrink: 0;
    }

    .rail-panel-item-label {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .rail-panel-item-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Variable item style (for Variables panel) */
    .var-item {
      display: flex;
      align-items: center;
      padding: 6px 16px;
      gap: 8px;
      font-size: 13px;
      border-left: 3px solid transparent;
      transition: background 0.1s;
    }

    .var-item:hover {
      background: var(--hover-bg);
    }

    .var-item-color {
      width: 4px;
      height: 16px;
      border-radius: 2px;
      flex-shrink: 0;
    }

    .var-item-name {
      font-weight: 500;
      color: var(--text);
    }

    .var-item-type {
      color: var(--text-muted);
      font-size: 12px;
    }

    /* Runtime list items */
    .runtimes-list {
      padding: 8px 0;
    }

    .runtimes-empty {
      padding: 16px;
      color: var(--text-dim);
      font-size: 12px;
      text-align: center;
    }

    .runtime-item {
      display: flex;
      align-items: center;
      padding: 8px 16px;
      gap: 10px;
      cursor: pointer;
      transition: background 0.1s;
    }

    .runtime-item:hover {
      background: var(--hover-bg);
    }

    .runtime-item.attached {
      background: rgba(88, 166, 255, 0.08);
    }

    .runtime-item-status {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--success);
      flex-shrink: 0;
    }

    .runtime-item.attached .runtime-item-status {
      background: var(--accent);
      box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.3);
    }

    .runtime-item-info {
      flex: 1;
      min-width: 0;
    }

    .runtime-item-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .runtime-item-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    .runtime-item-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .runtime-item:hover .runtime-item-actions {
      opacity: 1;
    }

    .runtime-item-btn {
      padding: 2px 6px;
      font-size: 10px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-muted);
      cursor: pointer;
      transition: background 0.1s, color 0.1s, border-color 0.1s;
    }

    .runtime-item-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .runtime-item-btn.danger:hover {
      border-color: var(--error);
      color: var(--error);
    }

    .runtime-lang-badge {
      display: inline-block;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      padding: 1px 4px;
      border-radius: 3px;
      margin-right: 6px;
      vertical-align: middle;
    }

    .runtime-lang-badge.python {
      background: rgba(53, 114, 165, 0.2);
      color: #5a9fd4;
    }

    .runtime-lang-badge.bash {
      background: rgba(76, 175, 80, 0.2);
      color: #81c784;
    }

    /* AI Command items */
    .ai-cmd {
      display: flex;
      align-items: center;
      padding: 8px 16px;
      gap: 10px;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.1s;
    }

    .ai-cmd:hover {
      background: var(--hover-bg);
    }

    .ai-cmd.disabled {
      opacity: 0.5;
      pointer-events: none;
    }

    .ai-cmd.loading {
      opacity: 0.7;
      pointer-events: none;
    }

    .ai-cmd.loading .ai-cmd-icon {
      animation: ai-cmd-pulse 1s infinite;
    }

    @keyframes ai-cmd-pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .ai-cmd-icon {
      width: 20px;
      text-align: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .ai-cmd-label {
      flex: 1;
      font-size: 13px;
      color: var(--text);
    }

    .ai-cmd-hint {
      font-size: 11px;
      color: var(--text-muted);
      opacity: 0.6;
    }

    .ai-cmd-key {
      width: 22px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      color: var(--accent);
      flex-shrink: 0;
    }

    .ai-cmd:hover .ai-cmd-key {
      border-color: var(--accent);
      background: rgba(88, 166, 255, 0.1);
    }

    /* Keyboard mode active indicator */
    #panel-ai.keyboard-mode .ai-cmd-key {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    #panel-ai.keyboard-mode {
      box-shadow: inset 0 0 0 2px var(--accent);
    }

    .ai-keyboard-hint {
      font-size: 11px;
      color: var(--accent);
      margin-left: auto;
      margin-right: 8px;
    }

    .ai-level-hint {
      font-size: 10px;
      color: var(--text-dim);
      font-weight: normal;
      margin-left: 6px;
    }

    .ai-panel-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: rgba(255, 193, 7, 0.1);
      border-bottom: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 12px;
    }

    .ai-status-icon {
      color: #ffc107;
    }

    .ai-juice-selector {
      display: flex;
      gap: 4px;
      padding: 8px 16px;
    }

    .ai-juice-btn {
      flex: 1;
      padding: 8px 4px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      cursor: pointer;
      font-size: 16px;
      transition: all 0.15s;
    }

    .ai-juice-btn:hover {
      background: var(--hover-bg);
      border-color: var(--text-muted);
    }

    .ai-juice-btn.selected {
      background: var(--accent-bg, rgba(59, 130, 246, 0.15));
      border-color: var(--accent, #3b82f6);
    }

    .ai-reasoning-btn {
      flex: 1;
      padding: 8px 4px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s;
    }

    .ai-reasoning-btn:hover {
      background: var(--hover-bg);
      border-color: var(--text-muted);
    }

    .ai-reasoning-btn.selected {
      background: var(--accent-bg, rgba(59, 130, 246, 0.15));
      border-color: var(--accent, #3b82f6);
    }

    .ai-reasoning-btn.disabled,
    .ai-reasoning-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }

    .ai-progress {
      padding: 12px 16px;
      background: var(--hover-bg);
      border-bottom: 1px solid var(--border);
    }

    .ai-progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .ai-progress-title {
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      animation: ai-progress-pulse 1.5s infinite;
    }

    @keyframes ai-progress-pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    .ai-progress-model {
      font-size: 11px;
      color: var(--text-muted);
    }

    .ai-progress-models {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .ai-progress-chip {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .ai-progress-chip.running {
      background: rgba(59, 130, 246, 0.15);
      border-color: var(--accent, #3b82f6);
      color: var(--accent, #3b82f6);
      animation: ai-progress-pulse 1s infinite;
    }

    .ai-progress-chip.done {
      background: rgba(34, 197, 94, 0.15);
      border-color: #22c55e;
      color: #22c55e;
    }

    .ai-progress-chip.pending {
      opacity: 0.5;
    }

    /* Setup hints banner */
    .setup-hints {
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      padding: 8px 16px;
    }

    .setup-hint {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: var(--hover-bg);
      border-radius: 6px;
      margin-bottom: 6px;
    }

    .setup-hint:last-child {
      margin-bottom: 0;
    }

    .hint-icon {
      font-size: 16px;
      flex-shrink: 0;
    }

    .hint-text {
      flex: 1;
      font-size: 13px;
      color: var(--text);
    }

    .hint-action {
      padding: 4px 10px;
      font-size: 12px;
      background: var(--accent, #3b82f6);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      white-space: nowrap;
    }

    .hint-action:hover {
      opacity: 0.9;
    }

    .hint-dismiss {
      padding: 2px 6px;
      font-size: 14px;
      background: transparent;
      color: var(--text-muted);
      border: none;
      cursor: pointer;
      border-radius: 4px;
    }

    .hint-dismiss:hover {
      background: var(--border);
      color: var(--text);
    }

    /* Inline "no runtime" prompt - appears below code cells */
    .no-runtime-prompt {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 400px;
      animation: prompt-slide-in 0.2s ease-out;
    }

    @keyframes prompt-slide-in {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    .no-runtime-prompt-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text);
    }

    .no-runtime-prompt-header svg {
      width: 16px;
      height: 16px;
      color: var(--warning, #f59e0b);
    }

    .no-runtime-prompt-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .no-runtime-prompt-btn {
      padding: 6px 12px;
      font-size: 12px;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }

    .no-runtime-prompt-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--text-muted);
    }

    .no-runtime-prompt-btn.primary {
      background: var(--accent, #3b82f6);
      border-color: var(--accent, #3b82f6);
      color: white;
    }

    .no-runtime-prompt-btn.primary:hover {
      opacity: 0.9;
    }

    .no-runtime-prompt-btn.secondary {
      color: var(--text-muted);
      font-size: 11px;
    }

    .no-runtime-prompt-dismiss {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 2px 6px;
      font-size: 14px;
      background: transparent;
      color: var(--text-muted);
      border: none;
      cursor: pointer;
      border-radius: 4px;
      line-height: 1;
    }

    .no-runtime-prompt-dismiss:hover {
      background: var(--border);
      color: var(--text);
    }

    .no-runtime-prompt-progress {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .no-runtime-prompt-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid var(--border);
      border-top-color: var(--accent, #3b82f6);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Subtle hover trigger for session config */
    .session-hover-trigger {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 48px;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .session-hover-trigger.visible {
      display: flex;
    }

    .session-hover-action {
      opacity: 0;
      padding: 6px 12px;
      font-size: 12px;
      color: var(--text-muted);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: opacity 0.2s ease, background 0.15s, color 0.15s;
      white-space: nowrap;
    }

    .session-hover-trigger:hover .session-hover-action {
      opacity: 1;
    }

    .session-hover-action:hover {
      background: var(--bg-tertiary);
      color: var(--text);
      border-color: var(--accent);
    }

    .session-hover-action svg {
      width: 14px;
      height: 14px;
      opacity: 0.7;
    }

    /* Modal overlay */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: flex-start;
      justify-content: center;
      padding-top: 10vh;
      z-index: 1000;
    }

    .modal-overlay.visible { display: flex; }

    /* File Picker Modal */
    .file-picker {
      width: 640px;
      max-height: 70vh;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .picker-header {
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .picker-icon {
      color: var(--text-dim);
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .picker-icon svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.5;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .picker-input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--text);
      font-size: 13px;
      outline: none;
    }

    .picker-input::placeholder { color: var(--text-dim); }

    .picker-hint {
      color: var(--text-dim);
      font-size: 11px;
      padding: 2px 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    .picker-body {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    .picker-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px 12px 16px;
    }

    .picker-section {
      margin-bottom: 20px;
    }

    .picker-section:last-child {
      margin-bottom: 0;
    }

    .picker-section-title {
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 0 8px 6px;
      margin-bottom: 0;
    }

    .picker-item {
      display: flex;
      align-items: center;
      padding: 10px 8px;
      border-radius: 4px;
      cursor: pointer;
      gap: 12px;
    }

    .picker-item:hover { background: var(--hover-bg); }
    .picker-item.selected {
      background: var(--accent);
      background: rgba(88, 166, 255, 0.15);
    }
    .picker-item.selected .picker-item-name {
      color: var(--accent);
    }

    .picker-item-icon {
      width: 16px;
      text-align: center;
      color: var(--text-dim);
      font-size: 12px;
    }

    .picker-item-name {
      flex: 1;
      font-size: 13px;
      font-weight: 400;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .picker-item-path {
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 180px;
    }

    .picker-item-meta {
      font-size: 11px;
      color: var(--text-dim);
      white-space: nowrap;
    }

    .picker-item-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      font-weight: 500;
      text-transform: uppercase;
      flex-shrink: 0;
    }

    .picker-item-badge.notebook {
      background: #f59e0b20;
      color: #f59e0b;
    }

    .picker-preview {
      width: 260px;
      border-left: 1px solid var(--border);
      background: var(--bg);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .preview-header {
      padding: 12px 16px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
    }

    .preview-content {
      flex: 1;
      padding: 0 16px 16px;
      font-family: inherit;
      font-size: 12px;
      line-height: 1.5;
      color: var(--text-muted);
      white-space: pre-wrap;
      overflow-y: auto;
    }

    .picker-footer {
      padding: 10px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      gap: 16px;
      font-size: 11px;
      color: var(--text-dim);
    }

    .picker-footer kbd {
      background: var(--bg-tertiary);
      padding: 2px 5px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 10px;
    }

    /* Folder context bar */
    .picker-context {
      padding: 8px 20px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .picker-context-path {
      color: var(--accent);
      font-weight: 500;
    }

    .picker-context-hint {
      margin-left: auto;
      font-size: 10px;
      color: var(--text-dim);
    }

    /* Create options */
    .picker-create-section {
      border-top: 1px solid var(--border);
      margin-top: 12px;
      padding-top: 12px;
    }

    .picker-item.create {
      color: var(--accent);
    }

    .picker-item.create .picker-item-icon {
      color: var(--accent);
    }

    .picker-item.folder .picker-item-icon {
      color: var(--text-dim);
    }

    .picker-item-action {
      font-size: 10px;
      color: var(--text-dim);
      margin-left: auto;
    }

    /* Mode indicator */
    .picker-mode {
      font-size: 10px;
      padding: 2px 8px;
      background: var(--accent);
      color: var(--bg);
      border-radius: 4px;
      font-weight: 500;
    }

    /* Venv Selector Modal */
    .venv-picker {
      width: 420px;
      max-height: 60vh;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }

    .venv-picker .picker-header {
      padding: 16px 20px;
      border-bottom: none;
    }

    .venv-picker .picker-list {
      padding: 8px 12px 16px;
    }

    .venv-picker .picker-section {
      margin-bottom: 20px;
    }

    .venv-picker .picker-section:last-child {
      margin-bottom: 0;
    }

    .venv-picker .picker-section-title {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: none;
      letter-spacing: 0;
      padding: 0 8px 8px;
      margin-bottom: 0;
    }

    .venv-picker .picker-footer {
      padding: 12px 20px;
      border-top: 1px solid var(--border);
      opacity: 0.6;
    }

    .venv-item {
      display: flex;
      align-items: center;
      padding: 12px 8px;
      border-radius: 4px;
      cursor: pointer;
      gap: 12px;
    }

    .venv-item:hover { background: var(--hover-bg); }
    .venv-item.selected { background: var(--selected-bg); }

    .venv-item-info { flex: 1; min-width: 0; }

    .venv-item-name {
      font-size: 14px;
      font-weight: 400;
    }

    .venv-item-path {
      font-size: 12px;
      color: var(--text-muted);
      font-family: inherit;
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .venv-item-version {
      font-size: 12px;
      color: var(--text-muted);
      background: none;
      padding: 0;
    }

    .venv-item-badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      font-weight: 400;
    }

    .venv-item-badge.warning {
      background: color-mix(in srgb, var(--warning) 15%, transparent);
      color: var(--warning);
    }

    .venv-item-badge.danger {
      background: color-mix(in srgb, var(--error) 15%, transparent);
      color: var(--error);
    }

    .picker-custom-path {
      padding: 8px 12px;
      border-top: 1px solid var(--border);
    }

    .picker-custom-path input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 8px 12px;
      color: var(--text);
      font-size: 12px;
      outline: none;
    }

    .picker-custom-path input:focus {
      border-color: var(--accent);
    }

    .picker-custom-path input::placeholder {
      color: var(--text-dim);
    }

    /* Loading spinner */
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
      font-size: 13px;
    }

    /* Match highlight */
    .match {
      color: var(--accent);
      font-weight: 500;
    }

    /* Notebook Open Dialog */
    .notebook-dialog {
      width: 420px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      padding: 24px;
    }

    .notebook-dialog h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }

    .notebook-dialog p {
      margin: 0 0 20px 0;
      font-size: 13px;
      color: var(--text-muted);
    }

    .notebook-dialog-filename {
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--accent);
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 3px;
      word-break: break-all;
    }

    .notebook-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
    }

    .notebook-option {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .notebook-option:hover {
      border-color: var(--accent);
      background: var(--hover-bg);
    }

    .notebook-option strong {
      font-size: 14px;
      font-weight: 500;
      color: var(--text);
    }

    .notebook-option span {
      font-size: 12px;
      color: var(--text-muted);
    }

    .notebook-option.convert:hover {
      border-color: var(--warning);
    }

    .notebook-dialog-cancel {
      width: 100%;
      padding: 10px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-muted);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .notebook-dialog-cancel:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    /* =========================================================================
       DATA LOSS PREVENTION - Warning Banner
       =========================================================================
       Added after investigating unexplained data loss on 2026-01-16.
       When sync server crashes, this banner is shown IMMEDIATELY to warn
       the user that their changes are NOT being saved.
       ========================================================================= */
    .sync-warning-banner {
      display: none;
      position: fixed;
      top: 38px; /* Below titlebar */
      left: 0;
      right: 0;
      background: linear-gradient(90deg, #dc2626, #b91c1c);
      color: white;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      z-index: 9999;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      animation: pulse-warning 2s ease-in-out infinite;
    }

    .sync-warning-banner.visible {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .sync-warning-banner .warning-icon {
      font-size: 20px;
    }

    .sync-warning-banner .warning-message {
      flex: 1;
    }

    .sync-warning-banner .warning-actions {
      display: flex;
      gap: 8px;
    }

    .sync-warning-banner button {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
    }

    .sync-warning-banner button:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .sync-warning-banner button.primary {
      background: white;
      color: #dc2626;
      border-color: white;
    }

    @keyframes pulse-warning {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }
  </style>
</head>
<body>
  <!-- =======================================================================
       DATA LOSS PREVENTION - Sync Warning Banner
       =======================================================================
       Added after investigating unexplained data loss on 2026-01-16.
       This banner is shown when the sync server crashes to immediately
       alert the user that their changes are NOT being saved.
       ======================================================================= -->
  <div class="sync-warning-banner" id="sync-warning-banner">
    <span class="warning-icon"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 2l6 12H2L8 2zM8 6v4M8 12v1"/></svg></span>
    <span class="warning-message">
      <strong>SYNC OFFLINE - CHANGES NOT BEING SAVED!</strong>
      <span id="sync-warning-details"></span>
    </span>
    <div class="warning-actions">
      <button onclick="copyBackupToClipboard()">Copy Content</button>
      <button onclick="downloadBackup()">Download Backup</button>
      <button class="primary" onclick="attemptRecovery()">Try to Recover</button>
    </div>
  </div>

  <div class="app">
    <div class="titlebar">
      <span class="titlebar-title" id="titlebar-title">mrmd</span>
      <button class="titlebar-btn rail-toggle" id="rail-toggle" title="Toggle tools (Ctrl+\)">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
          <line x1="3" y1="4" x2="13" y2="4"/>
          <line x1="3" y1="8" x2="13" y2="8"/>
          <line x1="3" y1="12" x2="13" y2="12"/>
        </svg>
      </button>
    </div>

    <div class="content">
      <!-- Project Navigation Sidebar -->
      <div id="nav-sidebar" class="nav-sidebar">
        <button class="sidebar-toggle nav-toggle" id="nav-toggle" title="Collapse"></button>
        <div class="nav-header">
          <span class="nav-title" id="nav-title" title="Click to open project config">No Project</span>
          <button class="nav-action" id="nav-config-btn" title="Project config (mrmd.md)"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><line x1="2" y1="4" x2="14" y2="4"/><circle cx="5" cy="4" r="1.5" fill="currentColor" stroke="none"/><line x1="2" y1="8" x2="14" y2="8"/><circle cx="10" cy="8" r="1.5" fill="currentColor" stroke="none"/><line x1="2" y1="12" x2="14" y2="12"/><circle cx="7" cy="12" r="1.5" fill="currentColor" stroke="none"/></svg></button>
          <button class="nav-action" id="nav-new-btn" title="New file (n)">+</button>
        </div>
        <div class="nav-tree" id="nav-tree">
          <!-- Nav tree renders here -->
        </div>
      </div>
      <!-- Floating toggle when nav is collapsed -->
      <button class="sidebar-toggle-floating nav-toggle-floating" id="nav-toggle-floating" title="Expand"></button>

      <!-- Nav Context Menu -->
      <div class="nav-context-menu" id="nav-context-menu">
        <div class="nav-context-item" data-action="new-file">New File</div>
        <div class="nav-context-item" data-action="new-folder">New Folder</div>
        <div class="nav-context-separator"></div>
        <div class="nav-context-item" data-action="rename">Rename</div>
        <div class="nav-context-item" data-action="reveal">Reveal in File Manager</div>
        <div class="nav-context-separator"></div>
        <div class="nav-context-item danger" data-action="delete">Delete</div>
      </div>

      <div id="editor-container">
        <!-- Contextual Python status trigger (replaces old "Add notebook config" button) -->
        <div id="session-hover-trigger" class="session-hover-trigger">
          <button class="session-hover-action" id="session-hover-btn" onclick="handleSessionHoverClick()" title="Python environment status">
            <span id="session-hover-icon">
              <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="8" cy="8" r="7"/>
                <path d="M8 5v4M8 11v1"/>
              </svg>
            </span>
            <span id="session-hover-text">Python</span>
          </button>
        </div>
        <!-- Setup hints banner (project/venv only) -->
        <div id="setup-hints" class="setup-hints" style="display: none;">
          <div class="setup-hint" id="hint-no-project">
            <span class="hint-icon"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 4v9a1 1 0 001 1h10a1 1 0 001-1V6a1 1 0 00-1-1H8L6.5 3H3a1 1 0 00-1 1z"/></svg></span>
            <span class="hint-text">This folder isn't an mrmd project yet</span>
            <button class="hint-action" onclick="initializeProject()">Initialize Project</button>
            <button class="hint-dismiss" onclick="dismissHint('no-project')"></button>
          </div>
          <div class="setup-hint" id="hint-no-venv">
            <span class="hint-icon"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 2v12M12 2v12M4 8h8"/></svg></span>
            <span class="hint-text">No virtual environment found</span>
            <button class="hint-action" onclick="showVenvPicker()">Select venv</button>
            <button class="hint-dismiss" onclick="dismissHint('no-venv')"></button>
          </div>
        </div>
        <div id="editor"></div>
      </div>

      <!-- Table of Contents Sidebar -->
      <div id="toc-sidebar" class="toc-sidebar">
        <button class="sidebar-toggle toc-toggle" id="toc-toggle" title="Collapse"></button>
        <div class="toc-header">On This Page</div>
        <div class="toc-list" id="toc-list">
          <div class="toc-empty">No headings found</div>
        </div>
      </div>
      <!-- Floating toggle when TOC is collapsed -->
      <button class="sidebar-toggle-floating toc-toggle-floating" id="toc-toggle-floating" title="Expand"></button>
    </div>

    <!-- Side Rail -->
    <div class="side-rail" id="side-rail">
      <!-- Tool buttons -->
      <button class="rail-btn" data-panel="runtimes" title="Runtimes"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="3" width="12" height="10" rx="1"/><path d="M5 7h2M5 9h4"/></svg></button>
      <button class="rail-btn" data-panel="variables" title="Variables"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 4h4l2 8h4M10 4l2 8"/></svg></button>
      <button class="rail-btn" data-panel="artifact" title="Artifact Preview"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><path d="M2 5h12M5 5v9"/></svg></button>
      <button class="rail-btn" data-panel="ai" title="AI Commands"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="4" width="10" height="8" rx="2"/><circle cx="6" cy="8" r="1" fill="currentColor" stroke="none"/><circle cx="10" cy="8" r="1" fill="currentColor" stroke="none"/></svg></button>
      <button class="rail-btn" data-panel="help" title="Help"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M6 6a2 2 0 112 2v1M8 11v1"/></svg></button>

      <div class="rail-spacer"></div>

      <div class="rail-divider"></div>
      <button class="rail-btn" data-panel="settings" title="Settings">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
          <line x1="2" y1="4" x2="14" y2="4"/><circle cx="5" cy="4" r="1.5" fill="currentColor" stroke="none"/>
          <line x1="2" y1="8" x2="14" y2="8"/><circle cx="10" cy="8" r="1.5" fill="currentColor" stroke="none"/>
          <line x1="2" y1="12" x2="14" y2="12"/><circle cx="7" cy="12" r="1.5" fill="currentColor" stroke="none"/>
        </svg>
      </button>
    </div>

    <!-- Panel: Runtimes -->
    <div class="rail-panel" id="panel-runtimes">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Runtimes</span>
        <button class="rail-panel-refresh" id="runtimes-refresh" title="Refresh"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8a6 6 0 0111.5-2.5M14 8a6 6 0 01-11.5 2.5M2 3v3h3M14 13v-3h-3"/></svg></button>
        <button class="rail-panel-close" data-close-panel="runtimes"></button>
      </div>
      <div class="rail-panel-content">
        <div id="runtimes-list" class="runtimes-list">
          <div class="runtimes-empty">No running runtimes</div>
        </div>
      </div>
    </div>

    <!-- Panel: Variables -->
    <div class="rail-panel" id="panel-variables">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Variables</span>
        <button class="rail-panel-refresh" id="variables-refresh" title="Refresh"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8a6 6 0 0111.5-2.5M14 8a6 6 0 01-11.5 2.5M2 3v3h3M14 13v-3h-3"/></svg></button>
        <button class="rail-panel-close" data-close-panel="variables"></button>
      </div>
      <div class="rail-panel-content">
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Environment</div>
          <div id="variables-list">
            <div class="var-item">
              <div class="var-item-color" style="background: var(--text-dim);"></div>
              <span class="var-item-name">No session</span>
              <span class="var-item-type">Start a runtime to see variables</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Panel: Artifact Preview -->
    <div class="rail-panel rail-panel-artifact" id="panel-artifact">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Artifact</span>
        <button class="rail-panel-btn" id="artifact-clear" title="Clear"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 4l8 8M4 12l8-8"/></svg></button>
        <button class="rail-panel-btn" id="artifact-reload" title="Reload"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8a6 6 0 0111.5-2.5M14 8a6 6 0 01-11.5 2.5M2 3v3h3M14 13v-3h-3"/></svg></button>
        <button class="rail-panel-close" data-close-panel="artifact"></button>
      </div>
      <div class="artifact-content">
        <iframe id="artifact-iframe" sandbox="allow-scripts allow-same-origin allow-forms allow-modals" title="Artifact Preview"></iframe>
      </div>
      <div class="artifact-status" id="artifact-status">
        <span class="artifact-status-text">No artifact yet. Run HTML, CSS, or JS cells to build.</span>
      </div>
    </div>

    <!-- Panel: Source -->
    <div class="rail-panel rail-panel-wide" id="panel-source">
      <div class="rail-panel-header">
        <button class="source-back-btn" id="source-back" title="Back" disabled></button>
        <span class="rail-panel-title" id="source-title">Source</span>
        <button class="rail-panel-close" data-close-panel="source"></button>
      </div>
      <div class="source-file-path" id="source-file"></div>
      <div class="rail-panel-content source-content">
        <pre class="source-code" id="source-code"><code>Press F12 on a symbol to view its source code.</code></pre>
      </div>
    </div>

    <!-- Panel: Help -->
    <div class="rail-panel" id="panel-help">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Help</span>
        <button class="rail-panel-close" data-close-panel="help"></button>
      </div>
      <div class="rail-panel-content">
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Keyboard Shortcuts</div>
          <div class="rail-panel-item">
            <span class="rail-panel-item-label">Run cell</span>
            <span class="rail-panel-item-meta">Ctrl+Enter</span>
          </div>
          <div class="rail-panel-item">
            <span class="rail-panel-item-label">Run all cells</span>
            <span class="rail-panel-item-meta">Ctrl+Shift+Enter</span>
          </div>
          <div class="rail-panel-item">
            <span class="rail-panel-item-label">Open file</span>
            <span class="rail-panel-item-meta">Ctrl+P</span>
          </div>
          <div class="rail-panel-item">
            <span class="rail-panel-item-label">Toggle rail</span>
            <span class="rail-panel-item-meta">Ctrl+\</span>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Tips</div>
          <div class="rail-panel-item">
            <div class="rail-panel-item-icon"></div>
            <span class="rail-panel-item-label">Use ```python to create code cells</span>
          </div>
          <div class="rail-panel-item">
            <div class="rail-panel-item-icon"></div>
            <span class="rail-panel-item-label">Click the play button to run code</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Panel: Settings -->
    <div class="rail-panel" id="panel-settings">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Settings</span>
        <button class="rail-panel-close" data-close-panel="settings"></button>
      </div>
      <div class="rail-panel-content">
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Appearance</div>
          <div class="rail-panel-item" onclick="cycleTheme()">
            <span class="rail-panel-item-label">Theme</span>
            <span class="rail-panel-item-meta" id="settings-theme">github</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Panel: AI Commands -->
    <div class="rail-panel" id="panel-ai">
      <div class="rail-panel-header">
        <span class="rail-panel-title">AI Commands</span>
        <span class="ai-keyboard-hint" id="ai-keyboard-hint" style="display: none;">Press key or Esc</span>
        <button class="rail-panel-close" data-close-panel="ai"></button>
      </div>
      <div class="rail-panel-content">
        <div id="ai-panel-status" class="ai-panel-status" style="display: none;">
          <span class="ai-status-icon"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 2l6 12H2L8 2zM8 6v4M8 12v1"/></svg></span>
          <span class="ai-status-text">AI server not connected</span>
        </div>
        <div id="ai-progress" class="ai-progress" style="display: none;">
          <div class="ai-progress-header">
            <span class="ai-progress-title">Working...</span>
            <span class="ai-progress-model" id="ai-progress-model"></span>
          </div>
          <div class="ai-progress-models" id="ai-progress-models"></div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Quality <span class="ai-level-hint">Shift+1-5</span></div>
          <div class="ai-juice-selector">
            <button class="ai-juice-btn" data-juice="0" title="Quick - Fast & cheap (Shift+1)">1</button>
            <button class="ai-juice-btn selected" data-juice="1" title="Balanced - Good quality (Shift+2)">2</button>
            <button class="ai-juice-btn" data-juice="2" title="Deep - Deep reasoning (Shift+3)">3</button>
            <button class="ai-juice-btn" data-juice="3" title="Maximum - Best single model (Shift+4)">4</button>
            <button class="ai-juice-btn" data-juice="4" title="Ultimate - Multi-model (Shift+5)">5</button>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Reasoning <span class="ai-level-hint">0-5</span></div>
          <div class="ai-juice-selector">
            <button class="ai-reasoning-btn" data-reasoning="0" title="Off - No extended thinking (0)">0</button>
            <button class="ai-reasoning-btn selected" data-reasoning="1" title="Minimal - Light reasoning (1)">1</button>
            <button class="ai-reasoning-btn" data-reasoning="2" title="Low - Some reasoning (2)">2</button>
            <button class="ai-reasoning-btn" data-reasoning="3" title="Medium - Moderate reasoning (3)">3</button>
            <button class="ai-reasoning-btn" data-reasoning="4" title="High - Deep reasoning (4)">4</button>
            <button class="ai-reasoning-btn" data-reasoning="5" title="Maximum - Full reasoning budget (5)">5</button>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Text</div>
          <div class="ai-cmd" data-cmd="fix-grammar" data-key="g">
            <span class="ai-cmd-key">g</span>
            <span class="ai-cmd-label">Fix Grammar</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="fix-transcription" data-key="t">
            <span class="ai-cmd-key">t</span>
            <span class="ai-cmd-label">Fix Transcription</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="finish-sentence" data-key="s">
            <span class="ai-cmd-key">s</span>
            <span class="ai-cmd-label">Complete Sentence</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
          <div class="ai-cmd" data-cmd="finish-paragraph" data-key="p">
            <span class="ai-cmd-key">p</span>
            <span class="ai-cmd-label">Complete Paragraph</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Code</div>
          <div class="ai-cmd" data-cmd="finish-code-line" data-key="l">
            <span class="ai-cmd-key">l</span>
            <span class="ai-cmd-label">Complete Line</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
          <div class="ai-cmd" data-cmd="finish-code-section" data-key="c">
            <span class="ai-cmd-key">c</span>
            <span class="ai-cmd-label">Complete Section</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
          <div class="ai-cmd" data-cmd="document-code" data-key="d">
            <span class="ai-cmd-key">d</span>
            <span class="ai-cmd-label">Add Docstrings</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="add-types" data-key="y">
            <span class="ai-cmd-key">y</span>
            <span class="ai-cmd-label">Add Type Hints</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="improve-names" data-key="n">
            <span class="ai-cmd-key">n</span>
            <span class="ai-cmd-label">Improve Names</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="refactor" data-key="r">
            <span class="ai-cmd-key">r</span>
            <span class="ai-cmd-label">Refactor Code</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Document</div>
          <div class="ai-cmd" data-cmd="document-continue" data-key="o">
            <span class="ai-cmd-key">o</span>
            <span class="ai-cmd-label">Continue Document</span>
            <span class="ai-cmd-hint">append</span>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Comments</div>
          <div class="ai-cmd" data-cmd="address-comment" data-key="m">
            <span class="ai-cmd-key">m</span>
            <span class="ai-cmd-label">Address Nearby</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
          <div class="ai-cmd" data-cmd="address-all-comments" data-key="M">
            <span class="ai-cmd-key">M</span>
            <span class="ai-cmd-label">Address All</span>
            <span class="ai-cmd-hint">document</span>
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- Hidden elements for JavaScript compatibility -->
  <div style="display: none;">
    <span id="status-file"></span>
    <span id="status-theme">github</span>
  </div>

  <!-- File Picker Modal -->
  <div class="modal-overlay" id="file-picker-overlay">
    <div class="file-picker">
      <div class="picker-header">
        <span class="picker-icon"><svg viewBox="0 0 16 16"><circle cx="7" cy="7" r="4"/><path d="M10 10l3.5 3.5"/></svg></span>
        <input type="text" class="picker-input" id="file-search" placeholder="Find or create file... (type path to create)" autocomplete="off" spellcheck="false">
        <span class="picker-mode" id="picker-mode" style="display: none;">PATH</span>
        <span class="picker-hint">esc</span>
      </div>
      <div class="picker-context" id="picker-context" style="display: none;">
        <span>IN:</span>
        <span class="picker-context-path" id="picker-context-path"></span>
        <span class="picker-context-hint">[Backspace to go up]</span>
      </div>
      <div class="picker-body">
        <div class="picker-list" id="file-list"></div>
        <div class="picker-preview">
          <div class="preview-header">Preview</div>
          <div class="preview-content" id="preview-content">Select a file to preview</div>
        </div>
      </div>
      <div class="picker-footer" id="picker-footer">
        <span><kbd></kbd> navigate</span>
        <span><kbd></kbd> open</span>
        <span><kbd></kbd> create</span>
        <span><kbd>Tab</kbd> complete</span>
        <span><kbd>Esc</kbd> close</span>
      </div>
    </div>
  </div>

  <!-- Venv Picker Modal -->
  <div class="modal-overlay" id="venv-picker-overlay">
    <div class="venv-picker">
      <div class="picker-header">
        <span class="picker-icon"><svg viewBox="0 0 16 16"><path d="M8 1L14.5 5v6L8 15L1.5 11V5L8 1z"/></svg></span>
        <input type="text" class="picker-input" id="venv-search" placeholder="Search environments..." autocomplete="off" spellcheck="false">
        <span class="picker-hint">esc</span>
      </div>
      <div class="picker-list" id="venv-list" style="max-height: 400px;"></div>
      <div class="picker-custom-path">
        <input type="text" id="custom-python-path" placeholder="Or enter path to Python environment..." autocomplete="off" spellcheck="false">
      </div>
      <div class="picker-footer">
        <span><kbd></kbd> navigate</span>
        <span><kbd></kbd> select</span>
        <span><kbd></kbd> new</span>
        <span><kbd>esc</kbd> close</span>
      </div>
    </div>
  </div>

  <!-- Notebook Open Dialog -->
  <div class="modal-overlay" id="notebook-dialog-overlay">
    <div class="notebook-dialog">
      <h3>Open Jupyter Notebook</h3>
      <p>Opening <span class="notebook-dialog-filename" id="notebook-dialog-filename"></span></p>
      <div class="notebook-options">
        <button class="notebook-option" id="notebook-sync-btn">
          <strong>Keep as Notebook</strong>
          <span>Edit in MRMD while keeping the .ipynb synced with Jupyter</span>
        </button>
        <button class="notebook-option convert" id="notebook-convert-btn">
          <strong>Convert to Markdown</strong>
          <span>Replace the .ipynb file with a .md file (cannot be undone)</span>
        </button>
      </div>
      <button class="notebook-dialog-cancel" id="notebook-cancel-btn">Cancel</button>
    </div>
  </div>

  <!-- Load mrmd-editor -->
  <script src="../mrmd-editor/dist/mrmd.iife.js"></script>

  <!-- Load xterm.js for terminal blocks -->
  <link rel="stylesheet" href="./node_modules/xterm/css/xterm.css">
  <script src="./node_modules/xterm/lib/xterm.js"></script>
  <script src="./node_modules/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
  <script src="./node_modules/xterm-addon-web-links/lib/xterm-addon-web-links.js"></script>

  <script>
    // =========================================================================
    // STATE
    // =========================================================================

    const state = {
      files: [],
      filteredFiles: [],
      recentFiles: [],
      selectedFileIndex: 0,
      previewRequestId: 0,
      venvs: [],
      filteredVenvs: [],
      filteredRuntimes: [],
      selectedVenvIndex: 0,
      venvQuery: '',
      runningRuntimes: [],
      pythonPort: null,
      pythonVenv: null,
      bashPort: null,
      bashSession: null,
      ptySession: null,  // PTY session for terminal blocks
      aiPort: null,
      currentFile: null,
      projectDir: null,
      editor: null,
      drive: null,
      homeDir: null,  // Will be set on init
      // New: Project state
      project: null,  // ProjectInfo from service
      // Enhanced file picker state
      pickerMode: 'fuzzy',  // 'fuzzy' | 'path' | 'create-file' | 'create-project'
      folderContext: null,  // Current folder being browsed (absolute path)
      createTarget: null,   // Path to create (file or project)
      // Session state (new)
      session: {
        name: null,           // e.g., "thesis:default"
        status: 'none',       // 'none' | 'starting' | 'connected' | 'error'
        config: null,         // Resolved session config from Project.resolveSession
        info: null,           // SessionInfo from SessionService (pid, port, etc.)
      },
      // Notebook sync state: maps shadow .md path to original .ipynb path
      syncedNotebooks: new Map(),
    };

    // DEBUG: Expose state to window for console debugging
    window._state = state;

    // =========================================================================
    // FSML HELPERS (for wiki-link completion)
    // =========================================================================

    /**
     * Parse a file path for wiki-link completion.
     * Simplified version of FSML.parsePath from mrmd-project.
     *
     * @param {string} path - Relative path (e.g., '02-getting-started/01-setup.md')
     * @returns {{path: string, title: string, name: string}}
     */
    function parseProjectFile(path) {
      if (!path) return { path: '', title: '', name: '' };

      // Get filename without directory
      const segments = path.split('/');
      const filename = segments[segments.length - 1];

      // Remove extension
      let name = filename.replace(/\.[^.]+$/, '');

      // Remove numeric prefix (e.g., "01-" or "02_")
      name = name.replace(/^\d+[-_]/, '');

      // Derive title: replace - and _ with spaces, title case
      const title = name
        .replace(/[-_]/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');

      return { path, title, name };
    }

    /**
     * Parse all project files for wiki-link completion.
     *
     * @param {string[]} files - Array of relative paths
     * @returns {Array<{path: string, title: string, name: string}>}
     */
    function parseProjectFiles(files) {
      if (!files) return [];
      return files
        .filter(f => f.endsWith('.md') && f !== 'mrmd.md')
        .map(parseProjectFile);
    }

    // =========================================================================
    // FILE PICKER MODE DETECTION
    // =========================================================================

    /**
     * Detects the picker mode based on query string.
     * Returns: { mode: 'fuzzy'|'path', mayCreate: boolean, isFile: boolean, basePath: string|null }
     */
    function detectPickerMode(query) {
      // Empty query = fuzzy with recents
      if (!query || !query.trim()) {
        return { mode: 'fuzzy', mayCreate: false, isFile: false, basePath: null };
      }

      // Path prefixes trigger path mode
      if (query.match(/^[.~\/]/)) {
        const endsWithMd = query.toLowerCase().endsWith('.md');
        const endsWithIpynb = query.toLowerCase().endsWith('.ipynb');
        const endsWithSlash = query.endsWith('/');
        const hasExtension = query.includes('.') && !query.endsWith('.');

        // Determine base path
        let basePath = null;
        if (query.startsWith('~/')) {
          basePath = query.replace('~', state.homeDir || '/home');
        } else if (query.startsWith('/')) {
          basePath = query;
        } else if (query.startsWith('./') || query.startsWith('../')) {
          // Relative to current file's directory or project root
          const baseDir = state.project?.root || (state.currentFile ? state.currentFile.replace(/\/[^/]+$/, '') : null);
          if (baseDir) {
            basePath = resolvePath(query, baseDir);
          }
        }

        if (endsWithMd || endsWithIpynb) {
          return { mode: 'path', mayCreate: true, isFile: true, basePath };
        }

        if (endsWithSlash || !hasExtension) {
          return { mode: 'path', mayCreate: true, isFile: false, basePath };
        }

        return { mode: 'path', mayCreate: false, isFile: false, basePath };
      }

      // Check if query looks like it wants to create something
      // (no matches and valid filename pattern)
      const looksLikeFilename = /^[\w-]+\.(md|ipynb)$/i.test(query);
      const looksLikeFolderName = /^[\w-]+$/.test(query) && !query.includes('.');

      return {
        mode: 'fuzzy',
        mayCreate: looksLikeFilename || looksLikeFolderName,
        isFile: looksLikeFilename,
        basePath: null
      };
    }

    /**
     * Resolve relative path to absolute
     */
    function resolvePath(relativePath, basePath) {
      if (relativePath.startsWith('/')) return relativePath;
      if (relativePath.startsWith('~/')) {
        return relativePath.replace('~', state.homeDir || '/home');
      }

      const parts = basePath.split('/').filter(p => p);
      const relParts = relativePath.split('/').filter(p => p);

      for (const part of relParts) {
        if (part === '.') continue;
        if (part === '..') {
          parts.pop();
        } else {
          parts.push(part);
        }
      }

      return '/' + parts.join('/');
    }

    // =========================================================================
    // FUZZY MATCHING (fzf-style with path support)
    // =========================================================================

    function fuzzyMatch(pattern, str) {
      if (!pattern) return { score: 0, matches: [] };

      const pLower = pattern.toLowerCase();
      const sLower = str.toLowerCase();
      let pi = 0;
      let score = 0;
      const matches = [];
      let prevMatch = -1;
      let consecutive = 0;

      for (let si = 0; si < str.length && pi < pattern.length; si++) {
        if (sLower[si] === pLower[pi]) {
          matches.push(si);

          // Scoring
          if (prevMatch === si - 1) {
            consecutive++;
            score += 2 + consecutive;
          } else {
            consecutive = 0;
            score += 1;
          }

          // Bonus for word boundaries
          if (si === 0 || '/._-'.includes(str[si - 1])) {
            score += 5;
          }

          // Bonus for uppercase after lowercase (camelCase)
          if (si > 0 && str[si] === str[si].toUpperCase() && str[si - 1] === str[si - 1].toLowerCase()) {
            score += 3;
          }

          prevMatch = si;
          pi++;
        }
      }

      if (pi !== pattern.length) return { score: 0, matches: [] };
      return { score, matches };
    }

    // Match against full path, return separate matches for name and dir
    function fuzzyMatchPath(pattern, fullPath) {
      // Create display path (~/Projects/foo/file.md)
      const displayPath = fullPath.replace(/^\/home\/[^/]+/, '~');
      const lastSlash = displayPath.lastIndexOf('/');
      const dir = lastSlash >= 0 ? displayPath.slice(0, lastSlash) : '';
      const name = lastSlash >= 0 ? displayPath.slice(lastSlash + 1) : displayPath;

      if (!pattern) return { score: 0, nameMatches: [], dirMatches: [], displayPath, dir, name };

      // Try matching filename first (higher priority)
      const nameResult = fuzzyMatch(pattern, name);
      if (nameResult.score > 0) {
        return {
          score: nameResult.score * 2,  // Filename matches worth more
          nameMatches: nameResult.matches,
          dirMatches: [],
          displayPath,
          dir,
          name,
        };
      }

      // Try matching full path
      const pathResult = fuzzyMatch(pattern, displayPath);
      if (pathResult.score > 0) {
        // Split matches into dir and name portions
        const nameMatches = [];
        const dirMatches = [];
        for (const idx of pathResult.matches) {
          if (idx <= lastSlash) {
            dirMatches.push(idx);
          } else {
            nameMatches.push(idx - lastSlash - 1);
          }
        }
        return {
          score: pathResult.score,
          nameMatches,
          dirMatches,
          displayPath,
          dir,
          name,
        };
      }

      return { score: 0, nameMatches: [], dirMatches: [], displayPath, dir, name };
    }

    function highlightMatches(str, matches) {
      if (!matches || !matches.length) return escapeHtml(str);

      let result = '';
      let lastIndex = 0;
      const sortedMatches = [...matches].sort((a, b) => a - b);

      for (const idx of sortedMatches) {
        if (idx >= str.length) continue;
        result += escapeHtml(str.slice(lastIndex, idx));
        result += `<span class="match">${escapeHtml(str[idx])}</span>`;
        lastIndex = idx + 1;
      }

      result += escapeHtml(str.slice(lastIndex));
      return result;
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // =========================================================================
    // FILE PICKER
    // =========================================================================

    function showFilePicker() {
      document.getElementById('file-picker-overlay').classList.add('visible');
      const input = document.getElementById('file-search');
      input.value = '';
      input.focus();

      // Load recent files first
      loadRecentFiles();

      // Start scanning
      electronAPI.scanFiles();
    }

    function hideFilePicker() {
      document.getElementById('file-picker-overlay').classList.remove('visible');
      resetPickerState();
    }

    async function loadRecentFiles() {
      const recent = await electronAPI.getRecent();
      state.recentFiles = recent.files || [];
      filterFiles('');
    }

    function filterFiles(query, { preserveSelection = false } = {}) {
      // Remember current selection before filtering
      const previousSelectedPath = state.filteredFiles[state.selectedFileIndex]?.path;

      // Detect picker mode
      const modeInfo = detectPickerMode(query);
      state.pickerMode = modeInfo.mode;
      state.createTarget = modeInfo.mayCreate ? query : null;

      // Update UI mode indicator
      const modeEl = document.getElementById('picker-mode');
      if (modeInfo.mode === 'path') {
        modeEl.style.display = 'inline';
        modeEl.textContent = 'PATH';
      } else {
        modeEl.style.display = 'none';
      }

      // Update folder context UI
      const contextEl = document.getElementById('picker-context');
      const contextPathEl = document.getElementById('picker-context-path');
      if (state.folderContext) {
        contextEl.style.display = 'flex';
        contextPathEl.textContent = state.folderContext.replace(state.homeDir, '~');
      } else {
        contextEl.style.display = 'none';
      }

      const results = [];

      // Score all files
      const allFiles = [...new Set([...state.recentFiles.map(f => f.path), ...state.files])];

      // Determine effective query for filtering
      let effectiveQuery = query;
      if (state.folderContext) {
        // When in folder context, filter within that folder
        effectiveQuery = query; // Just use the typed part
      }

      for (const filePath of allFiles) {
        // In folder context, only show files in that folder
        if (state.folderContext) {
          if (!filePath.startsWith(state.folderContext + '/')) continue;
          // For folder context, match against relative path
          const relativePath = filePath.slice(state.folderContext.length + 1);
          const matchResult = fuzzyMatchPath(effectiveQuery, relativePath);
          const isRecent = state.recentFiles.some(f => f.path === filePath);
          const recentEntry = state.recentFiles.find(f => f.path === filePath);

          if (!effectiveQuery || matchResult.score > 0) {
            results.push({
              path: filePath,
              name: matchResult.name,
              dir: matchResult.dir,
              score: matchResult.score + (isRecent ? 100 : 0),
              nameMatches: matchResult.nameMatches,
              dirMatches: matchResult.dirMatches,
              isRecent,
              opened: recentEntry?.opened,
              isFolder: false,
            });
          }
        } else {
          // Normal mode - match against full path
          const matchResult = fuzzyMatchPath(effectiveQuery, filePath);
          const isRecent = state.recentFiles.some(f => f.path === filePath);
          const recentEntry = state.recentFiles.find(f => f.path === filePath);

          // Include if no query OR if has a match
          if (!effectiveQuery || matchResult.score > 0) {
            results.push({
              path: filePath,
              name: matchResult.name,
              dir: matchResult.dir,
              score: matchResult.score + (isRecent ? 100 : 0),
              nameMatches: matchResult.nameMatches,
              dirMatches: matchResult.dirMatches,
              isRecent,
              opened: recentEntry?.opened,
              isFolder: false,
            });
          }
        }
      }

      // Also include folders from the file paths (for browsing)
      const folders = new Set();
      for (const filePath of allFiles) {
        const parts = filePath.split('/');
        let current = '';
        for (let i = 0; i < parts.length - 1; i++) {
          current = current ? current + '/' + parts[i] : parts[i];
          if (current.startsWith('/')) folders.add(current);
        }
      }

      // Add folder matches if in path mode or no query
      if (modeInfo.mode === 'path' || !query) {
        for (const folderPath of folders) {
          // In folder context, only show immediate children
          if (state.folderContext) {
            if (!folderPath.startsWith(state.folderContext + '/')) continue;
            const relative = folderPath.slice(state.folderContext.length + 1);
            if (relative.includes('/')) continue; // Skip nested
          }

          const matchResult = fuzzyMatchPath(effectiveQuery, folderPath);
          if (!effectiveQuery || matchResult.score > 0) {
            // Check if already in results
            if (!results.some(r => r.path === folderPath)) {
              results.push({
                path: folderPath,
                name: folderPath.split('/').pop(),
                dir: folderPath.split('/').slice(0, -1).join('/').replace(state.homeDir, '~') || '~',
                score: matchResult.score,
                nameMatches: [],
                dirMatches: [],
                isRecent: false,
                isFolder: true,
              });
            }
          }
        }
      }

      // Sort by score (folders slightly lower to keep files first)
      results.sort((a, b) => {
        if (a.isFolder && !b.isFolder) return 1;
        if (!a.isFolder && b.isFolder) return -1;
        return b.score - a.score;
      });

      state.filteredFiles = results.slice(0, 100);

      // Restore selection if preserving, otherwise reset to 0
      let newSelectedIndex = 0;
      if (preserveSelection && previousSelectedPath) {
        const foundIndex = state.filteredFiles.findIndex(f => f.path === previousSelectedPath);
        if (foundIndex !== -1) {
          newSelectedIndex = foundIndex;
        }
      }

      const selectionChanged = state.filteredFiles[newSelectedIndex]?.path !== previousSelectedPath;
      state.selectedFileIndex = newSelectedIndex;
      renderFileList(modeInfo);

      // Only load preview if selection changed or no previous selection (and not a folder)
      const selected = state.filteredFiles[newSelectedIndex];
      if (selected && !selected.isFolder && (!preserveSelection || selectionChanged)) {
        loadPreview(selected.path);
      }
    }

    function renderFileList(modeInfo = {}) {
      const list = document.getElementById('file-list');
      const query = document.getElementById('file-search').value;

      // Group files
      const recent = state.filteredFiles.filter(f => f.isRecent && !f.isFolder);
      const folders = state.filteredFiles.filter(f => f.isFolder);
      const other = state.filteredFiles.filter(f => !f.isRecent && !f.isFolder);

      let html = '';
      let currentIndex = 0;

      // Recent files
      if (recent.length > 0) {
        html += '<div class="picker-section"><div class="picker-section-title">Recent</div>';
        recent.forEach((f) => {
          html += renderFileItem(f, currentIndex++);
        });
        html += '</div>';
      }

      // Folders (in path mode or when browsing)
      if (folders.length > 0) {
        html += '<div class="picker-section"><div class="picker-section-title">Folders</div>';
        folders.forEach((f) => {
          html += renderFileItem(f, currentIndex++);
        });
        html += '</div>';
      }

      // Other files
      if (other.length > 0) {
        html += '<div class="picker-section"><div class="picker-section-title">Files</div>';
        other.forEach((f) => {
          html += renderFileItem(f, currentIndex++);
        });
        html += '</div>';
      }

      // Empty state
      if (state.filteredFiles.length === 0 && !modeInfo.mayCreate) {
        html = '<div class="empty-state">No files found</div>';
      }

      // Create options (at the bottom)
      if (query && (modeInfo.mayCreate || state.filteredFiles.length === 0)) {
        html += '<div class="picker-section picker-create-section">';

        // Calculate where the file would be created
        const createPath = state.folderContext
          ? `${state.folderContext}/${query.replace(/^\.\//, '')}`
          : (state.project?.root
            ? `${state.project.root}/${query.replace(/^\.\//, '')}`
            : query);

        const displayPath = createPath.replace(state.homeDir, '~');

        if (modeInfo.isFile || query.toLowerCase().endsWith('.md')) {
          // Create file option
          const fileName = query.endsWith('.md') ? query : query + '.md';
          const isSelected = currentIndex === state.selectedFileIndex;
          html += `
            <div class="picker-item create ${isSelected ? 'selected' : ''}"
                 data-index="${currentIndex}" data-action="create-file" data-create-path="${createPath}"
                 onclick="selectFileItem(${currentIndex})" ondblclick="createNewFile()">
              <span class="picker-item-icon">+</span>
              <span class="picker-item-name">Create: ${fileName}</span>
              <span class="picker-item-path">${displayPath}</span>
              ${isSelected ? '<span class="picker-item-action">[Enter]</span>' : ''}
            </div>
          `;
          currentIndex++;
        } else if (!modeInfo.isFile && query.length > 0) {
          // Create project option
          const isSelected = currentIndex === state.selectedFileIndex;
          html += `
            <div class="picker-item create ${isSelected ? 'selected' : ''}"
                 data-index="${currentIndex}" data-action="create-project" data-create-path="${createPath}"
                 onclick="selectFileItem(${currentIndex})" ondblclick="createNewProject()">
              <span class="picker-item-icon">+</span>
              <span class="picker-item-name">Create PROJECT: ${query}</span>
              <span class="picker-item-path">with mrmd.md, .venv</span>
              ${isSelected ? '<span class="picker-item-action">[Enter]</span>' : ''}
            </div>
          `;
          currentIndex++;
        }

        html += '</div>';
      }

      list.innerHTML = html;
    }

    function renderFileItem(file, index) {
      const selected = index === state.selectedFileIndex ? 'selected' : '';
      const timeAgo = file.opened ? formatTimeAgo(new Date(file.opened)) : '';
      const isFolder = file.isFolder;
      const isNotebook = file.path.endsWith('.ipynb');

      const icon = isFolder ? '<svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 4v9a1 1 0 001 1h10a1 1 0 001-1V6a1 1 0 00-1-1H8L6.5 3H3a1 1 0 00-1 1z"/></svg>' : (file.isRecent ? '' : '');
      const classes = `picker-item ${selected} ${isFolder ? 'folder' : ''} ${isNotebook ? 'notebook' : ''}`;
      const notebookBadge = isNotebook ? '<span class="picker-item-badge notebook">ipynb</span>' : '';

      return `
        <div class="${classes}" data-index="${index}" data-path="${file.path}" ${isFolder ? 'data-folder="true"' : ''}
             onclick="selectFileItem(${index})" ondblclick="${isFolder ? 'enterFolder' : 'openSelectedFile'}('${file.path.replace(/'/g, "\\'")}')">
          <span class="picker-item-icon">${icon}</span>
          <span class="picker-item-name">${highlightMatches(file.name, file.nameMatches)}</span>
          ${notebookBadge}
          <span class="picker-item-path">${highlightMatches(file.dir, file.dirMatches)}</span>
          ${isFolder ? '<span class="picker-item-action">[Tab to browse]</span>' : ''}
          ${timeAgo ? `<span class="picker-item-meta">${timeAgo}</span>` : ''}
        </div>
      `;
    }

    function selectFileItem(index) {
      state.selectedFileIndex = index;
      renderFileList();
      if (state.filteredFiles[index]) {
        loadPreview(state.filteredFiles[index].path);
      }

      // Scroll selected item into view
      const selected = document.querySelector('#file-list .picker-item.selected');
      if (selected) {
        selected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      }
    }

    async function loadPreview(filePath) {
      const preview = document.getElementById('preview-content');
      preview.textContent = 'Loading...';

      // Track request ID to prevent race conditions
      const requestId = ++state.previewRequestId;
      const result = await electronAPI.readPreview(filePath, 40);

      // Only update if this is still the current request
      if (requestId !== state.previewRequestId) return;

      if (result.success) {
        preview.textContent = result.preview || '(empty file)';
      } else {
        preview.textContent = 'Failed to load preview';
      }
    }

    async function openSelectedFile() {
      const selected = state.filteredFiles[state.selectedFileIndex];

      // Check if we're selecting a create option
      const selectedEl = document.querySelector('#file-list .picker-item.selected');
      if (selectedEl?.dataset.action === 'create-file') {
        await createNewFile();
        return;
      }
      if (selectedEl?.dataset.action === 'create-project') {
        await createNewProject();
        return;
      }

      // Handle folder selection (enter folder context)
      if (selected?.isFolder) {
        enterFolder(selected.path);
        return;
      }

      // Regular file selection
      if (!selected) return;
      hideFilePicker();
      await openFile(selected.path);
    }

    /**
     * Enter a folder context (browse inside)
     */
    function enterFolder(folderPath) {
      state.folderContext = folderPath;
      const input = document.getElementById('file-search');
      input.value = '';
      input.focus();
      filterFiles('');
    }

    /**
     * Exit folder context (go up one level)
     */
    function exitFolderContext() {
      if (!state.folderContext) return;

      // Go up one level or exit context
      const parent = state.folderContext.split('/').slice(0, -1).join('/');
      if (parent && parent !== state.homeDir) {
        state.folderContext = parent;
      } else {
        state.folderContext = null;
      }

      filterFiles(document.getElementById('file-search').value);
    }

    /**
     * Tab completion - complete selected item or enter folder
     */
    function tabComplete() {
      const selected = state.filteredFiles[state.selectedFileIndex];
      if (!selected) return;

      if (selected.isFolder) {
        // Enter folder
        enterFolder(selected.path);
      } else {
        // Complete filename in input
        const input = document.getElementById('file-search');
        input.value = selected.path.replace(state.homeDir, '~');
        filterFiles(input.value);
      }
    }

    /**
     * Create a new file
     */
    async function createNewFile() {
      const query = document.getElementById('file-search').value;
      let fileName = query.endsWith('.md') ? query : query + '.md';

      // Remove path prefixes for display
      fileName = fileName.replace(/^\.\//, '').replace(/^~\//, '');

      // Determine target path
      let targetPath;
      if (state.folderContext) {
        targetPath = `${state.folderContext}/${fileName}`;
      } else if (state.project?.root) {
        // Create in project root
        targetPath = `${state.project.root}/${fileName}`;
      } else {
        // Standalone file - ask for location or use query path
        const modeInfo = detectPickerMode(query);
        if (modeInfo.basePath) {
          targetPath = modeInfo.basePath;
          if (!targetPath.endsWith('.md')) targetPath += '.md';
        } else {
          console.warn('Cannot determine where to create file');
          return;
        }
      }

      console.log('Creating file:', targetPath);

      try {
        // Use the file service
        await electronAPI.file.create(targetPath, '');
        hideFilePicker();
        await openFile(targetPath);
      } catch (e) {
        console.error('Failed to create file:', e);
        alert('Failed to create file: ' + e.message);
      }
    }

    /**
     * Create a new project
     */
    async function createNewProject() {
      const query = document.getElementById('file-search').value;

      // Remove path prefixes
      let projectName = query.replace(/^\.\//, '').replace(/^~\//, '').replace(/\/$/, '');

      // Determine target path
      let targetPath;
      if (state.folderContext) {
        targetPath = `${state.folderContext}/${projectName}`;
      } else {
        const modeInfo = detectPickerMode(query);
        if (modeInfo.basePath) {
          targetPath = modeInfo.basePath;
        } else if (state.homeDir) {
          // Default to ~/Projects/<name> or just home/<name>
          targetPath = `${state.homeDir}/Projects/${projectName}`;
        } else {
          console.warn('Cannot determine where to create project');
          return;
        }
      }

      console.log('Creating project:', targetPath);

      try {
        // Use the project service
        const project = await electronAPI.project.create(targetPath);

        hideFilePicker();

        // Open the project's index file
        const indexPath = `${targetPath}/01-index.md`;
        await openFile(indexPath);
      } catch (e) {
        console.error('Failed to create project:', e);
        alert('Failed to create project: ' + e.message);
      }
    }

    /**
     * Reset picker state when hiding
     */
    function resetPickerState() {
      state.folderContext = null;
      state.pickerMode = 'fuzzy';
      state.createTarget = null;
    }

    // =========================================================================
    // VENV PICKER
    // =========================================================================

    async function showVenvPicker() {
      document.getElementById('venv-picker-overlay').classList.add('visible');
      state.venvs = [];
      state.filteredVenvs = [];
      state.filteredRuntimes = [];
      state.runningRuntimes = [];
      state.selectedVenvIndex = 0;
      state.venvQuery = '';

      const input = document.getElementById('venv-search');
      input.value = '';
      input.focus();

      document.getElementById('custom-python-path').value = '';

      renderVenvList();

      // Load running runtimes first (instant)
      const sessions = await electronAPI.session.list();
      // Map session format to runtime format for compatibility
      state.runningRuntimes = sessions.filter(s => s.alive).map(s => ({
        id: s.name,
        pid: s.pid,
        port: s.port,
        venv: s.venv,
        alive: s.alive
      }));
      filterVenvs(state.venvQuery);

      // Start discovery
      electronAPI.discoverVenvs(state.projectDir);
    }

    function hideVenvPicker() {
      document.getElementById('venv-picker-overlay').classList.remove('visible');
    }

    function filterVenvs(query) {
      state.venvQuery = query;
      const q = query.toLowerCase();

      // Filter runtimes
      state.filteredRuntimes = state.runningRuntimes.filter(rt => {
        if (!q) return true;
        return rt.id.toLowerCase().includes(q) ||
               (rt.venv || '').toLowerCase().includes(q);
      });

      // Filter venvs
      state.filteredVenvs = state.venvs.filter(v => {
        if (!q) return true;
        return v.projectName.toLowerCase().includes(q) ||
               v.path.toLowerCase().includes(q) ||
               (v.pythonVersion || '').toLowerCase().includes(q);
      });

      // Sort to match render order
      const sourceOrder = { system: 0, project: 1, recent: 2, conda: 3, pyenv: 4, discovered: 5 };
      state.filteredVenvs.sort((a, b) => {
        return (sourceOrder[a.source] ?? 6) - (sourceOrder[b.source] ?? 6);
      });

      state.selectedVenvIndex = 0;
      renderVenvList();
    }

    function addVenv(venv) {
      // Avoid duplicates
      if (!state.venvs.some(v => v.path === venv.path)) {
        state.venvs.push(venv);
        // Sort: project first, then recent, then discovered
        state.venvs.sort((a, b) => {
          const order = { project: 0, recent: 1, discovered: 2 };
          return (order[a.source] || 3) - (order[b.source] || 3);
        });
        filterVenvs(state.venvQuery);
      }
    }

    function renderVenvList() {
      const list = document.getElementById('venv-list');

      // Still loading
      if (state.runningRuntimes.length === 0 && state.venvs.length === 0) {
        list.innerHTML = '<div class="empty-state">Searching...</div>';
        return;
      }

      // No matches for search
      if (state.filteredRuntimes.length === 0 && state.filteredVenvs.length === 0) {
        list.innerHTML = '<div class="empty-state">No matching environments</div>';
        return;
      }

      let html = '';
      let globalIndex = 0;

      // Running runtimes section
      if (state.filteredRuntimes.length > 0) {
        html += '<div class="picker-section"><div class="picker-section-title">Running</div>';
        state.filteredRuntimes.forEach((rt) => {
          html += renderRuntimeItem(rt, globalIndex++);
        });
        html += '</div>';
      }

      const bySource = { system: [], project: [], recent: [], conda: [], pyenv: [], discovered: [] };
      state.filteredVenvs.forEach(v => {
        (bySource[v.source] || bySource.discovered).push(v);
      });

      // Render sections in order
      const sections = [
        { key: 'system', title: 'System' },
        { key: 'project', title: 'Project' },
        { key: 'recent', title: 'Recent' },
        { key: 'conda', title: 'Conda' },
        { key: 'pyenv', title: 'Pyenv' },
        { key: 'discovered', title: 'Discovered' },
      ];

      for (const { key, title } of sections) {
        if (bySource[key].length > 0) {
          html += `<div class="picker-section"><div class="picker-section-title">${title}</div>`;
          bySource[key].forEach(v => {
            html += renderVenvItem(v, globalIndex++);
          });
          html += '</div>';
        }
      }

      list.innerHTML = html;
    }

    function renderRuntimeItem(runtime, index) {
      const selected = index === state.selectedVenvIndex ? 'selected' : '';
      const venvDir = (runtime.venv || '').replace(/^\/home\/[^/]+/, '~');

      return `
        <div class="venv-item ${selected}" data-index="${index}" data-runtime-id="${runtime.id}"
             onclick="selectVenvItem(${index})" ondblclick="attachToRuntime('${runtime.id}')">
          <div class="venv-item-info">
            <div class="venv-item-name">${runtime.id}</div>
            <div class="venv-item-path">${venvDir}  port ${runtime.port}</div>
          </div>
          <span class="venv-item-version">pid ${runtime.pid}</span>
          <span class="venv-item-badge danger" onclick="event.stopPropagation(); killRuntimeAction('${runtime.id}')"
                style="cursor:pointer;">stop</span>
        </div>
      `;
    }

    function renderVenvItem(venv, index) {
      const selected = index === state.selectedVenvIndex ? 'selected' : '';
      const dir = venv.path.replace(/^\/home\/[^/]+/, '~');
      const isValid = venv.hasPython !== false;

      // Status: nothing if ready, "install" if needs mrmd-python, "invalid" if broken
      let status = '';
      if (!isValid) {
        status = '<span class="venv-item-badge" style="opacity:0.5">broken</span>';
      } else if (!venv.hasMrmdPython) {
        status = '<span class="venv-item-badge warning">install</span>';
      }

      return `
        <div class="venv-item ${selected}" data-index="${index}" data-path="${venv.path}"
             onclick="selectVenvItem(${index})" ondblclick="selectVenv()" style="${!isValid ? 'opacity:0.5' : ''}">
          <div class="venv-item-info">
            <div class="venv-item-name">${venv.projectName}</div>
            <div class="venv-item-path">${dir}</div>
          </div>
          ${venv.pythonVersion ? `<span class="venv-item-version">${venv.pythonVersion}</span>` : ''}
          ${status}
        </div>
      `;
    }

    function selectVenvItem(index) {
      state.selectedVenvIndex = index;
      renderVenvList();

      // Scroll selected item into view
      const selected = document.querySelector('#venv-list .venv-item.selected');
      if (selected) {
        selected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      }
    }

    async function selectVenv() {
      const numRuntimes = state.filteredRuntimes.length;

      // Check if selected item is a running runtime
      if (state.selectedVenvIndex < numRuntimes) {
        const runtime = state.filteredRuntimes[state.selectedVenvIndex];
        return attachToRuntime(runtime.id);
      }

      // Otherwise it's a venv
      const venvIndex = state.selectedVenvIndex - numRuntimes;
      if (venvIndex >= state.filteredVenvs.length) return;

      const venv = state.filteredVenvs[venvIndex];

      // Check if valid
      if (venv.hasPython === false) {
        alert('This venv is invalid (no Python found). Please select a different one.');
        return;
      }

      hideVenvPicker();

      // Check if needs install
      if (!venv.hasMrmdPython) {
        updatePythonStatus('loading', 'Installing...');
        try {
          const installResult = await electronAPI.installMrmdPython(venv.path);
          if (!installResult.success) {
            updatePythonStatus('error', 'Install failed');
            alert('Failed to install mrmd-python: ' + installResult.error);
            return;
          }
        } catch (e) {
          updatePythonStatus('error', 'Install failed');
          alert('Failed to install mrmd-python: ' + e.message);
          return;
        }
      }

      // Start runtime
      updatePythonStatus('loading', 'Starting...');
      try {
        const result = await electronAPI.startPython(venv.path);

        if (result.success) {
          state.pythonPort = result.port;
          state.pythonVenv = { ...venv, runtimeId: result.runtimeId };
          const statusLabel = result.reused ? `${result.runtimeId} (reused)` : result.runtimeId;
          updatePythonStatus('ready', statusLabel);
          console.log(`Python ready: ${result.runtimeId} on port ${result.port}${result.reused ? ' (reused)' : ''}`);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            const docName = state.currentFile.split('/').pop().replace(/\.md$/, '');
            const pythonClient = new mrmd.MRPClient(
              `http://127.0.0.1:${result.port}/mrp/v1`,
              { session: docName, languages: ['python', 'py', 'python3'] }
            );
            state.editor.registerRuntime('python', pythonClient);
            console.log('Registered Python runtime with existing editor');

            // Call pending retry callback if exists (from noRuntime prompt)
            if (window._pendingRuntimeRetry) {
              console.log('[venvPicker] Calling pending retry callback');
              const retryCallback = window._pendingRuntimeRetry;
              window._pendingRuntimeRetry = null;
              setTimeout(() => retryCallback(), 100);
            }
          }

          // Refresh runtimes list
          if (typeof refreshRuntimes === 'function') refreshRuntimes();
        } else {
          updatePythonStatus('error', 'Failed');
          alert('Failed to start Python: ' + result.error);
        }
      } catch (e) {
        updatePythonStatus('error', 'Failed');
        alert('Failed to start Python: ' + e.message);
      }
    }

    async function attachToRuntime(runtimeId, language = 'python') {
      console.log('Attaching to runtime:', runtimeId, 'language:', language);

      if (language === 'bash') {
        // Bash attach - just look up the session info
        try {
          const sessions = await electronAPI.bash.list();
          const session = sessions.find(s => s.name === runtimeId && s.alive);
          if (session) {
            state.bashPort = session.port;
            state.bashSession = { name: runtimeId, port: session.port, cwd: session.cwd };
            console.log('Attached to bash runtime on port', session.port);

            // Register bash runtime with existing editor if open (using auto-restart wrapper)
            if (state.editor && state.currentFile) {
              const bashClient = createAutoRestartingBashClient(session.port, runtimeId);
              state.editor.registerRuntime('bash', bashClient);
              console.log('Registered Bash runtime with existing editor');
            }

            // Update runtimes panel if open
            if (typeof renderRuntimesPanel === 'function') renderRuntimesPanel();
          } else {
            console.error('Bash session not found or not alive:', runtimeId);
          }
        } catch (e) {
          console.error('Failed to attach to bash runtime:', e);
        }
        return;
      }

      // Python attach (existing logic)
      hideVenvPicker();
      updatePythonStatus('loading', 'Attaching...');

      try {
        const result = await electronAPI.attachRuntime(runtimeId);
        if (result.success) {
          state.pythonPort = result.port;
          state.pythonVenv = { name: runtimeId, path: result.venv, runtimeId: runtimeId };
          updatePythonStatus('ready', runtimeId);
          console.log('Attached to runtime on port', result.port);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            const docName = state.currentFile.split('/').pop().replace(/\.md$/, '');
            const pythonClient = new mrmd.MRPClient(
              `http://127.0.0.1:${result.port}/mrp/v1`,
              { session: docName, languages: ['python', 'py', 'python3'] }
            );
            state.editor.registerRuntime('python', pythonClient);
            console.log('Registered Python runtime with existing editor');

            // Call pending retry callback if exists (from noRuntime prompt)
            if (window._pendingRuntimeRetry) {
              console.log('[attachRuntime] Calling pending retry callback');
              const retryCallback = window._pendingRuntimeRetry;
              window._pendingRuntimeRetry = null;
              setTimeout(() => retryCallback(), 100);
            }
          }

          // Update runtimes panel if open
          if (typeof renderRuntimesPanel === 'function') renderRuntimesPanel();
        } else {
          updatePythonStatus('error', 'Failed');
          alert('Failed to attach: ' + result.error);
        }
      } catch (e) {
        updatePythonStatus('error', 'Failed');
        alert('Failed to attach: ' + e.message);
      }
    }

    async function startNewRuntime(venvPath) {
      console.log('Starting NEW runtime for:', venvPath);
      hideVenvPicker();
      updatePythonStatus('loading', 'Starting new...');

      try {
        const result = await electronAPI.startPython(venvPath, true); // forceNew = true

        if (result.success) {
          state.pythonPort = result.port;
          state.pythonVenv = { path: venvPath, runtimeId: result.runtimeId };
          updatePythonStatus('ready', result.runtimeId);
          console.log(`New Python runtime: ${result.runtimeId} on port ${result.port}`);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            const docName = state.currentFile.split('/').pop().replace(/\.md$/, '');
            const pythonClient = new mrmd.MRPClient(
              `http://127.0.0.1:${result.port}/mrp/v1`,
              { session: docName, languages: ['python', 'py', 'python3'] }
            );
            state.editor.registerRuntime('python', pythonClient);
            console.log('Registered new Python runtime with editor');

            // Call pending retry callback if exists (from noRuntime prompt)
            if (window._pendingRuntimeRetry) {
              console.log('[startNewRuntime] Calling pending retry callback');
              const retryCallback = window._pendingRuntimeRetry;
              window._pendingRuntimeRetry = null;
              setTimeout(() => retryCallback(), 100);
            }
          }

          // Refresh runtimes list
          if (typeof refreshRuntimes === 'function') refreshRuntimes();
        } else {
          updatePythonStatus('error', 'Failed');
          alert('Failed to start Python: ' + result.error);
        }
      } catch (e) {
        updatePythonStatus('error', 'Failed');
        alert('Failed to start Python: ' + e.message);
      }
    }

    async function killRuntimeAction(runtimeId, language = 'python') {
      let result;
      if (language === 'bash') {
        result = await electronAPI.bash.stop(runtimeId);
        result = { success: result };
      } else {
        result = await electronAPI.killRuntime(runtimeId);
      }
      if (result.success) {
        // Remove from running runtimes and re-filter
        state.runningRuntimes = state.runningRuntimes.filter(r => r.id !== runtimeId);
        filterVenvs(state.venvQuery);

        // If we were using this runtime, clear state AND unregister from editor
        if (language === 'python' && state.pythonVenv &&
            (state.pythonVenv.runtimeId === runtimeId || state.pythonVenv.name === runtimeId)) {
          state.pythonPort = null;
          state.pythonVenv = null;
          updatePythonStatus('', 'python');

          // Unregister from editor so it knows there's no runtime
          if (state.editor?.unregisterRuntime) {
            state.editor.unregisterRuntime('python');
            console.log('[killRuntime] Unregistered Python runtime from editor');
          }
        } else if (language === 'bash' && state.bashSession?.name === runtimeId) {
          state.bashPort = null;
          state.bashSession = null;

          if (state.editor?.unregisterRuntime) {
            state.editor.unregisterRuntime('bash');
            console.log('[killRuntime] Unregistered Bash runtime from editor');
          }
        }

        // Update hints (may show setup prompt again)
        updateSetupHints();
      }
    }

    // =========================================================================
    // PROJECT NAVIGATION (FSML Implementation)
    // =========================================================================

    // Navigation state
    const navState = {
      expandedFolders: new Set(),
      dragging: null,        // Path being dragged
      renaming: null,        // Path being renamed
      contextTarget: null,   // Path for context menu
    };

    /**
     * Toggle folder expanded state
     */
    function toggleFolder(folderPath) {
      if (navState.expandedFolders.has(folderPath)) {
        navState.expandedFolders.delete(folderPath);
      } else {
        navState.expandedFolders.add(folderPath);
      }
      renderNavTreeFull();
    }

    /**
     * Expand all ancestors of a path
     */
    function expandToPath(filePath) {
      const parts = filePath.split('/');
      let current = '';
      for (let i = 0; i < parts.length - 1; i++) {
        current = current ? `${current}/${parts[i]}` : parts[i];
        navState.expandedFolders.add(current);
      }
    }

    /**
     * Get current file's relative path
     */
    function getCurrentRelativePath() {
      if (!state.currentFile || !state.project?.root) return null;
      return state.currentFile.replace(state.project.root + '/', '');
    }

    /**
     * Render the navigation tree
     */
    function renderNavTree(nodes, container, depth = 0) {
      const currentRelPath = getCurrentRelativePath();

      for (const node of nodes) {
        const isExpanded = navState.expandedFolders.has(node.path);
        const isSelected = node.path === currentRelPath;
        const isRenaming = node.path === navState.renaming;
        const hasChildren = node.children && node.children.length > 0;

        // Create item
        const item = document.createElement('div');
        item.className = 'nav-item' + (node.isFolder ? ' folder' : '') + (isSelected ? ' selected' : '');
        item.dataset.path = node.path;
        item.dataset.isFolder = node.isFolder ? 'true' : 'false';
        item.style.paddingLeft = (8 + depth * 16) + 'px';
        item.draggable = !isRenaming;

        // Expand arrow (for folders with children, or spacing placeholder for files)
        const expand = document.createElement('span');
        const showExpand = node.isFolder && hasChildren;
        expand.className = 'nav-expand' + (isExpanded ? ' expanded' : '') + (!showExpand ? ' hidden' : '');
        expand.textContent = '';
        if (showExpand) {
          expand.onclick = (e) => {
            e.stopPropagation();
            toggleFolder(node.path);
          };
        }
        item.appendChild(expand);

        // Label or rename input
        if (isRenaming) {
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'nav-rename-input';
          input.value = node.title;
          input.dataset.path = node.path;
          input.onclick = (e) => e.stopPropagation();
          input.onkeydown = (e) => {
            if (e.key === 'Enter') {
              finishRename(node.path, input.value);
            } else if (e.key === 'Escape') {
              cancelRename();
            }
          };
          input.onblur = () => {
            // Small delay to allow click events to fire first
            setTimeout(() => {
              if (navState.renaming === node.path) {
                finishRename(node.path, input.value);
              }
            }, 100);
          };
          item.appendChild(input);
          // Focus after render
          setTimeout(() => {
            input.focus();
            input.select();
          }, 0);
        } else {
          const label = document.createElement('span');
          label.className = 'nav-item-label';
          label.textContent = node.title;
          item.appendChild(label);
        }

        // Click handler
        item.onclick = (e) => {
          if (e.target.classList.contains('nav-expand')) return;
          if (node.isFolder) {
            // If folder has index.md, open it; otherwise toggle
            if (node.hasIndex) {
              const indexPath = state.project.root + '/' + node.path + '/index.md';
              openFile(indexPath);
            } else {
              toggleFolder(node.path);
            }
          } else {
            const fullPath = state.project.root + '/' + node.path;
            openFile(fullPath);
          }
        };

        // Double-click to rename
        item.ondblclick = (e) => {
          if (e.target.classList.contains('nav-expand')) return;
          e.preventDefault();
          startRename(node.path);
        };

        // Right-click context menu
        item.oncontextmenu = (e) => {
          e.preventDefault();
          showNavContextMenu(e.clientX, e.clientY, node.path, node.isFolder);
        };

        // Drag handlers
        item.ondragstart = (e) => {
          navState.dragging = node.path;
          item.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', node.path);
        };

        item.ondragend = () => {
          navState.dragging = null;
          clearDropTargets();
        };

        item.ondragover = (e) => {
          e.preventDefault();
          if (navState.dragging === node.path) return;

          clearDropTargets();

          // Determine drop position based on mouse position
          const rect = item.getBoundingClientRect();
          const y = e.clientY - rect.top;
          const height = rect.height;

          if (node.isFolder && y > height * 0.25 && y < height * 0.75) {
            // Drop INTO folder (middle zone)
            item.classList.add('drop-target');
          } else if (y < height * 0.5) {
            // Drop ABOVE
            item.classList.add('drop-above');
          } else {
            // Drop BELOW
            item.classList.add('drop-below');
          }

          e.dataTransfer.dropEffect = 'move';
        };

        item.ondragleave = () => {
          item.classList.remove('drop-target', 'drop-above', 'drop-below');
        };

        item.ondrop = async (e) => {
          e.preventDefault();
          e.stopPropagation();

          const fromPath = navState.dragging;
          if (!fromPath || fromPath === node.path) {
            clearDropTargets();
            return;
          }

          // Determine drop type
          const rect = item.getBoundingClientRect();
          const y = e.clientY - rect.top;
          const height = rect.height;

          let dropType = 'below';
          if (node.isFolder && y > height * 0.25 && y < height * 0.75) {
            dropType = 'into';
          } else if (y < height * 0.5) {
            dropType = 'above';
          }

          clearDropTargets();
          navState.dragging = null;

          await handleNavDrop(fromPath, node.path, dropType, node.isFolder);
        };

        container.appendChild(item);

        // Render children if expanded
        if (hasChildren && isExpanded) {
          const childContainer = document.createElement('div');
          childContainer.className = 'nav-children';
          childContainer.dataset.parent = node.path;
          container.appendChild(childContainer);
          renderNavTree(node.children, childContainer, depth + 1);
        }
      }
    }

    /**
     * Clear all drop target classes
     */
    function clearDropTargets() {
      document.querySelectorAll('.nav-item.drop-target, .nav-item.drop-above, .nav-item.drop-below, .nav-item.dragging')
        .forEach(el => el.classList.remove('drop-target', 'drop-above', 'drop-below', 'dragging'));
    }

    /**
     * Handle drop operation - reorder file with FSML conventions
     *
     * Uses FileService.reorder() which leverages FSML.computeNewPath()
     * to handle proper FSML ordering and sibling renumbering.
     */
    async function handleNavDrop(fromPath, toPath, dropType, toIsFolder) {
      if (!state.project?.root) return;

      // Don't drop on self
      if (fromPath === toPath) {
        console.log('Nav drop: same item, skipping');
        return;
      }

      // Map dropType to FSML position
      let position;
      if (dropType === 'into' && toIsFolder) {
        position = 'inside';
      } else if (dropType === 'above') {
        position = 'before';
      } else {
        position = 'after';
      }

      console.log(`Nav drop: ${fromPath} -> ${toPath} (${position})`);

      try {
        // Use FileService.reorder which uses FSML.computeNewPath for proper ordering
        const result = await electronAPI.file.reorder(
          state.project.root,
          fromPath,
          toPath,
          position
        );

        console.log('Reorder result:', result);

        // Refresh project data
        const project = await electronAPI.project.get(state.currentFile);
        state.project = project;

        // Update the current file path if it was moved
        if (state.currentFile && state.currentFile.includes(fromPath)) {
          const newCurrentFile = state.currentFile.replace(fromPath, result.movedFile);
          state.currentFile = newCurrentFile;
        }

        renderNavTreeFull();
      } catch (e) {
        console.error('Reorder failed:', e);
        alert('Failed to reorder: ' + e.message);
      }
    }

    /**
     * Start inline rename
     */
    function startRename(path) {
      navState.renaming = path;
      renderNavTreeFull();
    }

    /**
     * Cancel rename
     */
    function cancelRename() {
      navState.renaming = null;
      renderNavTreeFull();
    }

    /**
     * Finish rename - move file to new name
     */
    async function finishRename(oldPath, newTitle) {
      if (!navState.renaming || !state.project?.root) {
        navState.renaming = null;
        return;
      }

      navState.renaming = null;

      // Parse the old path to get directory and extract order prefix
      const lastSlash = oldPath.lastIndexOf('/');
      const dir = lastSlash >= 0 ? oldPath.substring(0, lastSlash) : '';
      const oldFilename = lastSlash >= 0 ? oldPath.substring(lastSlash + 1) : oldPath;

      // Extract order prefix if present (e.g., "01-" from "01-intro.md")
      const orderMatch = oldFilename.match(/^(\d+-)/);
      const orderPrefix = orderMatch ? orderMatch[1] : '';

      // Build new filename
      const extension = oldFilename.endsWith('.md') ? '.md' : '';
      const isFolder = !oldFilename.includes('.');

      // Convert title to filename (lowercase, replace spaces with hyphens)
      const newSlug = newTitle.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      const newFilename = orderPrefix + newSlug + (isFolder ? '' : extension);
      const newPath = dir ? `${dir}/${newFilename}` : newFilename;

      if (newPath === oldPath) {
        renderNavTreeFull();
        return;
      }

      console.log(`Rename: ${oldPath} -> ${newPath}`);

      try {
        const result = await electronAPI.file.move(state.project.root, oldPath, newPath);

        // Update current file if it was renamed
        if (state.currentFile && state.currentFile.endsWith(oldPath)) {
          state.currentFile = state.project.root + '/' + result.movedFile;
        }

        // Refresh project
        const project = await electronAPI.project.get(state.currentFile || state.project.root + '/mrmd.md');
        state.project = project;

        renderNavTreeFull();
      } catch (e) {
        console.error('Rename failed:', e);
        alert('Failed to rename: ' + e.message);
        renderNavTreeFull();
      }
    }

    /**
     * Show context menu
     */
    function showNavContextMenu(x, y, path, isFolder) {
      navState.contextTarget = { path, isFolder };

      const menu = document.getElementById('nav-context-menu');
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      menu.classList.add('visible');

      // Close on click outside
      const closeHandler = (e) => {
        if (!menu.contains(e.target)) {
          hideNavContextMenu();
          document.removeEventListener('click', closeHandler);
        }
      };
      setTimeout(() => document.addEventListener('click', closeHandler), 0);
    }

    /**
     * Hide context menu
     */
    function hideNavContextMenu() {
      document.getElementById('nav-context-menu').classList.remove('visible');
      navState.contextTarget = null;
    }

    /**
     * Handle context menu action
     */
    async function handleNavContextAction(action) {
      const target = navState.contextTarget;
      hideNavContextMenu();

      if (!target || !state.project?.root) return;

      switch (action) {
        case 'new-file':
          await createNavFile(target.isFolder ? target.path : getParentPath(target.path));
          break;
        case 'new-folder':
          await createNavFolder(target.isFolder ? target.path : getParentPath(target.path));
          break;
        case 'rename':
          startRename(target.path);
          break;
        case 'reveal':
          const fullPath = state.project.root + '/' + target.path;
          electronAPI.shell.showItemInFolder(fullPath);
          break;
        case 'delete':
          await deleteNavItem(target.path);
          break;
      }
    }

    /**
     * Get parent path
     */
    function getParentPath(path) {
      const lastSlash = path.lastIndexOf('/');
      return lastSlash >= 0 ? path.substring(0, lastSlash) : '';
    }

    /**
     * Create new file in nav with default name, then start inline rename
     */
    async function createNavFile(parentPath) {
      // Use default name - user can rename inline after creation
      const fileName = 'untitled.md';
      const relativePath = parentPath ? `${parentPath}/${fileName}` : fileName;

      try {
        const result = await electronAPI.file.createInProject(state.project.root, relativePath, '# Untitled\n');

        if (!result.success) {
          console.error('Create file failed:', result.error);
          return;
        }

        const actualPath = result.path;

        // Expand parent folder
        if (parentPath) {
          navState.expandedFolders.add(parentPath);
        }

        // Refresh project
        const project = await electronAPI.project.get(state.currentFile);
        state.project = project;

        // Start inline rename for the new file
        navState.renaming = actualPath;
        renderNavTreeFull();

        // Open the new file
        await openFile(state.project.root + '/' + actualPath);
      } catch (e) {
        console.error('Create file failed:', e);
      }
    }

    /**
     * Create new folder in nav with default name, then start inline rename
     */
    async function createNavFolder(parentPath) {
      // Use default name
      const name = 'new-folder';
      const folderPath = parentPath ? `${parentPath}/${name}` : name;
      const indexPath = `${folderPath}/index.md`;

      try {
        const result = await electronAPI.file.createInProject(state.project.root, indexPath, `# New Folder\n`);

        if (!result.success) {
          console.error('Create folder failed:', result.error);
          return;
        }

        // Extract actual folder path from the result (in case FSML added ordering prefix)
        const actualIndexPath = result.path;
        const actualFolderPath = actualIndexPath.replace(/\/index\.md$/, '');

        // Expand parent and new folder
        if (parentPath) {
          navState.expandedFolders.add(parentPath);
        }
        navState.expandedFolders.add(actualFolderPath);

        // Refresh project
        const project = await electronAPI.project.get(state.currentFile);
        state.project = project;

        // Start inline rename for the new folder
        navState.renaming = actualFolderPath;
        renderNavTreeFull();
      } catch (e) {
        console.error('Create folder failed:', e);
      }
    }

    /**
     * Delete nav item
     */
    async function deleteNavItem(path) {
      const isFolder = !path.includes('.') || path.endsWith('/');
      const confirmMsg = isFolder
        ? `Delete folder "${path}" and all its contents?`
        : `Delete "${path}"?`;

      if (!confirm(confirmMsg)) return;

      try {
        const fullPath = state.project.root + '/' + path;
        await electronAPI.file.delete(fullPath);

        // If we deleted the current file, clear it
        if (state.currentFile && state.currentFile.startsWith(fullPath)) {
          // Try to open another file or just clear
          state.currentFile = null;
        }

        // Refresh
        const project = await electronAPI.project.get(state.project.root + '/mrmd.md');
        state.project = project;
        renderNavTreeFull();
      } catch (e) {
        console.error('Delete failed:', e);
        alert('Failed to delete: ' + e.message);
      }
    }

    /**
     * Full render of nav tree
     */
    function renderNavTreeFull() {
      const tree = document.getElementById('nav-tree');
      if (!tree || !state.project?.navTree) return;

      tree.innerHTML = '';
      renderNavTree(state.project.navTree, tree, 0);
    }

    /**
     * Update the navigation sidebar
     */
    function updateNavSidebar(project, currentFilePath) {
      const sidebar = document.getElementById('nav-sidebar');
      const title = document.getElementById('nav-title');

      if (!project) {
        sidebar.classList.remove('visible');
        return;
      }

      // Show sidebar
      sidebar.classList.add('visible');
      // Use config name, or fallback to folder name
      const folderName = project.root.split('/').pop() || 'Project';
      title.textContent = project.config?.name || folderName;

      // Auto-expand to current file
      if (currentFilePath) {
        const relativePath = currentFilePath.replace(project.root + '/', '');
        expandToPath(relativePath);
      }

      // Render tree
      renderNavTreeFull();

      console.log('Nav sidebar updated:', project.navTree.length, 'top-level items');
    }

    // Context menu click handler
    document.getElementById('nav-context-menu').addEventListener('click', (e) => {
      const item = e.target.closest('.nav-context-item');
      if (item) {
        handleNavContextAction(item.dataset.action);
      }
    });

    // Header config button - opens mrmd.md
    document.getElementById('nav-config-btn').addEventListener('click', () => {
      if (state.project?.root) {
        openFile(state.project.root + '/mrmd.md');
      }
    });

    // Make project title clickable to open root index.md
    document.getElementById('nav-title').addEventListener('click', () => {
      if (state.project?.root) {
        openFile(state.project.root + '/index.md');
      }
    });

    // Header new button
    document.getElementById('nav-new-btn').addEventListener('click', () => {
      createNavFile('');
    });

    // =========================================================================
    // SIDEBAR TOGGLE HANDLERS
    // =========================================================================

    // Nav sidebar toggle
    document.getElementById('nav-toggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const sidebar = document.getElementById('nav-sidebar');
      const toggle = document.getElementById('nav-toggle');
      const floatingToggle = document.getElementById('nav-toggle-floating');
      sidebar.classList.add('collapsed');
      sidebar.classList.remove('visible');
      toggle.textContent = '';
      floatingToggle.classList.add('visible');
      localStorage.setItem('mrmd-nav-collapsed', 'true');
    });

    document.getElementById('nav-toggle-floating').addEventListener('click', () => {
      const sidebar = document.getElementById('nav-sidebar');
      const toggle = document.getElementById('nav-toggle');
      const floatingToggle = document.getElementById('nav-toggle-floating');
      sidebar.classList.remove('collapsed');
      sidebar.classList.add('visible');
      toggle.textContent = '';
      floatingToggle.classList.remove('visible');
      localStorage.setItem('mrmd-nav-collapsed', 'false');
    });

    // TOC sidebar toggle
    document.getElementById('toc-toggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const sidebar = document.getElementById('toc-sidebar');
      const toggle = document.getElementById('toc-toggle');
      const floatingToggle = document.getElementById('toc-toggle-floating');
      sidebar.classList.add('collapsed');
      toggle.textContent = '';
      floatingToggle.classList.add('visible');
      localStorage.setItem('mrmd-toc-collapsed', 'true');
    });

    document.getElementById('toc-toggle-floating').addEventListener('click', () => {
      const sidebar = document.getElementById('toc-sidebar');
      const toggle = document.getElementById('toc-toggle');
      const floatingToggle = document.getElementById('toc-toggle-floating');
      sidebar.classList.remove('collapsed');
      toggle.textContent = '';
      floatingToggle.classList.remove('visible');
      localStorage.setItem('mrmd-toc-collapsed', 'false');
    });

    // Restore sidebar states on load
    if (localStorage.getItem('mrmd-nav-collapsed') === 'true') {
      const sidebar = document.getElementById('nav-sidebar');
      const toggle = document.getElementById('nav-toggle');
      sidebar.classList.add('collapsed');
      toggle.textContent = '';
      document.getElementById('nav-toggle-floating').classList.add('visible');
    }
    if (localStorage.getItem('mrmd-toc-collapsed') === 'true') {
      const sidebar = document.getElementById('toc-sidebar');
      const toggle = document.getElementById('toc-toggle');
      sidebar.classList.add('collapsed');
      toggle.textContent = '';
      document.getElementById('toc-toggle-floating').classList.add('visible');
    }

    // =========================================================================
    // NOTEBOOK HANDLING
    // =========================================================================

    /**
     * Show notebook open dialog and return user's choice
     * @param {string} ipynbPath - Path to the .ipynb file
     * @returns {Promise<'convert'|'sync'|null>} User's choice or null if cancelled
     */
    function showNotebookDialog(ipynbPath) {
      return new Promise((resolve) => {
        const overlay = document.getElementById('notebook-dialog-overlay');
        const filenameEl = document.getElementById('notebook-dialog-filename');
        const convertBtn = document.getElementById('notebook-convert-btn');
        const syncBtn = document.getElementById('notebook-sync-btn');
        const cancelBtn = document.getElementById('notebook-cancel-btn');

        // Show filename
        filenameEl.textContent = ipynbPath.split('/').pop();

        // Cleanup function
        const cleanup = () => {
          overlay.classList.remove('visible');
          convertBtn.onclick = null;
          syncBtn.onclick = null;
          cancelBtn.onclick = null;
          overlay.onclick = null;
        };

        convertBtn.onclick = () => { cleanup(); resolve('convert'); };
        syncBtn.onclick = () => { cleanup(); resolve('sync'); };
        cancelBtn.onclick = () => { cleanup(); resolve(null); };

        // Close on backdrop click
        overlay.onclick = (e) => {
          if (e.target === overlay) { cleanup(); resolve(null); }
        };

        overlay.classList.add('visible');
      });
    }

    /**
     * Convert notebook to markdown (deletes the .ipynb file)
     * @param {string} ipynbPath - Path to the .ipynb file
     * @returns {Promise<string|null>} Path to created .md file, or null if cancelled/failed
     */
    async function convertNotebookToMd(ipynbPath) {
      const confirmed = confirm(
        'This will convert the notebook to markdown and DELETE the .ipynb file.\n\n' +
        'This action cannot be undone. Continue?'
      );

      if (!confirmed) return null;

      try {
        const result = await electronAPI.notebook.convert(ipynbPath);
        if (!result.success) {
          alert('Conversion failed: ' + result.error);
          return null;
        }
        return result.mdPath;
      } catch (e) {
        alert('Conversion failed: ' + e.message);
        return null;
      }
    }

    /**
     * Start notebook sync (creates shadow .md file in .mrmd folder)
     * @param {string} ipynbPath - Path to the .ipynb file
     * @returns {Promise<string|null>} Path to shadow .md file, or null if failed
     */
    async function startNotebookSync(ipynbPath) {
      try {
        console.log('[notebook] startNotebookSync called with:', ipynbPath);
        const result = await electronAPI.notebook.startSync(ipynbPath);
        console.log('[notebook] startSync result:', result);
        if (!result.success) {
          alert('Failed to start notebook sync: ' + result.error);
          return null;
        }

        // Track the synced notebook
        console.log('[notebook] Adding to syncedNotebooks: key=', result.shadowPath, 'value=', ipynbPath);
        state.syncedNotebooks.set(result.shadowPath, ipynbPath);

        return result.shadowPath;
      } catch (e) {
        alert('Failed to start notebook sync: ' + e.message);
        return null;
      }
    }

    // =========================================================================
    // OPEN FILE
    // =========================================================================

    async function openFile(filePath) {
      // Normalize path - remove double slashes
      filePath = filePath.replace(/\/+/g, '/');
      console.log('Opening file:', filePath);

      // Cleanup: Stop any synced notebook bridge if we're switching away from it
      if (state.currentFile && state.syncedNotebooks.has(state.currentFile)) {
        const ipynbPath = state.syncedNotebooks.get(state.currentFile);
        // Only stop if we're not reopening the same notebook
        let isReopening = false;
        if (filePath.endsWith('.ipynb') && filePath === ipynbPath) {
          isReopening = true;
        }
        if (!isReopening && filePath !== state.currentFile) {
          console.log('Stopping notebook sync for:', ipynbPath);
          await electronAPI.notebook.stopSync(ipynbPath);
          state.syncedNotebooks.delete(state.currentFile);
        }
      }

      // Handle shadow .md files in .mrmd folder - auto-start sync
      if (filePath.includes('/.mrmd/') && filePath.endsWith('.md')) {
        const ipynbPath = filePath
          .replace('/.mrmd/', '/')
          .replace(/\.md$/, '.ipynb');

        // Check if corresponding .ipynb exists
        try {
          const fileInfo = await electronAPI.getFileInfo(ipynbPath);
          if (fileInfo.success) {
            console.log('Opening shadow file, starting sync for:', ipynbPath);
            const shadowPath = await startNotebookSync(ipynbPath);
            if (shadowPath) {
              filePath = shadowPath;
            }
          }
        } catch (e) {
          // .ipynb doesn't exist, just open the .md normally
          console.log('No corresponding .ipynb found, opening .md directly');
        }
      }

      // Handle Jupyter notebooks
      if (filePath.endsWith('.ipynb')) {
        // Check if already synced
        for (const [shadowPath, ipynb] of state.syncedNotebooks) {
          if (ipynb === filePath) {
            console.log('Notebook already synced, opening shadow:', shadowPath);
            filePath = shadowPath;
            break;
          }
        }

        // If still an .ipynb (not already synced), show dialog
        if (filePath.endsWith('.ipynb')) {
          const mode = await showNotebookDialog(filePath);
          if (!mode) return; // Cancelled

          if (mode === 'convert') {
            const mdPath = await convertNotebookToMd(filePath);
            if (!mdPath) return; // Conversion failed or cancelled
            filePath = mdPath;
          } else {
            const shadowPath = await startNotebookSync(filePath);
            if (!shadowPath) return; // Sync failed
            filePath = shadowPath;
          }
        }
      }

      document.getElementById('titlebar-title').textContent = 'Opening...';

      try {
        // === NEW: Get project info from service ===
        const project = await electronAPI.project.get(filePath);
        state.project = project;

        if (project) {
          console.log('Project detected:', project.root);
          console.log('Config:', project.config);
          console.log('Files:', project.files.length);
          console.log('NavTree:', project.navTree);
          updateNavSidebar(project, filePath);

          // Start watching for file changes
          electronAPI.project.watch(project.root);
        } else {
          console.log('No project found (standalone file)');
          updateNavSidebar(null);
          electronAPI.project.unwatch();
        }
        // === END NEW ===

        const result = await electronAPI.openFile(filePath);

        if (!result.success) {
          alert('Failed to open file: ' + (result.error || 'Unknown error'));
          return;
        }

        const { syncPort, docName, projectDir } = result;
        state.projectDir = projectDir;

        console.log('Sync on port', syncPort, 'doc:', docName);

        // Create drive
        if (state.drive) state.drive.destroy?.();
        state.drive = mrmd.drive(`ws://127.0.0.1:${syncPort}`);

        // Destroy existing editor
        if (state.editor) {
          // Clear cursor from awareness before destroying to prevent stale cursors
          // appearing as "anonymous" when navigating back to this document
          if (state.editor.awareness) {
            state.editor.awareness.setLocalStateField('cursor', null);
          }
          detachSyncStatusHandlers();
          state.editor.destroy?.();
          state.editor = null;
          document.getElementById('editor').innerHTML = '';
        }

        // Editor options
        const currentTheme = THEMES[currentThemeIndex];
        const editorOptions = {
          theme: currentTheme,
          cellControls: {
            enabled: true,
            position: 'line-start',
            buttons: { run: true, stop: true, clear: true },
            callbacks: {
              // Terminal launch callback - calls global handler set up by registerPtyWithEditor
              onLaunchTerminal: (block, blockIndex) => {
                if (window._mrmdLaunchTerminal) {
                  window._mrmdLaunchTerminal(block, blockIndex);
                } else {
                  console.warn('[cell-controls] Terminal launcher not ready');
                }
              },
            },
          },
          // Run JS in main window context (full DOM/console access)
          javascriptIsolation: 'none',
        };

        // Create JavaScript/HTML/CSS runtime (always available - runs in browser)
        // Isolation: 'none' = main window context (full DOM access), 'iframe' = sandboxed
        const jsRuntime = mrmd.createJavaScriptRuntime({
          defaultIsolation: editorOptions.javascriptIsolation === 'none' ? 'none' : 'iframe',
        });
        editorOptions.runtimes = { javascript: jsRuntime };

        // Add Python runtime if available
        if (state.pythonPort) {
          const pythonClient = new mrmd.MRPClient(
            `http://127.0.0.1:${state.pythonPort}/mrp/v1`,
            { session: docName, languages: ['python', 'py', 'python3'] }
          );
          editorOptions.runtimes.python = pythonClient;
        }

        // Open document
        state.editor = await state.drive.open(docName, '#editor', editorOptions);
        attachSyncStatusHandlers(state.editor);
        state.currentFile = filePath;

        // Add runtime CodeLens extensions for yaml config blocks
        addRuntimeCodeLensToEditor(state.editor);

        // Setup handler for "no runtime" event (shows inline prompt)
        setupNoRuntimeHandler(state.editor);

        // Add AI integration extensions for visual feedback
        addAiIntegrationToEditor(state.editor);

        // Add Ctrl-K and comment syntax extensions (if AI client is connected)
        addCtrlKAndCommentExtensions();

        // Add image paste handler for the editor
        setupImagePasteHandler(state.editor, filePath);

        // Setup asset URL resolver so images load correctly
        setupAssetResolver(state.editor, filePath);

        // Setup asset handler for saving plots/images from code execution
        setupExecutionAssetHandler(state.editor, filePath);

        // Setup view source handler (F12)
        state.editor.onViewSource(showSource);

        // Setup artifact panel execution hook
        setupArtifactExecutionHook();

        // Setup wiki-link completion with project files
        if (project && project.files) {
          const parsedFiles = parseProjectFiles(project.files);
          state.editor.setProjectFiles(parsedFiles);
          console.log(`Wiki-link completion enabled with ${parsedFiles.length} files`);
        }

        // Setup link navigation handlers
        setupLinkNavigation(state.editor, filePath, project);

        // Update UI
        document.getElementById('editor-container').style.display = 'block';

        // Show notebook indicator if this is a synced notebook
        console.log('[notebook] Checking sync status for filePath:', filePath);
        console.log('[notebook] syncedNotebooks keys:', [...state.syncedNotebooks.keys()]);
        const isNotebookSync = state.syncedNotebooks.has(filePath);
        console.log('[notebook] isNotebookSync:', isNotebookSync);
        if (isNotebookSync) {
          const ipynbPath = state.syncedNotebooks.get(filePath);
          document.getElementById('titlebar-title').textContent = ipynbPath.split('/').pop() + ' (synced)';
          document.getElementById('status-file').textContent = ipynbPath.replace(/^\/home\/[^/]+/, '~') + '  .md';
        } else {
          document.getElementById('titlebar-title').textContent = filePath.split('/').pop();
          document.getElementById('status-file').textContent = filePath.replace(/^\/home\/[^/]+/, '~');
        }

        // Initialize Table of Contents
        initializeTOC();

        console.log('File opened successfully');

        // Check for missing configuration and show hints
        updateSetupHints();

        // Resolve session from project config and auto-start if configured
        await resolveProjectSession();

        // Register global bash runtime (always available)
        registerBashWithEditor();

        // Register PTY for terminal blocks (```term)
        registerPtyWithEditor();

      } catch (e) {
        console.error('Error opening file:', e);
        alert('Error: ' + e.message);
      }
    }

    // =========================================================================
    // SIDE RAIL SYSTEM
    // =========================================================================

    const railState = {
      open: false,
      activePanel: null,
    };

    /**
     * Initialize the side rail system
     */
    function initSideRail() {
      const toggle = document.getElementById('rail-toggle');
      const rail = document.getElementById('side-rail');

      // Toggle button toggles the rail
      toggle?.addEventListener('click', () => {
        if (railState.open) {
          closeRail();
        } else {
          openRail();
        }
      });

      // Panel buttons
      document.querySelectorAll('.rail-btn[data-panel]').forEach(btn => {
        btn.addEventListener('click', () => {
          const panelId = btn.dataset.panel;
          togglePanel(panelId);
        });
      });

      // Close panel buttons
      document.querySelectorAll('[data-close-panel]').forEach(btn => {
        btn.addEventListener('click', () => {
          const panelId = btn.dataset.closePanel;
          closePanel(panelId);
        });
      });

      // Keyboard shortcut: Ctrl+\ to toggle rail
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === '\\') {
          e.preventDefault();
          if (railState.open) {
            closeRail();
          } else {
            openRail();
          }
        }
        // Escape closes active panel or rail
        if (e.key === 'Escape') {
          if (railState.activePanel) {
            closePanel(railState.activePanel);
          } else if (railState.open) {
            closeRail();
          }
        }
      });
    }

    /**
     * Open the side rail
     */
    function openRail() {
      const toggle = document.getElementById('rail-toggle');
      const rail = document.getElementById('side-rail');
      const content = document.querySelector('.content');

      railState.open = true;
      toggle?.classList.add('active');
      rail?.classList.add('open');
      content?.classList.add('rail-open');
    }

    /**
     * Close the side rail
     */
    function closeRail() {
      const toggle = document.getElementById('rail-toggle');
      const rail = document.getElementById('side-rail');
      const content = document.querySelector('.content');

      // Close any open panel first
      if (railState.activePanel) {
        closePanel(railState.activePanel);
      }

      railState.open = false;
      toggle?.classList.remove('active');
      rail?.classList.remove('open');
      content?.classList.remove('rail-open');
    }

    /**
     * Toggle a panel
     */
    function togglePanel(panelId) {
      if (railState.activePanel === panelId) {
        closePanel(panelId);
      } else {
        openPanel(panelId);
      }
    }

    /**
     * Open a panel
     */
    function openPanel(panelId) {
      // Close current panel if different
      if (railState.activePanel && railState.activePanel !== panelId) {
        closePanel(railState.activePanel);
      }

      const panel = document.getElementById(`panel-${panelId}`);
      const btn = document.querySelector(`.rail-btn[data-panel="${panelId}"]`);

      panel?.classList.add('open');
      btn?.classList.add('active');
      railState.activePanel = panelId;

      // Update settings theme display if settings panel
      if (panelId === 'settings') {
        const themeEl = document.getElementById('settings-theme');
        const statusTheme = document.getElementById('status-theme');
        if (themeEl && statusTheme) {
          themeEl.textContent = statusTheme.textContent;
        }
      }
    }

    /**
     * Close a panel
     */
    function closePanel(panelId) {
      const panel = document.getElementById(`panel-${panelId}`);
      const btn = document.querySelector(`.rail-btn[data-panel="${panelId}"]`);

      panel?.classList.remove('open');
      btn?.classList.remove('active');

      if (railState.activePanel === panelId) {
        railState.activePanel = null;
      }
    }

    // Initialize rail on page load
    document.addEventListener('DOMContentLoaded', () => {
      initSideRail();
    });

    // =========================================================================
    // VARIABLES PANEL
    // =========================================================================

    const variablesState = {
      variables: [],
      loading: false,
      error: null,
      lastRefresh: null,
    };

    /**
     * Fetch variables from the Python runtime
     */
    async function fetchVariables() {
      if (!state.pythonPort) {
        variablesState.variables = [];
        variablesState.error = 'No runtime connected';
        renderVariables();
        return;
      }

      variablesState.loading = true;
      renderVariables();

      try {
        const url = `http://127.0.0.1:${state.pythonPort}/mrp/v1/variables`;
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            session: 'default',
            filter: { excludePrivate: true }
          })
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();
        variablesState.variables = result.variables || [];
        variablesState.error = null;
        variablesState.lastRefresh = Date.now();
      } catch (err) {
        console.error('Failed to fetch variables:', err);
        variablesState.error = err.message;
        variablesState.variables = [];
      } finally {
        variablesState.loading = false;
        renderVariables();
      }
    }

    /**
     * Render the variables list in the panel
     */
    function renderVariables() {
      const container = document.getElementById('variables-list');
      if (!container) return;

      // Loading state
      if (variablesState.loading) {
        container.innerHTML = `
          <div class="var-item">
            <div class="var-item-color" style="background: var(--text-dim);"></div>
            <span class="var-item-name">Loading...</span>
          </div>
        `;
        return;
      }

      // No runtime connected
      if (!state.pythonPort) {
        container.innerHTML = `
          <div class="var-item">
            <div class="var-item-color" style="background: var(--text-dim);"></div>
            <span class="var-item-name">No session</span>
            <span class="var-item-type">Start a runtime to see variables</span>
          </div>
        `;
        return;
      }

      // Error state
      if (variablesState.error) {
        container.innerHTML = `
          <div class="var-item">
            <div class="var-item-color" style="background: var(--error);"></div>
            <span class="var-item-name">Error</span>
            <span class="var-item-type">${escapeHtml(variablesState.error)}</span>
          </div>
        `;
        return;
      }

      // No variables
      if (variablesState.variables.length === 0) {
        container.innerHTML = `
          <div class="var-item">
            <div class="var-item-color" style="background: var(--text-dim);"></div>
            <span class="var-item-name">No variables</span>
            <span class="var-item-type">Run some code to create variables</span>
          </div>
        `;
        return;
      }

      // Render variables
      const colors = ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#06b6d4'];
      container.innerHTML = variablesState.variables.map((v, i) => {
        const color = colors[i % colors.length];
        const typeInfo = v.shape ? `${v.type}(${v.shape.join(', ')})` : v.type;
        return `
          <div class="var-item" title="${escapeHtml(v.value || '')}">
            <div class="var-item-color" style="background: ${color};"></div>
            <span class="var-item-name">${escapeHtml(v.name)}</span>
            <span class="var-item-type">${escapeHtml(typeInfo)}</span>
          </div>
        `;
      }).join('');
    }

    /**
     * Initialize variables panel - auto-refresh when panel opens
     */
    function initVariablesPanel() {
      // Refresh when panel opens
      const originalOpenPanel = openPanel;
      openPanel = function(panelId) {
        originalOpenPanel(panelId);
        if (panelId === 'variables') {
          fetchVariables();
        }
      };

      // Add refresh button handler
      const refreshBtn = document.getElementById('variables-refresh');
      refreshBtn?.addEventListener('click', fetchVariables);
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      initVariablesPanel();
    });

    // Auto-refresh variables after code execution
    // Hook into editor's execution events if available
    function setupVariablesAutoRefresh() {
      if (state.editor?.on) {
        state.editor.on('executionComplete', () => {
          // Only refresh if panel is open
          if (railState.activePanel === 'variables') {
            setTimeout(fetchVariables, 500); // Small delay for Python to update
          }
        });
      }
    }

    // =========================================================================
    // ARTIFACT PANEL
    // =========================================================================

    const artifactState = {
      html: '',
      css: '',
      scripts: [],  // JS code accumulated from cells
      initialized: false,
    };

    /**
     * Initialize the artifact iframe with a basic HTML structure
     */
    function initArtifactIframe() {
      const iframe = document.getElementById('artifact-iframe');
      if (!iframe) return;

      // Create a basic HTML document
      const doc = iframe.contentDocument || iframe.contentWindow.document;
      doc.open();
      doc.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style id="artifact-styles">
            /* Base styles */
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
              margin: 0;
              padding: 16px;
              line-height: 1.5;
            }
            * { box-sizing: border-box; }
          </style>
        </head>
        <body id="artifact-body">
          <div id="artifact-content"></div>
        </body>
        </html>
      `);
      doc.close();

      artifactState.initialized = true;
      updateArtifactStatus('Ready');
    }

    /**
     * Update the artifact with new HTML content
     */
    function updateArtifactHtml(html) {
      const iframe = document.getElementById('artifact-iframe');
      if (!iframe || !artifactState.initialized) {
        initArtifactIframe();
      }

      const doc = iframe.contentDocument || iframe.contentWindow.document;
      const container = doc.getElementById('artifact-content');
      if (container) {
        // Append HTML (don't replace, so multiple HTML cells accumulate)
        container.innerHTML += html;
        artifactState.html += html;
        updateArtifactStatus('HTML updated');
      }
    }

    /**
     * Update the artifact with new CSS
     */
    function updateArtifactCss(css) {
      const iframe = document.getElementById('artifact-iframe');
      if (!iframe || !artifactState.initialized) {
        initArtifactIframe();
      }

      const doc = iframe.contentDocument || iframe.contentWindow.document;
      const styleEl = doc.getElementById('artifact-styles');
      if (styleEl) {
        // Append CSS
        styleEl.textContent += '\n' + css;
        artifactState.css += '\n' + css;
        updateArtifactStatus('CSS updated');
      }
    }

    /**
     * Execute JS in the artifact context
     */
    function executeArtifactJs(code) {
      const iframe = document.getElementById('artifact-iframe');
      if (!iframe || !artifactState.initialized) {
        initArtifactIframe();
      }

      try {
        const win = iframe.contentWindow;
        // Execute in the iframe's context
        win.eval(code);
        artifactState.scripts.push(code);
        updateArtifactStatus('JS executed');
      } catch (err) {
        console.error('[artifact] JS error:', err);
        updateArtifactStatus('JS error: ' + err.message);
      }
    }

    /**
     * Update status bar
     */
    function updateArtifactStatus(text) {
      const statusEl = document.getElementById('artifact-status');
      if (statusEl) {
        const hasContent = artifactState.html || artifactState.css || artifactState.scripts.length > 0;
        statusEl.innerHTML = `
          <span class="artifact-status-indicator ${hasContent ? 'active' : ''}"></span>
          <span class="artifact-status-text">${text}</span>
        `;
      }
    }

    /**
     * Clear the artifact
     */
    function clearArtifact() {
      artifactState.html = '';
      artifactState.css = '';
      artifactState.scripts = [];
      artifactState.initialized = false;
      initArtifactIframe();
      updateArtifactStatus('Cleared');
    }

    /**
     * Reload the artifact (re-apply all accumulated content)
     */
    function reloadArtifact() {
      const savedHtml = artifactState.html;
      const savedCss = artifactState.css;
      const savedScripts = [...artifactState.scripts];

      // Reset and rebuild
      artifactState.html = '';
      artifactState.css = '';
      artifactState.scripts = [];
      artifactState.initialized = false;
      initArtifactIframe();

      // Re-apply CSS
      if (savedCss) {
        updateArtifactCss(savedCss);
      }

      // Re-apply HTML
      if (savedHtml) {
        const iframe = document.getElementById('artifact-iframe');
        const doc = iframe?.contentDocument || iframe?.contentWindow?.document;
        const container = doc?.getElementById('artifact-content');
        if (container) {
          container.innerHTML = savedHtml;
          artifactState.html = savedHtml;
        }
      }

      // Re-execute scripts
      savedScripts.forEach(code => {
        executeArtifactJs(code);
      });

      updateArtifactStatus('Reloaded');
    }

    /**
     * Initialize artifact panel
     */
    function initArtifactPanel() {
      // Initialize iframe when panel first opens
      const originalOpenPanel = openPanel;
      const wrappedOpenPanel = function(panelId) {
        originalOpenPanel(panelId);
        if (panelId === 'artifact' && !artifactState.initialized) {
          initArtifactIframe();
        }
      };
      // Only wrap if not already wrapped
      if (!openPanel._artifactWrapped) {
        openPanel = wrappedOpenPanel;
        openPanel._artifactWrapped = true;
      }

      // Button handlers
      document.getElementById('artifact-clear')?.addEventListener('click', clearArtifact);
      document.getElementById('artifact-reload')?.addEventListener('click', reloadArtifact);

      // Expose artifact API to window for JS cells to use
      window.artifact = {
        html: updateArtifactHtml,
        css: updateArtifactCss,
        js: executeArtifactJs,
        clear: clearArtifact,
        reload: reloadArtifact,
        // Get the artifact iframe's document
        get document() {
          const iframe = document.getElementById('artifact-iframe');
          return iframe?.contentDocument || iframe?.contentWindow?.document;
        },
        // Get the artifact iframe's window
        get window() {
          const iframe = document.getElementById('artifact-iframe');
          return iframe?.contentWindow;
        },
        // Show the artifact panel
        show() {
          openPanel('artifact');
          if (!artifactState.initialized) {
            initArtifactIframe();
          }
        }
      };
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      initArtifactPanel();
    });

    /**
     * Hook into cell execution to update artifact
     */
    function setupArtifactExecutionHook() {
      if (!state.editor?.execution?.on) {
        console.log('[artifact] Waiting for editor...');
        setTimeout(setupArtifactExecutionHook, 500);
        return;
      }

      // Listen for cell completion
      state.editor.execution.on('cellComplete', (cellIndex, result, execId) => {
        // Get the cell to determine language
        const cells = state.editor.getCells?.() || [];
        const cell = cells[cellIndex];
        if (!cell) return;

        const lang = cell.language?.toLowerCase();
        console.log('[artifact] Cell complete:', lang, execId);

        // Only update artifact panel if it's open or has content
        if (railState.activePanel !== 'artifact' && !artifactState.initialized) {
          return;
        }

        if (lang === 'html' || lang === 'htm') {
          // For HTML cells, use the cell code itself
          updateArtifactHtml(cell.code);
        } else if (lang === 'css' || lang === 'style') {
          // For CSS cells, apply the styles
          updateArtifactCss(cell.code);
        } else if (lang === 'javascript' || lang === 'js') {
          // For JS cells, optionally execute in artifact context
          // Only if the cell has a special marker like "artifact" in metadata
          // For now, we don't auto-execute JS in artifact
        }
      });

      console.log('[artifact] Execution hook registered');
    }

    // =========================================================================
    // SOURCE PANEL
    // =========================================================================

    const sourceState = {
      history: [],      // Stack of {name, result} for back navigation
      currentIndex: -1, // Current position in history
    };

    /**
     * Show source code in the panel
     */
    function showSource(result) {
      if (!result || !result.found) {
        console.log('[source] No result to show');
        return;
      }

      // Add to history
      if (sourceState.currentIndex < sourceState.history.length - 1) {
        // If we navigated back and then view new source, truncate forward history
        sourceState.history = sourceState.history.slice(0, sourceState.currentIndex + 1);
      }
      sourceState.history.push({ name: result.name, result });
      sourceState.currentIndex = sourceState.history.length - 1;

      renderSource(result);
      openPanel('source');
    }

    /**
     * Navigate back in source history
     */
    function sourceBack() {
      if (sourceState.currentIndex > 0) {
        sourceState.currentIndex--;
        const entry = sourceState.history[sourceState.currentIndex];
        renderSource(entry.result);
      }
    }

    /**
     * Render source code with syntax highlighting and clickable types
     */
    function renderSource(result) {
      const titleEl = document.getElementById('source-title');
      const fileEl = document.getElementById('source-file');
      const codeEl = document.getElementById('source-code');
      const backBtn = document.getElementById('source-back');

      if (!titleEl || !fileEl || !codeEl) return;

      // Update title and file path
      titleEl.textContent = result.name || 'Source';
      fileEl.textContent = result.file || '';
      fileEl.title = result.file || '';

      // Update back button state
      if (backBtn) {
        backBtn.disabled = sourceState.currentIndex <= 0;
      }

      // Get source code or show message
      const sourceCode = result.sourceCode;
      if (!sourceCode) {
        codeEl.innerHTML = `<code>No source code available for ${result.name}.\n\nType: ${result.type || 'unknown'}\n${result.docstring ? '\nDocstring:\n' + result.docstring : ''}</code>`;
        return;
      }

      // Apply syntax highlighting and make types clickable
      const highlighted = highlightPythonSource(sourceCode);
      codeEl.innerHTML = `<code>${highlighted}</code>`;

      // Add click handlers for type references
      codeEl.querySelectorAll('.source-type-ref').forEach(el => {
        el.addEventListener('click', async () => {
          const typeName = el.dataset.type;
          if (typeName) {
            await drillIntoType(typeName);
          }
        });
      });
    }

    /**
     * Basic Python syntax highlighting with clickable type references
     */
    function highlightPythonSource(code) {
      // Escape HTML first
      let html = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      // Extract strings first to protect them (replace with placeholders)
      const strings = [];
      html = html.replace(/("""[\s\S]*?"""|'''[\s\S]*?'''|"[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')/g, (match) => {
        strings.push(match);
        return `__STR${strings.length - 1}__`;
      });

      // Extract comments to protect them
      const comments = [];
      html = html.replace(/(#.*$)/gm, (match) => {
        comments.push(match);
        return `__CMT${comments.length - 1}__`;
      });

      // Keywords
      const keywords = ['class', 'def', 'return', 'if', 'else', 'elif', 'for', 'while', 'try', 'except', 'finally', 'with', 'as', 'import', 'from', 'raise', 'pass', 'break', 'continue', 'yield', 'async', 'await', 'lambda', 'and', 'or', 'not', 'in', 'is', 'None', 'True', 'False', 'self', 'cls'];
      const kwPattern = new RegExp(`\\b(${keywords.join('|')})\\b`, 'g');
      html = html.replace(kwPattern, '<span class=kw>$1</span>');

      // Decorators
      html = html.replace(/(@\w+)/g, '<span class=dec>$1</span>');

      // Numbers
      html = html.replace(/\b(\d+\.?\d*)\b/g, '<span class=num>$1</span>');

      // Function definitions
      html = html.replace(/(<span class=kw>def<\/span>\s+)(\w+)/g, '$1<span class=fn>$2</span>');

      // Class definitions with clickable base classes
      html = html.replace(/(<span class=kw>class<\/span>\s+)(\w+)(\s*\()([^)]+)(\))/g, (match, prefix, className, paren1, bases, paren2) => {
        // Make base classes clickable
        const clickableBases = bases.split(',').map(base => {
          const trimmed = base.trim();
          if (trimmed && !trimmed.startsWith('<span')) {
            return `<span class=source-type-ref data-type="${trimmed}">${trimmed}</span>`;
          }
          return base;
        }).join(',');
        return `${prefix}<span class=cls>${className}</span>${paren1}${clickableBases}${paren2}`;
      });

      // Type annotations (: TypeName) - make clickable
      html = html.replace(/:\s*([A-Z][A-Za-z0-9_]*(?:\[[^\]]+\])?)/g, (match, typeName) => {
        // Extract base type (before any brackets)
        const baseType = typeName.split('[')[0];
        return `: <span class="source-type-ref type" data-type="${baseType}">${typeName}</span>`;
      });

      // Return type annotations (-> TypeName)
      html = html.replace(/-&gt;\s*([A-Z][A-Za-z0-9_]*(?:\[[^\]]+\])?)/g, (match, typeName) => {
        const baseType = typeName.split('[')[0];
        return `-&gt; <span class="source-type-ref type" data-type="${baseType}">${typeName}</span>`;
      });

      // Restore comments with highlighting
      comments.forEach((cmt, i) => {
        html = html.replace(`__CMT${i}__`, `<span class=cm>${cmt}</span>`);
      });

      // Restore strings with highlighting
      strings.forEach((str, i) => {
        html = html.replace(`__STR${i}__`, `<span class=str>${str}</span>`);
      });

      return html;
    }

    /**
     * Drill into a type to view its source
     */
    async function drillIntoType(typeName) {
      console.log('[source] Drilling into:', typeName);

      if (!state.editor) {
        console.error('[source] No editor available');
        return;
      }

      try {
        const result = await state.editor.viewSourceByName(typeName, 'python');
        if (result && result.found) {
          // showSource is called via the onViewSource callback
        } else {
          console.log('[source] Type not found:', typeName);
          alert(`Could not find source for: ${typeName}`);
        }
      } catch (e) {
        console.error('[source] Error drilling into type:', e);
      }
    }

    /**
     * Initialize source panel
     */
    function initSourcePanel() {
      const backBtn = document.getElementById('source-back');
      if (backBtn) {
        backBtn.addEventListener('click', sourceBack);
      }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      initSourcePanel();
    });

    // =========================================================================
    // RUNTIMES PANEL
    // =========================================================================

    /**
     * Render the runtimes list in the panel
     */
    function renderRuntimesPanel() {
      const listEl = document.getElementById('runtimes-list');
      if (!listEl) return;

      const runtimes = state.runningRuntimes || [];
      const attachedPythonId = state.pythonVenv?.runtimeId || state.pythonVenv?.name;
      const attachedBashId = state.bashSession?.name;

      if (runtimes.length === 0) {
        listEl.innerHTML = '<div class="runtimes-empty">No running runtimes</div>';
        return;
      }

      listEl.innerHTML = runtimes.map(rt => {
        const lang = rt.language || 'python';
        const isAttached = lang === 'bash' ? rt.id === attachedBashId : rt.id === attachedPythonId;
        return `
          <div class="runtime-item ${isAttached ? 'attached' : ''}"
               data-runtime-id="${rt.id}"
               data-language="${lang}"
               title="pid ${rt.pid}">
            <div class="runtime-item-status"></div>
            <div class="runtime-item-info">
              <div class="runtime-item-name">
                <span class="runtime-lang-badge ${lang}">${lang}</span>
                ${rt.id}
              </div>
              <div class="runtime-item-meta">port ${rt.port}</div>
            </div>
            <div class="runtime-item-actions">
              ${isAttached ? '' : `<button class="runtime-item-btn" onclick="event.stopPropagation(); attachToRuntime('${rt.id}', '${lang}')">attach</button>`}
              <button class="runtime-item-btn danger" onclick="event.stopPropagation(); killAndRefreshRuntime('${rt.id}', '${lang}')">stop</button>
            </div>
          </div>
        `;
      }).join('');

      // Add click handler to attach on row click
      listEl.querySelectorAll('.runtime-item').forEach(el => {
        el.addEventListener('click', () => {
          const runtimeId = el.dataset.runtimeId;
          const language = el.dataset.language || 'python';
          if (!el.classList.contains('attached')) {
            attachToRuntime(runtimeId, language);
          }
        });
      });
    }

    /**
     * Refresh runtimes list from backend
     */
    async function refreshRuntimes() {
      try {
        // Fetch session service runtimes AND legacy runtimes in parallel
        // Use Promise.allSettled to handle individual failures gracefully
        const [pythonResult, bashResult, legacyResult] = await Promise.allSettled([
          electronAPI.session.list(),
          electronAPI.bash.list(),
          electronAPI.listRuntimes()  // Legacy runtime registry
        ]);

        const pythonSessions = pythonResult.status === 'fulfilled' ? pythonResult.value : [];
        const bashSessions = bashResult.status === 'fulfilled' ? bashResult.value : [];
        const legacyRuntimes = legacyResult.status === 'fulfilled' ? (legacyResult.value?.runtimes || []) : [];

        if (pythonResult.status === 'rejected') {
          console.warn('[runtimes] Failed to fetch Python sessions:', pythonResult.reason);
        }
        if (bashResult.status === 'rejected') {
          console.warn('[runtimes] Failed to fetch Bash sessions:', bashResult.reason);
        }
        if (legacyResult.status === 'rejected') {
          console.warn('[runtimes] Failed to fetch legacy runtimes:', legacyResult.reason);
        }

        console.log('[runtimes] Python sessions:', pythonSessions);
        console.log('[runtimes] Bash sessions:', bashSessions);
        console.log('[runtimes] Legacy runtimes:', legacyRuntimes);

        // Collect all session IDs to avoid duplicates
        const sessionIds = new Set(pythonSessions.map(s => s.name));

        // Combine all sources with language field
        state.runningRuntimes = [
          // Session service Python sessions
          ...pythonSessions.filter(s => s.alive).map(s => ({
            id: s.name,
            pid: s.pid,
            port: s.port,
            venv: s.venv,
            alive: s.alive,
            language: 'python'
          })),
          // Legacy runtimes (avoid duplicates with session service)
          ...legacyRuntimes.filter(r => r.alive && !sessionIds.has(r.id)).map(r => ({
            id: r.id,
            pid: r.pid,
            port: r.port,
            venv: r.venv,
            alive: r.alive,
            language: 'python'
          })),
          // Bash sessions
          ...bashSessions.filter(s => s.alive).map(s => ({
            id: s.name,
            pid: s.pid,
            port: s.port,
            cwd: s.cwd,
            alive: s.alive,
            language: 'bash'
          }))
        ];
        renderRuntimesPanel();
      } catch (e) {
        console.error('Failed to refresh runtimes:', e);
      }
    }

    /**
     * Kill a runtime and refresh the list
     */
    async function killAndRefreshRuntime(runtimeId, language = 'python') {
      await killRuntimeAction(runtimeId, language);
      renderRuntimesPanel();
    }

    /**
     * Initialize runtimes panel
     */
    function initRuntimesPanel() {
      // Refresh when panel opens
      const originalOpenPanel = openPanel;
      openPanel = function(panelId) {
        originalOpenPanel(panelId);
        if (panelId === 'runtimes') {
          refreshRuntimes();
        }
      };

      // Add refresh button handler
      const refreshBtn = document.getElementById('runtimes-refresh');
      refreshBtn?.addEventListener('click', refreshRuntimes);
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      initRuntimesPanel();
    });

    // =========================================================================
    // AI COMMANDS PANEL
    // =========================================================================

    /**
     * Global AI client - set when AI server is connected
     * @type {import('mrmd-editor').AiClient|null}
     */
    let aiClient = null;

    /**
     * AI command definitions
     */
    const AI_COMMANDS = {
      'fix-grammar': {
        program: 'FixGrammarPredict',
        resultField: 'fixed_text',
        type: 'replace',
        requiresSelection: true,
        buildParams: (ctx) => ({
          text_to_fix: ctx.selectedText,
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'fix-transcription': {
        program: 'FixTranscriptionPredict',
        resultField: 'fixed_text',
        type: 'replace',
        requiresSelection: true,
        buildParams: (ctx) => ({
          text_to_fix: ctx.selectedText,
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'finish-sentence': {
        program: 'FinishSentencePredict',
        resultField: 'completion',
        type: 'insert',
        requiresSelection: false,
        buildParams: (ctx) => ({
          text_before_cursor: ctx.textBeforeCursor,
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'finish-paragraph': {
        program: 'FinishParagraphPredict',
        resultField: 'completion',
        type: 'insert',
        requiresSelection: false,
        buildParams: (ctx) => ({
          text_before_cursor: ctx.textBeforeCursor,
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'document-code': {
        program: 'DocumentCodePredict',
        resultField: 'documented_code',
        type: 'replace',
        requiresSelection: true,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code: ctx.selectedText,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'add-types': {
        program: 'AddTypeHintsPredict',
        resultField: 'typed_code',
        type: 'replace',
        requiresSelection: true,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code: ctx.selectedText,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'improve-names': {
        program: 'ImproveNamesPredict',
        resultField: 'improved_code',
        type: 'replace',
        requiresSelection: true,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code: ctx.selectedText,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'refactor': {
        program: 'RefactorCodePredict',
        resultField: 'refactored_code',
        type: 'replace',
        requiresSelection: true,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code: ctx.selectedText,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'finish-code-line': {
        program: 'FinishCodeLinePredict',
        resultField: 'completion',
        type: 'insert',
        requiresSelection: false,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code_before_cursor: ctx.textBeforeCursor,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'finish-code-section': {
        program: 'FinishCodeSectionPredict',
        resultField: 'completion',
        type: 'insert',
        requiresSelection: false,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code_before_cursor: ctx.textBeforeCursor,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'document-continue': {
        program: 'DocumentResponsePredict',
        resultField: 'response',
        type: 'insert',
        requiresSelection: false,
        buildParams: (ctx) => ({
          document: ctx.documentContext,
        }),
        // Special: insert at end of document
        insertAtEnd: true,
      },
      // Comment commands
      'address-comment': {
        program: 'AddressNearbyCommentPredict',
        resultField: 'edits',
        type: 'edits',  // Special type for edit operations
        requiresSelection: false,
        buildParams: (ctx) => {
          const commentSyntax = mrmd.default?.commentSyntax || mrmd.commentSyntax;
          const nearbyComment = commentSyntax?.findNearestComment?.(ctx.documentContext, ctx.cursorPos);
          if (!nearbyComment) return null;
          return {
            full_document: ctx.documentContext,
            cursor_context_before: ctx.textBeforeCursor,
            cursor_context_after: ctx.textAfterCursor,
            nearby_comment: {
              text: nearbyComment.content,
              context_before: ctx.documentContext.slice(Math.max(0, nearbyComment.start - 200), nearbyComment.start),
              context_after: ctx.documentContext.slice(nearbyComment.end, Math.min(ctx.documentContext.length, nearbyComment.end + 200)),
            },
            nearby_comment_raw: nearbyComment.raw,
          };
        },
      },
      'address-all-comments': {
        program: 'AddressAllCommentsPredict',
        resultField: 'edits',
        type: 'edits',
        requiresSelection: false,
        buildParams: (ctx) => {
          const commentSyntax = mrmd.default?.commentSyntax || mrmd.commentSyntax;
          const comments = commentSyntax?.extractComments?.(ctx.documentContext) || [];
          if (comments.length === 0) return null;
          return {
            full_document: ctx.documentContext,
            comments: comments.map(c => ({
              text: c.content,
              context_before: ctx.documentContext.slice(Math.max(0, c.start - 200), c.start),
              context_after: ctx.documentContext.slice(c.end, Math.min(ctx.documentContext.length, c.end + 200)),
            })),
          };
        },
      },
    };

    /**
     * Connect to AI server
     * @param {string} serverUrl - AI server base URL (e.g., http://127.0.0.1:34251)
     */
    function connectAiServer(serverUrl) {
      // Create a simple client that calls mrmd-ai server directly
      // mrmd-ai endpoints are at /{program} not /api/ai/{program}
      aiClient = {
        baseUrl: serverUrl.replace(/\/$/, ''),
        juiceLevel: currentJuiceLevel, // Use current panel state
        reasoningLevel: currentReasoningLevel, // Use current panel state

        async execute(program, params, options = {}) {
          const juiceLevel = options.juiceLevel ?? this.juiceLevel;
          const reasoningLevel = options.reasoningLevel ?? this.reasoningLevel;
          const response = await fetch(`${this.baseUrl}/${program}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Juice-Level': String(juiceLevel),
              'X-Reasoning-Level': String(reasoningLevel),
            },
            body: JSON.stringify(params),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ detail: response.statusText }));
            throw new Error(error.detail || `AI request failed: ${response.status}`);
          }

          return response.json();
        },

        /**
         * Execute with streaming progress updates
         */
        async executeStream(program, params, callbacks = {}, options = {}) {
          const juiceLevel = options.juiceLevel ?? this.juiceLevel;
          const reasoningLevel = options.reasoningLevel ?? this.reasoningLevel;
          const response = await fetch(`${this.baseUrl}/${program}/stream`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-Juice-Level': String(juiceLevel),
              'X-Reasoning-Level': String(reasoningLevel),
              'Accept': 'text/event-stream',
            },
            body: JSON.stringify(params),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ detail: response.statusText }));
            throw new Error(error.detail || `AI stream request failed: ${response.status}`);
          }

          // Parse SSE stream
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          let result = null;
          let currentEventType = null;

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop() || '';

            for (const line of lines) {
              // Track event type
              if (line.startsWith('event: ')) {
                currentEventType = line.slice(7).trim();
                continue;
              }

              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.slice(6));

                  // Route based on event type
                  if (currentEventType === 'model_start') {
                    callbacks.onModelStart?.(data.model, data);
                  } else if (currentEventType === 'model_complete') {
                    callbacks.onModelComplete?.(data.model, data);
                  } else if (currentEventType === 'status') {
                    callbacks.onStatus?.(data.step, data);
                  } else if (currentEventType === 'result') {
                    result = data;
                    callbacks.onResult?.(data);
                  } else if (currentEventType === 'error') {
                    callbacks.onError?.(new Error(data.message || data.error));
                  } else {
                    // Fallback: check data properties
                    if (data.step) {
                      callbacks.onStatus?.(data.step, data);
                    }
                    if (data.completion || data.fixed_text || data.response) {
                      result = data;
                      callbacks.onResult?.(data);
                    }
                  }

                  currentEventType = null; // Reset after processing
                } catch (e) {
                  // Skip invalid JSON
                }
              }
            }
          }

          return result;
        },

        cancel(requestId) {
          // Not implemented for simple client
        },

        cancelAll() {
          // Not implemented for simple client
        },
      };

      updateAiPanelStatus();
      console.log('[AI] Connected to AI server at', serverUrl);

      // Add Ctrl-K and comment syntax extensions now that aiClient is available
      addCtrlKAndCommentExtensions();
    }

    /**
     * Add Ctrl-K modal and comment syntax extensions to the editor
     * Called after aiClient is initialized
     */
    function addCtrlKAndCommentExtensions() {
      if (!state?.editor?.view || !aiClient) return;

      const editor = state.editor;

      // Create Ctrl-K modal extension (Mod-K to open AI command input at cursor)
      const ctrlK = mrmd.default?.ctrlK || mrmd.ctrlK;
      const ctrlKExtensions = ctrlK?.createCtrlKExtension?.({
        aiClient,
        juiceLevel: currentJuiceLevel,
        onError: (err) => {
          console.error('[Ctrl-K] Error:', err);
          showAiProgress('Error', err.message);
        },
      }) || [];

      // Create comment syntax extension (<!--! !--> markers)
      const commentSyntax = mrmd.default?.commentSyntax || mrmd.commentSyntax;
      const commentExtensions = commentSyntax?.createCommentSyntaxExtension?.({
        aiClient,
        juiceLevel: currentJuiceLevel,
      }) || [];

      if (ctrlKExtensions.length > 0 || commentExtensions.length > 0) {
        editor.view.dispatch({
          effects: mrmd.codemirror.StateEffect.appendConfig.of([
            ...ctrlKExtensions,
            ...commentExtensions,
          ].filter(Boolean)),
        });
        console.log('[AI] Ctrl-K and comment syntax extensions added');
      }
    }

    /**
     * Disconnect from AI server
     */
    function disconnectAiServer() {
      if (aiClient) {
        aiClient.cancelAll?.();
        aiClient = null;
        updateAiPanelStatus();
        console.log('[AI] Disconnected from AI server');
      }
    }

    /**
     * Update AI panel status display
     */
    function updateAiPanelStatus() {
      const statusEl = document.getElementById('ai-panel-status');
      if (!statusEl) return;

      if (aiClient) {
        statusEl.style.display = 'none';
      } else {
        statusEl.style.display = 'flex';
      }
    }

    /**
     * Show AI progress panel
     */
    function showAiProgress(title, model) {
      const progressEl = document.getElementById('ai-progress');
      const modelEl = document.getElementById('ai-progress-model');
      const modelsEl = document.getElementById('ai-progress-models');

      if (progressEl) {
        progressEl.style.display = 'block';
        progressEl.querySelector('.ai-progress-title').textContent = title || 'Working...';
      }
      if (modelEl) {
        modelEl.textContent = model || '';
      }
      if (modelsEl) {
        modelsEl.innerHTML = '';
      }
    }

    /**
     * Hide AI progress panel
     */
    function hideAiProgress() {
      const progressEl = document.getElementById('ai-progress');
      if (progressEl) {
        progressEl.style.display = 'none';
      }
    }

    /**
     * Update model progress chips
     */
    function updateModelProgress(modelName, status) {
      const modelsEl = document.getElementById('ai-progress-models');
      if (!modelsEl) return;

      // Shorten model name for display
      const shortName = modelName.replace(/^(claude-|gpt-|gemini-)/, '').slice(0, 12);

      // Find or create chip for this model
      let chip = modelsEl.querySelector(`[data-model="${modelName}"]`);
      if (!chip) {
        chip = document.createElement('span');
        chip.className = 'ai-progress-chip';
        chip.dataset.model = modelName;
        chip.textContent = shortName;
        modelsEl.appendChild(chip);
      }

      // Update status
      chip.classList.remove('running', 'done', 'pending');
      if (status === 'running') {
        chip.classList.add('running');
      } else if (status === 'done') {
        chip.classList.add('done');
      } else if (status === 'pending') {
        chip.classList.add('pending');
      }
    }

    /**
     * Execute an AI command
     * @param {string} cmdId - Command ID
     */
    async function executeAiCommand(cmdId) {
      const cmd = AI_COMMANDS[cmdId];
      if (!cmd) return;

      if (!aiClient) {
        console.warn('[AI] AI server not connected');
        return;
      }

      if (!state.editor?.view) {
        console.warn('[AI] No editor active');
        return;
      }

      const view = state.editor.view;
      const cmdEl = document.querySelector(`.ai-cmd[data-cmd="${cmdId}"]`);

      // Get AI context using mrmd.default.ai helpers
      const context = mrmd.default.ai.getAiContext(view);

      // Check requirements
      if (cmd.requiresSelection && !context.selectedText) {
        console.warn('[AI] This command requires selected text');
        return;
      }

      // Detect code language if needed
      let language = null;
      if (cmd.codeOnly) {
        language = detectCodeLanguageAtCursor(view);
      }

      const juiceLevel = currentJuiceLevel;
      const reasoningLevel = currentReasoningLevel;

      // Determine insert position
      let from, to;
      if (cmd.insertAtEnd) {
        // Insert at end of document
        const docLength = view.state.doc.length;
        from = docLength;
        to = docLength;
      } else if (cmd.type === 'insert') {
        from = context.cursorPos;
        to = context.cursorPos;
      } else {
        from = context.selectionFrom;
        to = context.selectionTo;
      }

      // Show loading state in panel
      cmdEl?.classList.add('loading');
      showAiProgress('Working...', '');

      // Get AI integration for editor shimmer
      const ai = mrmd.default?.ai || mrmd.ai;
      const opId = ai.generateOperationId();
      const originalText = cmd.type === 'replace' ? view.state.doc.sliceString(from, to) : '';

      // Check if this is Ultimate mode (juice=4) - use multi-response picker
      const isUltimateMode = juiceLevel === 4;

      // For Ultimate mode, start with multi-response picker immediately
      if (isUltimateMode) {
        view.dispatch({
          effects: ai.startAiOperationMulti.of({
            id: opId,
            type: cmd.type,
            from,
            to,
            originalText,
          }),
        });
      } else {
        // Regular mode - show loading shimmer
        view.dispatch({
          effects: ai.startAiOperation.of({
            id: opId,
            type: cmd.type,
            from,
            to,
            originalText,
          }),
        });
      }

      const params = cmd.buildParams(context, language);

      // Check if params is null (e.g., no comments to address)
      if (params === null) {
        console.log('[AI] Command has nothing to process');
        cmdEl?.classList.remove('loading');
        view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
        hideAiProgress();
        return;
      }

      try {
        // Track individual model responses as they complete
        const modelResponses = new Map(); // model -> response text

        // Use streaming for progress updates
        const result = await aiClient.executeStream(cmd.program, params, {
          onStatus: (step, data) => {
            console.log('[AI] Status:', step, data);
            if (step === 'starting_multi_model') {
              // Ultimate mode - add placeholder responses for each model
              showAiProgress('Multi-model synthesis...', `${data.total} models`);
              data.models?.forEach(m => {
                updateModelProgress(m, 'pending');
                // Add loading placeholder to picker
                view.dispatch({
                  effects: ai.addAiResponse.of({
                    id: opId,
                    model: m,
                    response: null,
                    status: 'loading',
                    isSynthesized: false,
                  }),
                });
              });
            } else if (step === 'calling_model') {
              showAiProgress('Working...', data.model || '');
            } else if (step === 'starting') {
              const title = data.juice_name || 'Working...';
              showAiProgress(title, data.model || '');
            } else if (step === 'synthesizing') {
              showAiProgress('Synthesizing...', 'Combining responses');
            }
          },
          onModelStart: (modelName, data) => {
            console.log('[AI] Model started:', modelName);
            updateModelProgress(modelName, 'running');
            // Update status in picker
            if (isUltimateMode) {
              view.dispatch({
                effects: ai.updateAiResponse.of({
                  id: opId,
                  model: modelName,
                  status: 'loading',
                }),
              });
            }
          },
          onModelComplete: (modelName, data) => {
            console.log('[AI] Model complete:', modelName, data);
            updateModelProgress(modelName, 'done');
            // If data contains response, update the picker
            if (isUltimateMode && data?.response) {
              // Extract the actual text from the response dict using resultField
              const responseDict = data.response;
              const responseText = responseDict[cmd.resultField] ||
                                   responseDict.completion ||
                                   responseDict.fixed_text ||
                                   responseDict.response ||
                                   (typeof responseDict === 'string' ? responseDict : JSON.stringify(responseDict));

              modelResponses.set(modelName, responseText);
              view.dispatch({
                effects: ai.updateAiResponse.of({
                  id: opId,
                  model: modelName,
                  response: responseText,
                  status: 'complete',
                }),
              });
            } else if (isUltimateMode && data?.success === false) {
              // Handle model error
              view.dispatch({
                effects: ai.updateAiResponse.of({
                  id: opId,
                  model: modelName,
                  error: data.error || 'Model failed',
                  status: 'error',
                }),
              });
            }
          },
          onError: (err) => {
            console.error('[AI] Stream error:', err);
          },
        }, { juiceLevel, reasoningLevel });

        hideAiProgress();

        if (!result) {
          console.warn('[AI] No result from AI');
          view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
          return;
        }

        // Handle 'edits' type commands (comment addressing)
        if (cmd.type === 'edits') {
          const edits = result.edits || result[cmd.resultField] || [];
          if (edits && edits.length > 0) {
            // Apply edits using the comment syntax module
            const commentSyntax = mrmd.default?.commentSyntax || mrmd.commentSyntax;
            const doc = view.state.doc.toString();
            const changes = [];

            for (const edit of edits) {
              if (edit.find === '' || edit.find === null) {
                // Insert at cursor
                changes.push({ from: context.cursorPos, insert: edit.replace });
              } else {
                // Find and replace
                const idx = doc.indexOf(edit.find);
                if (idx >= 0) {
                  changes.push({ from: idx, to: idx + edit.find.length, insert: edit.replace });
                } else {
                  console.warn('[AI] Could not find text to replace:', edit.find.slice(0, 50));
                }
              }
            }

            if (changes.length > 0) {
              view.dispatch({ changes });
            }
          }

          // Cancel the loading operation
          view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
          hideAiProgress();
          return;
        }

        // Extract the result text
        const newText = result[cmd.resultField] || result.completion || result.fixed_text || result.response || '';

        // Check if we have multiple individual responses to show
        const individualResponses = result._individual_responses;
        const hasMultipleResponses = individualResponses && individualResponses.length > 1;

        if (hasMultipleResponses || isUltimateMode) {
          // Use multi-response picker
          console.log('[AI] Using multi-response picker with', individualResponses?.length || 0, 'responses');

          // If not already in multi mode, switch to it
          if (!isUltimateMode) {
            // Cancel the loading operation and start multi
            view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
            const multiOpId = ai.generateOperationId();
            view.dispatch({
              effects: ai.startAiOperationMulti.of({
                id: multiOpId,
                type: cmd.type,
                from,
                to,
                originalText,
              }),
            });

            // Add all individual responses
            if (individualResponses) {
              individualResponses.forEach((resp, idx) => {
                view.dispatch({
                  effects: ai.addAiResponse.of({
                    id: multiOpId,
                    model: resp.model,
                    response: resp.response,
                    error: resp.error,
                    status: resp.error ? 'error' : 'complete',
                    isSynthesized: false,
                  }),
                });
              });
            }

            // Add synthesized response as last option
            if (newText) {
              view.dispatch({
                effects: ai.addAiResponse.of({
                  id: multiOpId,
                  model: 'Synthesized',
                  response: newText,
                  status: 'complete',
                  isSynthesized: true,
                }),
              });
            }
          } else {
            // Already in multi mode, just add final responses
            if (individualResponses) {
              individualResponses.forEach((resp) => {
                // Update or add responses
                view.dispatch({
                  effects: ai.updateAiResponse.of({
                    id: opId,
                    model: resp.model,
                    response: resp.response,
                    error: resp.error,
                    status: resp.error ? 'error' : 'complete',
                  }),
                });
              });
            }

            // Add synthesized response
            if (newText) {
              view.dispatch({
                effects: ai.addAiResponse.of({
                  id: opId,
                  model: 'Synthesized',
                  response: newText,
                  status: 'complete',
                  isSynthesized: true,
                }),
              });
              // Select the synthesized response by default
              const state = view.state.field(ai.aiState);
              const op = state.operations.get(opId);
              if (op) {
                const synthIndex = (op.responses?.length || 0);
                view.dispatch({
                  effects: ai.setSelectedResponse.of({ id: opId, index: synthIndex }),
                });
              }
            }
          }

          // Don't insert text yet - wait for user to pick
          return;
        }

        // Single response - use original inline approach
        if (!newText) {
          console.warn('[AI] Empty result from AI');
          view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
          return;
        }

        // Insert/replace text using AI integration for accept/reject UI
        if (cmd.type === 'insert') {
          view.dispatch({
            changes: { from, insert: newText },
            effects: ai.completeAiOperation.of({ id: opId, newText }),
          });
        } else {
          view.dispatch({
            changes: { from, to, insert: newText },
            effects: ai.completeAiOperation.of({ id: opId, newText }),
          });
        }
      } catch (err) {
        console.error('[AI] Command failed:', err);
        // Cancel the AI operation on error
        view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
        hideAiProgress();
      } finally {
        cmdEl?.classList.remove('loading');
      }
    }

    /**
     * Detect the programming language at cursor position
     * @param {EditorView} view
     * @returns {string}
     */
    function detectCodeLanguageAtCursor(view) {
      // Look for ```language in nearby text
      const pos = view.state.selection.main.head;
      const text = view.state.doc.toString();
      const before = text.slice(Math.max(0, pos - 500), pos);
      const match = before.match(/```(\w+)[^\`]*$/);
      return match ? match[1] : 'python';
    }

    /**
     * Update command states based on selection
     */
    function updateAiCommandStates() {
      if (!state.editor?.view) return;

      const hasSelection = state.editor.view.state.selection.main.from !==
                           state.editor.view.state.selection.main.to;

      document.querySelectorAll('.ai-cmd').forEach(el => {
        const cmdId = el.dataset.cmd;
        const cmd = AI_COMMANDS[cmdId];
        if (cmd?.requiresSelection && !hasSelection) {
          el.classList.add('disabled');
        } else {
          el.classList.remove('disabled');
        }
      });
    }

    /**
     * Current juice level (0-4)
     */
    let currentJuiceLevel = 1;

    /**
     * Current reasoning level (0-5)
     */
    let currentReasoningLevel = 1;

    /**
     * Map of juice levels to whether they support reasoning
     * Level 0 (Groq/Kimi K2) does NOT support reasoning
     */
    const JUICE_SUPPORTS_REASONING = {
      0: false,  // Groq/Kimi K2 - no reasoning support
      1: true,   // Claude Sonnet 4.5
      2: true,   // Gemini 3 Pro
      3: true,   // Claude Opus 4.5
      4: true,   // Multi-model (all support reasoning)
    };

    /**
     * Set the juice level and update UI
     */
    function setJuiceLevel(level) {
      currentJuiceLevel = Math.max(0, Math.min(4, level));
      if (aiClient) {
        aiClient.juiceLevel = currentJuiceLevel;
      }
      // Update UI
      document.querySelectorAll('.ai-juice-btn').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.dataset.juice) === currentJuiceLevel);
      });

      // Enable/disable reasoning buttons based on model support
      const supportsReasoning = JUICE_SUPPORTS_REASONING[currentJuiceLevel] ?? true;
      document.querySelectorAll('.ai-reasoning-btn').forEach(btn => {
        btn.disabled = !supportsReasoning;
        btn.classList.toggle('disabled', !supportsReasoning);
      });

      // If reasoning not supported and currently set to non-zero, reset to 0
      if (!supportsReasoning && currentReasoningLevel > 0) {
        setReasoningLevel(0);
      }
    }

    /**
     * Set the reasoning level and update UI
     */
    function setReasoningLevel(level) {
      currentReasoningLevel = Math.max(0, Math.min(5, level));
      if (aiClient) {
        aiClient.reasoningLevel = currentReasoningLevel;
      }
      // Update UI
      document.querySelectorAll('.ai-reasoning-btn').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.dataset.reasoning) === currentReasoningLevel);
      });
    }

    // =========================================================================
    // AI Panel Keyboard Mode
    // =========================================================================

    /**
     * State for AI panel keyboard mode
     */
    let aiPanelKeyboardMode = false;
    let aiPanelKeyHandler = null;

    /**
     * Map of keyboard shortcuts to command IDs
     * Built dynamically from data-key attributes
     */
    function buildAiKeyMap() {
      const keyMap = {};
      document.querySelectorAll('.ai-cmd[data-key]').forEach(el => {
        const key = el.dataset.key.toLowerCase();
        const cmdId = el.dataset.cmd;
        keyMap[key] = cmdId;
      });
      return keyMap;
    }

    /**
     * Handle keyboard events when AI panel is in keyboard mode
     */
    function handleAiPanelKeydown(e) {
      if (!aiPanelKeyboardMode) return;

      const key = e.key.toLowerCase();
      const code = e.code; // e.g., 'Digit1', 'KeyG', etc.
      const keyMap = buildAiKeyMap();

      // Escape to close panel and disable keyboard mode
      if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        disableAiPanelKeyboardMode();
        closePanel('ai');
        // Return focus to editor
        state.editor?.view?.focus();
        return;
      }

      // Shift+1-5 for juice/quality level (use e.code since e.key gives '!@#$%')
      if (e.shiftKey && code >= 'Digit1' && code <= 'Digit5') {
        e.preventDefault();
        e.stopPropagation();
        const digit = parseInt(code.charAt(5), 10); // Extract digit from 'Digit1'
        setJuiceLevel(digit - 1); // 1-5 maps to 0-4
        return;
      }

      // 0-5 for reasoning level (without shift)
      if (!e.shiftKey && code >= 'Digit0' && code <= 'Digit5') {
        e.preventDefault();
        e.stopPropagation();
        const digit = parseInt(code.charAt(5), 10);
        setReasoningLevel(digit);
        return;
      }

      // Command keys
      if (keyMap[key]) {
        e.preventDefault();
        e.stopPropagation();
        const cmdId = keyMap[key];
        const cmdEl = document.querySelector(`.ai-cmd[data-cmd="${cmdId}"]`);
        if (cmdEl && !cmdEl.classList.contains('disabled') && !cmdEl.classList.contains('loading')) {
          disableAiPanelKeyboardMode();
          executeAiCommand(cmdId);
        }
        return;
      }
    }

    /**
     * Enable keyboard mode for the AI panel
     * Called when panel is opened via long-press 'j'
     */
    function enableAiPanelKeyboardMode() {
      if (aiPanelKeyboardMode) return;

      aiPanelKeyboardMode = true;

      // Add visual indicator
      const panel = document.getElementById('panel-ai');
      panel?.classList.add('keyboard-mode');

      // Show hint
      const hint = document.getElementById('ai-keyboard-hint');
      if (hint) hint.style.display = 'inline';

      // Add capture-phase handler to intercept all keys
      aiPanelKeyHandler = (e) => handleAiPanelKeydown(e);
      document.addEventListener('keydown', aiPanelKeyHandler, { capture: true });

      console.log('[AI] Keyboard mode enabled');
    }

    /**
     * Disable keyboard mode for the AI panel
     */
    function disableAiPanelKeyboardMode() {
      if (!aiPanelKeyboardMode) return;

      aiPanelKeyboardMode = false;

      // Remove visual indicator
      const panel = document.getElementById('panel-ai');
      panel?.classList.remove('keyboard-mode');

      // Hide hint
      const hint = document.getElementById('ai-keyboard-hint');
      if (hint) hint.style.display = 'none';

      // Remove handler
      if (aiPanelKeyHandler) {
        document.removeEventListener('keydown', aiPanelKeyHandler, { capture: true });
        aiPanelKeyHandler = null;
      }

      console.log('[AI] Keyboard mode disabled');
    }

    /**
     * Initialize the AI Commands panel
     */
    function initAiPanel() {
      // Attach click handlers to AI commands
      document.querySelectorAll('.ai-cmd').forEach(el => {
        el.addEventListener('click', () => {
          const cmdId = el.dataset.cmd;
          if (!el.classList.contains('disabled') && !el.classList.contains('loading')) {
            executeAiCommand(cmdId);
          }
        });
      });

      // Attach click handlers to juice level buttons
      document.querySelectorAll('.ai-juice-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          setJuiceLevel(parseInt(btn.dataset.juice));
        });
      });

      // Attach click handlers to reasoning level buttons
      document.querySelectorAll('.ai-reasoning-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          setReasoningLevel(parseInt(btn.dataset.reasoning));
        });
      });

      // Update command states when panel opens
      const originalOpenPanel = openPanel;
      openPanel = function(panelId) {
        originalOpenPanel(panelId);
        if (panelId === 'ai') {
          updateAiPanelStatus();
          updateAiCommandStates();
        }
      };

      // Disable keyboard mode when panel closes
      const originalClosePanel = closePanel;
      closePanel = function(panelId) {
        if (panelId === 'ai' || railState.activePanel === 'ai') {
          disableAiPanelKeyboardMode();
        }
        originalClosePanel(panelId);
      };

      // Update AI panel status initially
      updateAiPanelStatus();

      // Listen for editor selection changes (poll every 200ms when panel is open)
      setInterval(() => {
        if (railState.activePanel === 'ai') {
          updateAiCommandStates();
        }
      }, 200);
    }

    // Initialize AI panel on load
    document.addEventListener('DOMContentLoaded', () => {
      initAiPanel();
    });

    // =========================================================================
    // TABLE OF CONTENTS
    // =========================================================================

    /**
     * Extract headings from markdown content
     * @param {string} content - The markdown content
     * @returns {Array<{level: number, text: string, line: number, pos: number}>}
     */
    function extractHeadings(content) {
      const headings = [];
      const lines = content.split('\n');
      let pos = 0;
      let inCodeBlock = false;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Check for code block delimiters (``` or ~~~)
        if (line.match(/^(`{3,}|~{3,})/)) {
          inCodeBlock = !inCodeBlock;
          pos += line.length + 1;
          continue;
        }

        // Skip heading detection inside code blocks
        if (inCodeBlock) {
          pos += line.length + 1;
          continue;
        }

        // Match markdown headings (# to ######)
        const match = line.match(/^(#{1,6})\s+(.+)$/);
        if (match) {
          const level = match[1].length;
          // Clean up the heading text (remove trailing #, inline code, etc.)
          let text = match[2].trim().replace(/\s*#+\s*$/, '');
          headings.push({
            level,
            text,
            line: i,
            pos: pos,
          });
        }
        pos += line.length + 1; // +1 for newline
      }

      return headings;
    }

    /**
     * Update the TOC sidebar with headings
     * @param {Array} headings - Array of heading objects
     */
    function updateTOC(headings) {
      const tocList = document.getElementById('toc-list');
      const tocSidebar = document.getElementById('toc-sidebar');

      if (!tocList) return;

      // Filter to show only h1-h3 by default for cleaner display
      const displayHeadings = headings.filter(h => h.level <= 3);

      if (displayHeadings.length === 0) {
        tocList.innerHTML = '<div class="toc-empty">No headings found</div>';
        tocSidebar.classList.remove('visible');
        return;
      }

      // Show the sidebar
      tocSidebar.classList.add('visible');

      // Build the TOC HTML
      tocList.innerHTML = displayHeadings.map((h, idx) => `
        <div class="toc-item" data-level="${h.level}" data-pos="${h.pos}" data-index="${idx}">
          ${escapeHtml(h.text)}
        </div>
      `).join('');

      // Add click handlers
      tocList.querySelectorAll('.toc-item').forEach(item => {
        item.addEventListener('click', () => {
          const pos = parseInt(item.dataset.pos, 10);
          jumpToPosition(pos);

          // Update active state
          tocList.querySelectorAll('.toc-item').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
        });
      });

      // Set first item as active by default
      const firstItem = tocList.querySelector('.toc-item');
      if (firstItem) firstItem.classList.add('active');
    }

    /**
     * Jump to a position in the editor
     * @param {number} pos - Character position
     */
    function jumpToPosition(pos) {
      if (!state.editor?.view) return;

      const view = state.editor.view;

      // Set cursor position
      view.dispatch({
        selection: { anchor: pos, head: pos },
        scrollIntoView: true,
      });

      // Focus the editor
      view.focus();
    }

    /**
     * Escape HTML special characters
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Initialize TOC for the current editor
     */
    function initializeTOC() {
      if (!state.editor) return;

      // Get initial content and update TOC
      const content = state.editor.view?.state.doc.toString() || '';
      const headings = extractHeadings(content);
      updateTOC(headings);

      // Subscribe to content changes (debounced)
      let tocUpdateTimeout = null;
      state.editor.onChange((newContent) => {
        clearTimeout(tocUpdateTimeout);
        tocUpdateTimeout = setTimeout(() => {
          const headings = extractHeadings(newContent);
          updateTOC(headings);
        }, 300); // Debounce 300ms
      });

      // Update active heading based on scroll position
      const contentEl = document.querySelector('.content');
      if (contentEl) {
        contentEl.addEventListener('scroll', () => {
          updateActiveTOCItem();
        }, { passive: true });
      }
    }

    /**
     * Update the active TOC item based on scroll position
     */
    function updateActiveTOCItem() {
      if (!state.editor?.view) return;

      const view = state.editor.view;
      const tocItems = document.querySelectorAll('.toc-item');
      if (tocItems.length === 0) return;

      // Get the visible area's top position in document coordinates
      const visibleTop = view.documentTop;
      const scrollTop = view.scrollDOM.scrollTop;

      // Find which heading is currently visible
      let activeItem = tocItems[0];

      tocItems.forEach(item => {
        const pos = parseInt(item.dataset.pos, 10);
        try {
          const coords = view.coordsAtPos(pos);
          if (coords && coords.top <= 100) { // 100px from top of viewport
            activeItem = item;
          }
        } catch (e) {
          // Position might be invalid, skip
        }
      });

      // Update active class
      tocItems.forEach(item => item.classList.remove('active'));
      activeItem.classList.add('active');

      // Scroll TOC to keep active item visible
      activeItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }

    /**
     * Hide the TOC sidebar
     */
    function hideTOC() {
      const tocSidebar = document.getElementById('toc-sidebar');
      if (tocSidebar) {
        tocSidebar.classList.remove('visible');
      }
    }

    async function discoverProjectVenv(projectDir) {
      // If no python yet, check for obvious venv
      if (!state.pythonPort) {
        const venvPaths = [
          projectDir + '/.venv',
          projectDir + '/venv',
          projectDir + '/env',
        ];

        for (const vp of venvPaths) {
          // We can't check fs directly, but we can try to start and see
          // For now, just trigger discovery
        }

        // Start venv discovery in background
        electronAPI.discoverVenvs(projectDir);
      }
    }

    // =========================================================================
    // STATUS BAR & SESSION MANAGEMENT
    // =========================================================================

    /**
     * Update session status (state only, UI handled by CodeLens)
     * @param {'none'|'starting'|'connected'|'error'} status
     * @param {string} name - Session name (e.g., "thesis:default")
     */
    function updateSessionStatus(status, name) {
      state.session.status = status;
      state.session.name = name;

      // Log status change
      console.log(`[Session] Status: ${status}, Name: ${name || 'none'}`);

      // Rebuild CodeLens to reflect status change
      rebuildEditorCodeLens();
    }

    // Legacy wrapper for old code
    function updatePythonStatus(status, label) {
      const statusMap = { ready: 'connected', loading: 'starting', error: 'error' };
      updateSessionStatus(statusMap[status] || 'none', label);
    }

    function updateAiStatus(status) {
      const dot = document.getElementById('ai-dot');
      if (dot) {
        dot.className = 'status-dot ' + status;
      }
    }

    /**
     * Add AI integration extensions to the editor
     * Shows loading shimmer and accept/reject UI for AI operations
     * Also adds long-press 'j' detection to open AI panel
     * Note: Ctrl-K and comment syntax are added later via addCtrlKAndCommentExtensions()
     * @param {Object} editor - The mrmd editor instance
     */
    function addAiIntegrationToEditor(editor) {
      if (!editor?.view) return;

      // Get the AI integration module
      const ai = mrmd.default?.ai || mrmd.ai;
      if (!ai?.aiIntegration) {
        console.warn('[AI] aiIntegration not available');
        return;
      }

      // Create AI extensions
      const aiExtensions = ai.aiIntegration({
        // Could add onSparkClick here for inline AI menu
      });

      // Create long-press 'j' extension to open AI panel
      const longPressExtensions = ai.createLongPressExtension?.({
        onTrigger: (view) => {
          // Open the side rail first, then the AI panel
          openRail();
          openPanel('ai');
          // Enable keyboard mode for the AI panel
          enableAiPanelKeyboardMode();
        },
      }) || [];

      // Also add palette styles extension (for loading indicator)
      const paletteStyles = ai.aiPaletteStyles || [];

      // Combine all extensions
      const allExtensions = [
        ...aiExtensions,
        ...longPressExtensions,
        paletteStyles,
      ].filter(Boolean);

      // Add extensions to editor
      editor.view.dispatch({
        effects: mrmd.codemirror.StateEffect.appendConfig.of(allExtensions),
      });

      console.log('[AI] AI integration extensions added to editor (including long-press j)');
    }

    /**
     * Setup image paste handler for the editor.
     * Intercepts paste events, saves images to _assets/, and inserts markdown.
     *
     * @param {Object} editor - The mrmd editor instance
     * @param {string} documentPath - Absolute path to the current document
     */
    function setupImagePasteHandler(editor, documentPath) {
      if (!editor?.view) return;

      const editorDom = editor.view.dom;

      editorDom.addEventListener('paste', async (event) => {
        // Check if we have image data in clipboard
        const items = event.clipboardData?.items;
        if (!items) return;

        // Find image item
        let imageItem = null;
        for (const item of items) {
          if (item.type.startsWith('image/')) {
            imageItem = item;
            break;
          }
        }

        if (!imageItem) return;

        // Prevent default paste (we'll handle it)
        event.preventDefault();

        // Get project info
        const projectRoot = state.project?.root;
        if (!projectRoot) {
          console.warn('[ImagePaste] No project root available, cannot save asset');
          return;
        }

        try {
          // Get the image file from clipboard
          const file = imageItem.getAsFile();
          if (!file) {
            console.warn('[ImagePaste] Could not get file from clipboard');
            return;
          }

          // Read file as array buffer
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);

          // Generate filename based on timestamp
          const ext = file.type.split('/')[1] || 'png';
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const filename = `paste-${timestamp}.${ext}`;

          console.log(`[ImagePaste] Saving ${filename} (${uint8Array.length} bytes)`);

          // Save asset via electron API
          const result = await electronAPI.asset.save(projectRoot, uint8Array, filename);
          console.log('[ImagePaste] Asset saved:', result);

          // Get relative path from document to asset
          const relativeDocPath = documentPath.replace(projectRoot + '/', '');
          const relativePath = await electronAPI.asset.relativePath(result.path, relativeDocPath);
          console.log('[ImagePaste] Relative path:', relativePath);

          // Insert markdown at cursor position
          const view = editor.view;
          const pos = view.state.selection.main.head;

          // Create markdown image syntax
          const altText = result.deduplicated ? 'image' : filename.replace(/\.[^.]+$/, '');
          const markdown = `![${altText}](${relativePath})`;

          // Insert the markdown
          view.dispatch({
            changes: { from: pos, insert: markdown },
            selection: { anchor: pos + markdown.length },
          });

          console.log(`[ImagePaste] Inserted: ${markdown}`);

        } catch (err) {
          console.error('[ImagePaste] Error:', err);
        }
      });

      console.log('[ImagePaste] Image paste handler installed');

      // Also handle drag and drop of images
      editorDom.addEventListener('dragover', (event) => {
        // Check if dragging files
        if (event.dataTransfer?.types?.includes('Files')) {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'copy';
        }
      });

      editorDom.addEventListener('drop', async (event) => {
        const files = event.dataTransfer?.files;
        if (!files || files.length === 0) return;

        // Check if any file is an image
        const imageFile = Array.from(files).find(f => f.type.startsWith('image/'));
        if (!imageFile) return;

        event.preventDefault();

        const projectRoot = state.project?.root;
        if (!projectRoot) {
          console.warn('[ImageDrop] No project root available, cannot save asset');
          return;
        }

        try {
          // Read file as array buffer
          const arrayBuffer = await imageFile.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);

          // Use original filename or generate one
          const filename = imageFile.name || `drop-${Date.now()}.png`;

          console.log(`[ImageDrop] Saving ${filename} (${uint8Array.length} bytes)`);

          // Save asset via electron API
          const result = await electronAPI.asset.save(projectRoot, uint8Array, filename);
          console.log('[ImageDrop] Asset saved:', result);

          // Get relative path from document to asset
          const relativeDocPath = documentPath.replace(projectRoot + '/', '');
          const relativePath = await electronAPI.asset.relativePath(result.path, relativeDocPath);
          console.log('[ImageDrop] Relative path:', relativePath);

          // Get drop position - try to get cursor position near drop location
          const view = editor.view;
          const dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });
          const pos = dropPos ?? view.state.selection.main.head;

          // Create markdown image syntax
          const altText = result.deduplicated ? 'image' : filename.replace(/\.[^.]+$/, '');
          const markdown = `![${altText}](${relativePath})`;

          // Insert the markdown
          view.dispatch({
            changes: { from: pos, insert: markdown },
            selection: { anchor: pos + markdown.length },
          });

          console.log(`[ImageDrop] Inserted: ${markdown}`);

        } catch (err) {
          console.error('[ImageDrop] Error:', err);
        }
      });

      console.log('[ImageDrop] Image drop handler installed');
    }

    /**
     * Resolve special links (next, prev, home, up, toc)
     *
     * @param {string} target - Special link target
     * @param {string} documentPath - Absolute path to current document
     * @param {Object} project - Project info with root and files array
     * @returns {string | null} Resolved relative file path or null
     */
    function resolveSpecialLink(target, documentPath, project) {
      const { root, files } = project;
      if (!files || files.length === 0) return null;

      // Get current document path relative to project root
      const fromDocument = documentPath.startsWith(root + '/')
        ? documentPath.slice(root.length + 1)
        : documentPath;

      // Filter to only .md files (content files), excluding mrmd.md
      const mdFiles = files.filter(f => f.endsWith('.md') && f !== 'mrmd.md');

      // Sort by FSML order (numeric prefix, then alphabetical)
      const sorted = [...mdFiles].sort((a, b) => {
        // Extract first path segment's numeric prefix for top-level ordering
        const aSegments = a.split('/');
        const bSegments = b.split('/');

        // Compare path segments level by level
        const maxLen = Math.max(aSegments.length, bSegments.length);
        for (let i = 0; i < maxLen; i++) {
          const aSeg = aSegments[i] || '';
          const bSeg = bSegments[i] || '';

          // Extract numeric prefix
          const aMatch = aSeg.match(/^(\d+)-/);
          const bMatch = bSeg.match(/^(\d+)-/);
          const aOrder = aMatch ? parseInt(aMatch[1]) : Infinity;
          const bOrder = bMatch ? parseInt(bMatch[1]) : Infinity;

          if (aOrder !== bOrder) return aOrder - bOrder;
          if (aSeg !== bSeg) return aSeg.localeCompare(bSeg);
        }
        return 0;
      });

      const currentIndex = sorted.indexOf(fromDocument);

      switch (target.toLowerCase()) {
        case 'next':
          return currentIndex >= 0 && currentIndex < sorted.length - 1
            ? sorted[currentIndex + 1]
            : null;

        case 'prev':
          return currentIndex > 0
            ? sorted[currentIndex - 1]
            : null;

        case 'home':
          return sorted[0] || null;

        case 'up': {
          // Go to parent directory's index or first file
          const parts = fromDocument.split('/');
          if (parts.length > 1) {
            const parentDir = parts.slice(0, -1).join('/');
            // Look for index.md in parent
            const parentIndex = sorted.find(f => f === parentDir + '/index.md');
            if (parentIndex) return parentIndex;
            // Or first file in parent
            const parentFile = sorted.find(f => f.startsWith(parentDir + '/'));
            if (parentFile) return parentFile;
          }
          return sorted[0] || null;
        }

        case 'toc':
          // TODO: TOC should render inline, not navigate
          console.log('[LinkNav] TOC link - inline rendering not yet implemented');
          return null;

        default:
          return null;
      }
    }

    /**
     * Setup link navigation handlers for the editor.
     * Handles wiki-link and file-link navigation events.
     *
     * @param {Object} editor - The mrmd editor instance
     * @param {string} documentPath - Absolute path to the current document
     * @param {Object} project - Project info with files array
     */
    function setupLinkNavigation(editor, documentPath, project) {
      if (!editor?.view) return;

      const editorDom = editor.view.dom;

      // Handle wiki-link navigation: [[target]]
      editorDom.addEventListener('wiki-link-navigate', async (e) => {
        const target = e.detail?.target;
        if (!target) return;

        console.log(`[LinkNav] Wiki-link: ${target}`);

        // Handle special links
        if (target === 'next' || target === 'prev' || target === 'home' || target === 'up' || target === 'toc') {
          if (!project?.files || !documentPath) {
            console.warn('[LinkNav] Cannot resolve special link - missing project or document');
            return;
          }

          const resolved = resolveSpecialLink(target, documentPath, project);
          if (resolved) {
            const fullPath = project.root + '/' + resolved;
            console.log(`[LinkNav] Special link resolved: ${target} -> ${fullPath}`);
            openFile(fullPath);
          } else {
            console.warn(`[LinkNav] Could not resolve special link: ${target}`);
          }
          return;
        }

        // Resolve wiki-link to file path
        if (!project?.files) {
          console.warn('[LinkNav] No project files available');
          return;
        }

        // Find matching file (fuzzy match)
        const targetLower = target.toLowerCase();
        let matchedFile = null;

        for (const filePath of project.files) {
          if (!filePath.endsWith('.md')) continue;

          // Get filename without extension and order prefix
          const segments = filePath.split('/');
          const filename = segments[segments.length - 1];
          const name = filename.replace(/\.md$/, '').replace(/^\d+-/, '');

          // Check for match
          if (name.toLowerCase() === targetLower) {
            matchedFile = filePath;
            break;
          }

          // Also check full path match
          const pathWithoutExt = filePath.replace(/\.md$/, '');
          if (pathWithoutExt.toLowerCase().endsWith(targetLower)) {
            matchedFile = filePath;
            // Don't break - prefer exact name match
          }
        }

        if (matchedFile) {
          const fullPath = project.root + '/' + matchedFile;
          console.log(`[LinkNav] Resolved: ${target} -> ${fullPath}`);
          openFile(fullPath);
        } else {
          console.warn(`[LinkNav] Could not resolve wiki-link: ${target}`);
        }
      });

      // Handle file-link navigation: [text](./path)
      editorDom.addEventListener('file-link-navigate', async (e) => {
        const relativePath = e.detail?.path;
        if (!relativePath) return;

        console.log(`[LinkNav] File link: ${relativePath}`);

        // Resolve relative path from document directory
        const documentDir = documentPath.substring(0, documentPath.lastIndexOf('/'));
        let resolvedPath;

        if (relativePath.startsWith('/')) {
          // Absolute path
          resolvedPath = relativePath;
        } else if (relativePath.startsWith('../') || relativePath.startsWith('./')) {
          // Relative path
          const parts = documentDir.split('/');
          const urlParts = relativePath.split('/');

          for (const part of urlParts) {
            if (part === '..') {
              parts.pop();
            } else if (part !== '.') {
              parts.push(part);
            }
          }
          resolvedPath = parts.join('/');
        } else {
          // Relative without prefix
          resolvedPath = documentDir + '/' + relativePath;
        }

        console.log(`[LinkNav] Resolved: ${relativePath} -> ${resolvedPath}`);

        // Check if it's a markdown file
        if (resolvedPath.endsWith('.md')) {
          // Open in editor
          openFile(resolvedPath);
        } else {
          // Open with system default application
          try {
            await electronAPI.shell.openPath(resolvedPath);
          } catch (err) {
            console.error(`[LinkNav] Failed to open: ${resolvedPath}`, err);
          }
        }
      });

      console.log('[LinkNav] Link navigation handlers installed');
    }

    /**
     * Setup asset URL resolver for the editor.
     * Converts relative asset paths (like ../_assets/image.png) to absolute file:// URLs
     * so images can load correctly in the Electron renderer.
     *
     * @param {Object} editor - The mrmd editor instance
     * @param {string} documentPath - Absolute path to the current document
     */
    function setupAssetResolver(editor, documentPath) {
      if (!editor?.view) return;

      const projectRoot = state.project?.root;
      if (!projectRoot) {
        console.warn('[AssetResolver] No project root, asset resolution disabled');
        return;
      }

      // Get the document's directory (relative paths are resolved from here)
      const documentDir = documentPath.substring(0, documentPath.lastIndexOf('/'));

      // Get the assetResolverFacet from mrmd
      const assetResolverFacet = mrmd.assetResolverFacet;
      if (!assetResolverFacet) {
        console.warn('[AssetResolver] assetResolverFacet not available in mrmd');
        return;
      }

      // Create resolver function that converts relative paths to file:// URLs
      const resolver = (url) => {
        if (!url) return url;

        // Resolve relative path from document directory
        // Handle ../_assets/..., ./_assets/..., _assets/... patterns
        let resolvedPath;
        if (url.startsWith('/')) {
          // Absolute path - use project root
          resolvedPath = projectRoot + url;
        } else if (url.startsWith('../') || url.startsWith('./')) {
          // Relative path - resolve from document directory
          const parts = documentDir.split('/');
          const urlParts = url.split('/');

          for (const part of urlParts) {
            if (part === '..') {
              parts.pop();
            } else if (part !== '.') {
              parts.push(part);
            }
          }
          resolvedPath = parts.join('/');
        } else {
          // Relative path without ./ - resolve from document directory
          resolvedPath = documentDir + '/' + url;
        }

        // Convert to file:// URL
        const fileUrl = 'file://' + resolvedPath;
        console.log(`[AssetResolver] ${url} -> ${fileUrl}`);
        return fileUrl;
      };

      // Add the resolver extension to the editor
      editor.view.dispatch({
        effects: mrmd.codemirror.StateEffect.appendConfig.of(
          assetResolverFacet.of(resolver)
        ),
      });

      console.log('[AssetResolver] Asset resolver installed for', documentDir);
    }

    /**
     * Setup asset handler for saving generated plots/images from code execution.
     * When a code cell produces images (matplotlib plots, etc.), this handler:
     * 1. Fetches the image from the runtime server
     * 2. Saves it to _assets/generated/ in the project
     * 3. Returns the relative path for markdown insertion
     *
     * @param {Object} editor - The mrmd editor instance
     * @param {string} documentPath - Absolute path to the current document
     */
    function setupExecutionAssetHandler(editor, documentPath) {
      if (!editor?.execution) {
        console.warn('[AssetHandler] No execution manager, asset handler disabled');
        return;
      }

      const projectRoot = state.project?.root;
      if (!projectRoot) {
        console.warn('[AssetHandler] No project root, asset handler disabled');
        return;
      }

      // Get document name for relative path computation
      const docRelativePath = documentPath.replace(projectRoot + '/', '');

      // Set the asset handler on the execution manager
      editor.execution.assetHandler = async ({ execId, cellIndex, data, eventType, runtimeUrl, mimeType, url }) => {
        console.log('[AssetHandler] Processing asset:', { execId, eventType, mimeType, url });

        try {
          // Determine filename and fetch URL
          let fetchUrl;
          let filename;

          if (eventType === 'asset' && url) {
            // Asset event: url is like /mrp/v1/assets/exec-123_0001.png
            // Extract filename from URL
            filename = url.split('/').pop();
            fetchUrl = runtimeUrl ? `${runtimeUrl.replace('/mrp/v1', '')}${url}` : url;
          } else if (eventType === 'display' && data.data) {
            // Display event: base64-encoded data
            const imgData = data.data['image/png'] || data.data['image/jpeg'] || data.data['image/svg+xml'];
            if (imgData) {
              // Generate filename based on execId
              const ext = data.data['image/png'] ? '.png' : data.data['image/jpeg'] ? '.jpg' : '.svg';
              filename = `${execId}-${Date.now()}${ext}`;

              // Decode base64 and save directly
              const buffer = Uint8Array.from(atob(imgData), c => c.charCodeAt(0));
              const result = await window.electronAPI.asset.save(projectRoot, buffer, `generated/${filename}`);

              if (result.error) {
                console.error('[AssetHandler] Failed to save display asset:', result.error);
                return null;
              }

              // Compute relative path from document to asset
              // Note: result.path is already relative to _assets/ (e.g., "generated/xxx.png")
              // getRelativePath adds _assets/ prefix internally
              const relativePath = await window.electronAPI.asset.relativePath(
                result.path,
                docRelativePath
              );

              console.log('[AssetHandler] Saved display asset:', result.path, 'relative:', relativePath);
              return { assetPath: result.path, relativePath };
            }
            return null;
          } else {
            console.warn('[AssetHandler] Unknown asset type:', eventType, data);
            return null;
          }

          // Fetch from runtime
          console.log('[AssetHandler] Fetching from:', fetchUrl);
          const response = await fetch(fetchUrl);

          if (!response.ok) {
            console.error('[AssetHandler] Failed to fetch asset:', response.status, response.statusText);
            return null;
          }

          const arrayBuffer = await response.arrayBuffer();
          const buffer = new Uint8Array(arrayBuffer);

          // Save to _assets/generated/
          const result = await window.electronAPI.asset.save(projectRoot, buffer, `generated/${filename}`);

          if (result.error) {
            console.error('[AssetHandler] Failed to save asset:', result.error);
            return null;
          }

          // Compute relative path from document to asset
          // Note: result.path is already relative to _assets/ (e.g., "generated/xxx.png")
          // getRelativePath adds _assets/ prefix internally
          const relativePath = await window.electronAPI.asset.relativePath(
            result.path,
            docRelativePath
          );

          console.log('[AssetHandler] Saved asset:', result.path, 'relative:', relativePath, result.deduplicated ? '(deduplicated)' : '');
          return { assetPath: result.path, relativePath };
        } catch (err) {
          console.error('[AssetHandler] Error processing asset:', err);
          return null;
        }
      };

      console.log('[AssetHandler] Execution asset handler installed');
    }

    /**
     * Add runtime CodeLens extensions to the editor
     * Shows inline controls above yaml config blocks and frontmatter
     * @param {Object} editor - The mrmd editor instance
     */
    function addRuntimeCodeLensToEditor(editor) {
      if (!editor?.view) return;

      const projectName = state.project?.config?.name || 'default';

      // Create CodeLens extensions with callbacks
      const codeLensExtensions = mrmd.runtimeCodeLens.createExtensions({
        projectName,

        // Get session status by name (e.g., "thesis:default")
        getSessionStatus: (sessionName) => {
          if (state.session.name === sessionName && state.session.status !== 'none') {
            return {
              alive: state.session.status === 'connected',
              pid: state.session.info?.pid,
              port: state.session.info?.port,
              error: state.session.status === 'error' ? 'Session failed' : undefined,
            };
          }
          return null;
        },

        // Start a runtime (receives full runtime config from yaml)
        onStart: async (runtime) => {
          console.log('[CodeLens] Start runtime:', runtime);
          const projectRoot = state.project?.root || '';

          // Resolve relative paths to absolute
          const resolvePath = (p) => {
            if (!p) return projectRoot;
            if (p.startsWith('/')) return p;
            return projectRoot ? `${projectRoot}/${p}`.replace(/\/+/g, '/') : p;
          };

          // Build session config from runtime info with resolved paths
          const config = {
            name: runtime.name,
            language: runtime.language,
            venv: resolvePath(runtime.venv),
            cwd: resolvePath(runtime.cwd),
            projectRoot,
          };
          console.log('[CodeLens] Resolved config:', config);
          state.session.config = config;
          await startSession();
          // Rebuild CodeLens to update status
          rebuildEditorCodeLens();
        },

        // Stop a runtime by name
        onStop: async (sessionName) => {
          console.log('[CodeLens] Stop session:', sessionName);
          state.session.name = sessionName;
          await stopSession();
          // Rebuild CodeLens to update status
          rebuildEditorCodeLens();
        },

        // Restart a runtime by name
        onRestart: async (sessionName) => {
          console.log('[CodeLens] Restart session:', sessionName);
          state.session.name = sessionName;
          await restartSession();
          // Rebuild CodeLens to update status
          rebuildEditorCodeLens();
        },

        // Restart all runtimes (for multi-runtime configs)
        onRestartAll: async () => {
          console.log('[CodeLens] Restart all runtimes');
          // For now, just restart the current session
          if (state.session.name) {
            await restartSession();
            rebuildEditorCodeLens();
          }
        },
      });

      // Add extensions to the editor dynamically
      editor.view.dispatch({
        effects: mrmd.codemirror.StateEffect.appendConfig.of(codeLensExtensions),
      });

      console.log('[CodeLens] Runtime CodeLens extensions added to editor');
    }

    /**
     * Rebuild CodeLens decorations in the editor
     * Call this when session status changes
     * Uses requestAnimationFrame to avoid "update during update" errors
     */
    function rebuildEditorCodeLens() {
      if (state.editor?.view) {
        // Defer to avoid calling dispatch during an update cycle
        requestAnimationFrame(() => {
          if (state.editor?.view) {
            mrmd.runtimeCodeLens.rebuild(state.editor.view);
          }
        });
      }
    }

    /**
     * Start session from project config
     */
    async function startSession() {
      if (!state.session.config) {
        console.error('No session config available');
        return;
      }

      const config = state.session.config;
      updateSessionStatus('starting', config.name);

      try {
        // Pass config directly - preload wraps it in { config }
        const result = await electronAPI.session.start(config);

        if (result.success || result.pid) {
          state.session.info = result;
          state.pythonPort = result.port;
          updateSessionStatus('connected', config.name);
          console.log(`Session started: ${config.name} on port ${result.port} (PID ${result.pid})`);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            registerSessionWithEditor(result.port);
          }
        } else {
          updateSessionStatus('error', config.name);
          console.error('Failed to start session:', result.error);
        }
      } catch (e) {
        updateSessionStatus('error', config.name);
        console.error('Session start error:', e);
      }
    }

    /**
     * Restart current session
     */
    async function restartSession() {
      if (!state.session.name) {
        console.error('No session to restart');
        return;
      }

      const sessionName = state.session.name;
      updateSessionStatus('starting', sessionName);

      try {
        const result = await electronAPI.session.restart(sessionName);

        if (result.success || result.pid) {
          state.session.info = result;
          state.pythonPort = result.port;
          updateSessionStatus('connected', sessionName);
          console.log(`Session restarted: ${sessionName} on port ${result.port}`);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            registerSessionWithEditor(result.port);
          }
        } else {
          updateSessionStatus('error', sessionName);
          console.error('Failed to restart session:', result.error);
        }
      } catch (e) {
        updateSessionStatus('error', sessionName);
        console.error('Session restart error:', e);
      }
    }

    /**
     * Stop current session
     */
    async function stopSession() {
      if (!state.session.name) {
        console.error('No session to stop');
        return;
      }

      const sessionName = state.session.name;

      try {
        const result = await electronAPI.session.stop(sessionName);

        if (result.success) {
          state.session.info = null;
          state.pythonPort = null;
          updateSessionStatus('none', null);
          console.log(`Session stopped: ${sessionName}`);
        } else {
          console.error('Failed to stop session:', result.error);
        }
      } catch (e) {
        console.error('Session stop error:', e);
      }
    }

    /**
     * Register session with editor for code execution
     */
    function registerSessionWithEditor(port) {
      if (!state.editor || !port) return;

      const docName = state.currentFile.split('/').pop().replace(/\.md$/, '');
      const pythonClient = new mrmd.MRPClient(
        `http://127.0.0.1:${port}/mrp/v1`,
        { session: docName, languages: ['python', 'py', 'python3'] }
      );
      state.editor.registerRuntime('python', pythonClient);
      console.log('Registered Python runtime with editor');
    }

    /**
     * Create an auto-restarting MRP client wrapper.
     * If execution fails due to connection error, restarts the session and retries.
     */
    function createAutoRestartingBashClient(initialPort, sessionName) {
      let currentPort = initialPort;
      let isRestarting = false;
      const supportedLanguages = ['bash', 'sh', 'shell'];

      // Create the underlying MRPClient
      let realClient = new mrmd.MRPClient(
        `http://127.0.0.1:${currentPort}/mrp/v1`,
        { session: 'default', languages: supportedLanguages }
      );

      // Helper to recreate client with new port
      function updateClient(newPort) {
        currentPort = newPort;
        realClient = new mrmd.MRPClient(
          `http://127.0.0.1:${currentPort}/mrp/v1`,
          { session: 'default', languages: supportedLanguages }
        );
      }

      // Use Proxy to delegate all method calls, intercepting executeStreaming for auto-restart
      return new Proxy(realClient, {
        get(target, prop, receiver) {
          // Always use current realClient (may have been updated)
          const value = realClient[prop];

          // For supports, use our list (faster, no async)
          if (prop === 'supports') {
            return (language) => supportedLanguages.includes(language.toLowerCase());
          }

          // Intercept executeStreaming to add auto-restart
          if (prop === 'executeStreaming') {
            return async function(code, language, onChunk, onStdinRequest, options = {}) {
              try {
                return await realClient.executeStreaming(code, language, onChunk, onStdinRequest, options);
              } catch (error) {
                // Check if it's a connection error
                if (error.message?.includes('Failed to fetch') || error.message?.includes('ERR_CONNECTION')) {
                  console.log('[bash] Connection failed, attempting to restart session...');

                  if (isRestarting) {
                    onChunk?.('Bash session is restarting...', 'Bash session is restarting...', true);
                    throw new Error('Bash session is restarting, please try again');
                  }

                  isRestarting = true;
                  try {
                    const newConfig = await electronAPI.bash.forDocument(state.currentFile);
                    if (newConfig?.alive && newConfig?.port) {
                      updateClient(newConfig.port);
                      state.bashPort = newConfig.port;
                      state.bashSession = newConfig;
                      console.log('[bash] Session restarted on port', currentPort);

                      isRestarting = false;
                      return await realClient.executeStreaming(code, language, onChunk, onStdinRequest, options);
                    } else {
                      throw new Error('Failed to restart bash session');
                    }
                  } catch (restartError) {
                    isRestarting = false;
                    console.error('[bash] Restart failed:', restartError);
                    throw restartError;
                  }
                }
                throw error;
              }
            };
          }

          // For all other properties, delegate to realClient
          if (typeof value === 'function') {
            return value.bind(realClient);
          }
          return value;
        }
      });
    }

    /**
     * Register bash runtime with editor for shell code execution.
     * Bash runtime is per-project, respects session.bash config in mrmd.md.
     */
    async function registerBashWithEditor() {
      console.log('[bash] registerBashWithEditor called');

      if (!state.editor || !state.currentFile) {
        console.log('[bash] No editor or currentFile, skipping');
        return;
      }

      // Check if electronAPI.bash exists (requires app restart after preload changes)
      if (!electronAPI.bash) {
        console.error('[bash] electronAPI.bash not available - restart the app!');
        return;
      }

      try {
        console.log('[bash] Calling bash.forDocument for:', state.currentFile);
        // Get or create bash session for this document
        const bashConfig = await electronAPI.bash.forDocument(state.currentFile);
        console.log('[bash] Got config:', bashConfig);

        if (!bashConfig) {
          console.log('No bash session config for this document');
          return;
        }

        // Check for errors
        if (bashConfig.error) {
          console.error('Bash session error:', bashConfig.error);
          return;
        }

        // Check if session is alive (auto-started or existing)
        if (bashConfig.alive && bashConfig.port) {
          state.bashPort = bashConfig.port;
          state.bashSession = bashConfig;

          // Use auto-restarting client wrapper
          const bashClient = createAutoRestartingBashClient(bashConfig.port, bashConfig.name);
          state.editor.registerRuntime('bash', bashClient);
          console.log('Registered Bash runtime with editor on port', bashConfig.port, 'cwd:', bashConfig.cwd);
        } else {
          console.log('Bash session not started (auto_start may be false)');
        }
      } catch (e) {
        console.error('Error registering bash runtime:', e);
      }
    }

    /**
     * Register PTY session with editor for terminal blocks (```term).
     * Starts mrmd-pty server and sets up terminal launch callback.
     */
    async function registerPtyWithEditor() {
      console.log('[pty] registerPtyWithEditor called');

      if (!state.editor || !state.currentFile) {
        console.log('[pty] No editor or currentFile, skipping');
        return;
      }

      // Check if electronAPI.pty exists
      if (!electronAPI.pty) {
        console.error('[pty] electronAPI.pty not available - restart the app!');
        return;
      }

      // Check if terminal functions are available in mrmd
      if (!mrmd.terminal?.launchTerminal) {
        console.log('[pty] Terminal functions not available in mrmd');
        return;
      }

      try {
        console.log('[pty] Calling pty.forDocument for:', state.currentFile);
        // Get or create PTY session for this document
        const ptyConfig = await electronAPI.pty.forDocument(state.currentFile);
        console.log('[pty] Got config:', ptyConfig);

        if (!ptyConfig) {
          console.log('[pty] No PTY session config for this document');
          return;
        }

        // Check for errors
        if (ptyConfig.error) {
          console.error('[pty] PTY session error:', ptyConfig.error);
          return;
        }

        // Store PTY config in state
        state.ptySession = ptyConfig;

        // Inject terminal overlay styles
        mrmd.terminal.injectTermWidgetStyles();

        // Create terminal config for launching terminals
        state.terminalConfig = {
          filePath: state.currentFile,
          cwd: ptyConfig.cwd,
          venv: ptyConfig.venv,
          baseUrl: ptyConfig.alive ? `http://127.0.0.1:${ptyConfig.port}` : null,
        };

        // Set up the global terminal launch handler for cell controls
        // This will be called when user clicks the terminal button on a ```term block
        window._mrmdLaunchTerminal = (block, blockIndex) => {
          console.log('[pty] Launching terminal for block:', blockIndex, block);
          if (state.terminalConfig && state.editor?.view) {
            mrmd.terminal.launchTerminal(block, state.terminalConfig, state.editor.view);
          } else {
            console.error('[pty] Terminal config or editor not available');
          }
        };

        // Add terminal widget extension (for inline terminal display)
        // and keymap (Ctrl+Enter/Shift+Enter to toggle terminal)
        const terminalExtensions = [];

        if (mrmd.terminal.terminalWidget) {
          terminalExtensions.push(...mrmd.terminal.terminalWidget(state.terminalConfig));
        }

        if (mrmd.terminal.terminalKeymap) {
          terminalExtensions.push(mrmd.terminal.terminalKeymap(state.terminalConfig));
        }

        if (terminalExtensions.length > 0) {
          state.editor.view.dispatch({
            effects: mrmd.codemirror.StateEffect.appendConfig.of(terminalExtensions),
          });
          console.log('[pty] Terminal extensions added (widget + keymap)');
        }

        if (ptyConfig.alive) {
          console.log('[pty] Registered PTY with editor, wsUrl:', ptyConfig.wsUrl);
        } else {
          console.log('[pty] PTY server not started (auto_start may be false)');
        }
      } catch (e) {
        console.error('[pty] Error registering PTY with editor:', e);
      }
    }

    /**
     * Try to auto-detect a venv in common locations near the current file.
     * This enables the "just works" experience without requiring explicit config.
     *
     * Checks (in order):
     * 1. .venv/ in file's directory
     * 2. venv/ in file's directory
     * 3. env/ in file's directory
     * 4. .venv/ in parent directory
     */
    async function tryAutoDetectVenv() {
      if (!state.currentFile) {
        state.session.config = null;
        updateSessionStatus('none', null);
        return;
      }

      const fileDir = state.currentFile.replace(/\/[^/]+$/, '');

      // Check common venv locations
      const candidatePaths = [
        `${fileDir}/.venv`,
        `${fileDir}/venv`,
        `${fileDir}/env`,
        `${fileDir.replace(/\/[^/]+$/, '')}/.venv`, // parent dir
      ];

      for (const venvPath of candidatePaths) {
        try {
          // Check if venv exists by looking for bin/python
          const checkResult = await electronAPI.getFileInfo(`${venvPath}/bin/python`);
          if (checkResult?.success) {
            console.log('[auto-detect] Found venv at:', venvPath);

            // Try to start the runtime
            try {
              updateSessionStatus('connecting', 'Auto-detected');
              const startResult = await electronAPI.startPython(venvPath);

              if (startResult?.success) {
                console.log('[auto-detect] Python runtime started on port:', startResult.port);

                state.pythonPort = startResult.port;
                state.pythonVenv = { path: venvPath, runtimeId: startResult.runtimeId };
                state.session.config = {
                  name: 'auto-detected',
                  venv: venvPath,
                  autoStart: true,
                };
                state.session.info = {
                  alive: true,
                  port: startResult.port,
                  venv: venvPath,
                };

                updateSessionStatus('connected', 'Auto-detected');
                registerSessionWithEditor(startResult.port);
                return;
              }
            } catch (e) {
              console.warn('[auto-detect] Failed to start runtime:', e.message);
              // Continue checking other paths
            }
          }
        } catch {
          // Path doesn't exist, try next
        }
      }

      // No venv found - that's OK, user can create one on first run
      console.log('[auto-detect] No venv found in common locations');
      state.session.config = null;
      updateSessionStatus('none', null);
    }

    /**
     * Resolve and optionally auto-start session for current project
     * If no project exists, auto-detect common venv locations
     */
    async function resolveProjectSession() {
      // If no project, try auto-detecting venv in common locations
      if (!state.project) {
        await tryAutoDetectVenv();
        return;
      }

      try {
        // Get session config from project
        const sessionConfig = await electronAPI.session.forDocument(state.currentFile);

        if (sessionConfig) {
          state.session.config = sessionConfig;

          // Check for errors (e.g., venv not found, auto-start failed)
          if (sessionConfig.error) {
            console.error('Session config error:', sessionConfig.error);
            updateSessionStatus('error', sessionConfig.name);
            showSessionError(sessionConfig.error);
            return;
          }

          // Check if already connected (either existing or auto-started)
          if (sessionConfig.alive && sessionConfig.port) {
            state.session.info = sessionConfig;
            state.pythonPort = sessionConfig.port;
            updateSessionStatus('connected', sessionConfig.name);
            registerSessionWithEditor(sessionConfig.port);
          } else {
            // Show as available but not started
            state.session.name = sessionConfig.name;
            updateSessionStatus('none', null);
          }
        } else {
          state.session.config = null;
          updateSessionStatus('none', null);
        }
      } catch (e) {
        console.error('Error resolving project session:', e);
        updateSessionStatus('error', 'Session error');
      }
    }

    /**
     * Show session error to user
     */
    function showSessionError(message) {
      // For now, log to console. Can enhance with a toast/banner later.
      console.error('Session error:', message);

      // Check for common errors and provide helpful messages
      if (message.includes('mrmd-python not installed')) {
        console.log('Hint: mrmd-python needs to be installed in the venv');
      } else if (message.includes('not found')) {
        console.log('Hint: Check that the venv path in mrmd.md is correct');
      }
    }

    // =========================================================================
    // NO RUNTIME INLINE PROMPT
    // =========================================================================

    /**
     * Current no-runtime prompt state
     */
    let noRuntimePrompt = null;

    /**
     * Show inline prompt when user tries to run code but no runtime is available.
     * This is the "moment of friction" approach from the Jobs/Ive UX discussion.
     *
     * @param {number} cellIndex - Index of the cell that failed
     * @param {Object} cell - Cell info {language, code, start, end}
     * @param {string} language - Language that needs a runtime
     * @param {function} retryCallback - Call this after runtime is set up to retry execution
     */
    function showNoRuntimePrompt(cellIndex, cell, language, retryCallback) {
      // Remove any existing prompt
      hideNoRuntimePrompt();

      // Create prompt element
      const prompt = document.createElement('div');
      prompt.className = 'no-runtime-prompt';
      prompt.id = 'no-runtime-prompt';

      // Position below the cell (approximate - we'll refine this)
      const editorRect = document.getElementById('editor').getBoundingClientRect();
      prompt.style.top = `${editorRect.top + 100}px`;

      // Get language-specific info
      const langLabel = language === 'python' || language === 'py' || language === 'python3'
        ? 'Python'
        : language.charAt(0).toUpperCase() + language.slice(1);

      const isPython = ['python', 'py', 'python3'].includes(language.toLowerCase());

      prompt.innerHTML = `
        <button class="no-runtime-prompt-dismiss" onclick="hideNoRuntimePrompt()"></button>
        <div class="no-runtime-prompt-header">
          <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M8 1v8M8 12v2"/>
            <circle cx="8" cy="8" r="7"/>
          </svg>
          <span>No ${langLabel} environment found</span>
        </div>
        <div class="no-runtime-prompt-actions" id="no-runtime-actions">
          ${isPython ? `
            <button class="no-runtime-prompt-btn primary" onclick="createVenvAndRetry()">
              Create .venv
            </button>
            <button class="no-runtime-prompt-btn" onclick="chooseVenvAndRetry()">
              Choose existing...
            </button>
          ` : `
            <button class="no-runtime-prompt-btn" onclick="hideNoRuntimePrompt()">
              Dismiss
            </button>
          `}
        </div>
      `;

      document.body.appendChild(prompt);

      // Store state for callbacks
      noRuntimePrompt = {
        element: prompt,
        language,
        cellIndex,
        cell,
        retryCallback,
      };

      console.log('[noRuntime] Showing prompt for', language, 'cell', cellIndex);
    }

    /**
     * Hide the no-runtime prompt
     */
    function hideNoRuntimePrompt() {
      const existing = document.getElementById('no-runtime-prompt');
      if (existing) {
        existing.remove();
      }
      noRuntimePrompt = null;
    }

    /**
     * Create .venv in project directory and retry execution
     */
    async function createVenvAndRetry() {
      if (!noRuntimePrompt) return;

      const { retryCallback, language } = noRuntimePrompt;
      const actionsEl = document.getElementById('no-runtime-actions');

      // Show progress
      if (actionsEl) {
        actionsEl.innerHTML = `
          <div class="no-runtime-prompt-progress">
            <div class="no-runtime-prompt-spinner"></div>
            <span>Creating .venv...</span>
          </div>
        `;
      }

      try {
        const venvPath = state.projectDir
          ? `${state.projectDir}/.venv`
          : `${state.currentFile.replace(/\/[^/]+$/, '')}/.venv`;

        console.log('[noRuntime] Creating venv at:', venvPath);

        // Create venv using Python
        const createResult = await electronAPI.createVenv(venvPath);

        if (!createResult?.success) {
          throw new Error(createResult?.error || 'Failed to create venv');
        }

        // Update progress - installing mrmd-python
        if (actionsEl) {
          actionsEl.innerHTML = `
            <div class="no-runtime-prompt-progress">
              <div class="no-runtime-prompt-spinner"></div>
              <span>Installing mrmd-python...</span>
            </div>
          `;
        }

        // Install mrmd-python in the venv
        console.log('[noRuntime] Installing mrmd-python in:', venvPath);
        const installResult = await electronAPI.installMrmdPython(venvPath);

        if (!installResult?.success) {
          throw new Error(installResult?.error || 'Failed to install mrmd-python');
        }

        // Update progress - starting
        if (actionsEl) {
          actionsEl.innerHTML = `
            <div class="no-runtime-prompt-progress">
              <div class="no-runtime-prompt-spinner"></div>
              <span>Starting Python...</span>
            </div>
          `;
        }

        // Start runtime
        const startResult = await electronAPI.startPython(venvPath);

        if (!startResult?.success) {
          throw new Error(startResult?.error || 'Failed to start Python');
        }

        // Register with editor
        if (state.editor && state.currentFile) {
          const docName = state.currentFile.split('/').pop().replace(/\.md$/, '');
          const pythonClient = new mrmd.MRPClient(
            `http://127.0.0.1:${startResult.port}/mrp/v1`,
            { session: docName, languages: ['python', 'py', 'python3'] }
          );
          state.editor.registerRuntime('python', pythonClient);
          state.pythonPort = startResult.port;
          state.pythonVenv = { path: venvPath, runtimeId: startResult.runtimeId };
          console.log('[noRuntime] Python runtime registered');
        }

        // Refresh runtimes panel and update hints
        if (typeof refreshRuntimes === 'function') refreshRuntimes();
        updateSetupHints();

        // Hide prompt and retry
        hideNoRuntimePrompt();

        if (retryCallback) {
          console.log('[noRuntime] Retrying execution...');
          retryCallback();
        }

      } catch (e) {
        console.error('[noRuntime] Failed to create venv:', e);
        if (actionsEl) {
          actionsEl.innerHTML = `
            <div class="no-runtime-prompt-progress" style="color: var(--error, #ef4444);">
              <span>Failed: ${e.message}</span>
            </div>
            <button class="no-runtime-prompt-btn" onclick="hideNoRuntimePrompt()" style="margin-top: 8px;">
              Dismiss
            </button>
          `;
        }
      }
    }

    /**
     * Open venv picker and retry execution after selection
     */
    async function chooseVenvAndRetry() {
      if (!noRuntimePrompt) return;

      const { retryCallback } = noRuntimePrompt;

      // Store retry callback for after venv selection
      window._pendingRuntimeRetry = retryCallback;

      // Hide the prompt
      hideNoRuntimePrompt();

      // Show venv picker
      showVenvPicker();
    }

    /**
     * Hook up noRuntime event handler to editor
     */
    function setupNoRuntimeHandler(editor) {
      if (!editor?.execution?.on) {
        console.log('[noRuntime] Editor execution manager not available');
        return;
      }

      editor.execution.on('noRuntime', (cellIndex, cell, language, retryCallback) => {
        console.log('[noRuntime] Event received for', language);
        showNoRuntimePrompt(cellIndex, cell, language, retryCallback);
      });

      console.log('[noRuntime] Handler registered');
    }

    // =========================================================================
    // SETUP HINTS
    // =========================================================================

    const dismissedHints = new Set();

    /**
     * Update setup hints based on current state
     */
    function updateSetupHints() {
      const hintsEl = document.getElementById('setup-hints');
      const sessionHoverTrigger = document.getElementById('session-hover-trigger');
      const hoverBtn = document.getElementById('session-hover-btn');
      const hoverText = document.getElementById('session-hover-text');
      const hoverIcon = document.getElementById('session-hover-icon');

      if (!hintsEl) return;

      const hints = [];

      // Check for missing project config
      const hasProjectConfig = state.project?.config?.name;
      if (!hasProjectConfig && !dismissedHints.has('no-project')) {
        hints.push('no-project');
      }

      // Check for missing session config in document
      const hasSessionConfig = checkDocumentHasSessionConfig();

      // Check for missing venv
      const hasVenv = state.project?.config?.venv || state.session?.config?.venv;
      if (!hasVenv && hasSessionConfig && !dismissedHints.has('no-venv')) {
        hints.push('no-venv');
      }

      // Show/hide individual hints
      document.getElementById('hint-no-project').style.display =
        hints.includes('no-project') ? 'flex' : 'none';
      document.getElementById('hint-no-venv').style.display =
        hints.includes('no-venv') ? 'flex' : 'none';

      // Show/hide hints container (for project/venv hints only)
      hintsEl.style.display = hints.length > 0 ? 'block' : 'none';

      // Update contextual hover trigger based on Python state
      if (sessionHoverTrigger && hoverText && hoverIcon) {
        const hasRuntime = state.pythonPort != null;
        const hasVenvDetected = state.pythonVenv || state.session?.config?.venv;

        if (hasRuntime) {
          // Python is running - hide the trigger (everything is working)
          sessionHoverTrigger.classList.remove('visible');
        } else if (hasVenvDetected) {
          // Venv exists but not running - show "Start Python"
          sessionHoverTrigger.classList.add('visible');
          hoverText.textContent = 'Start Python';
          hoverIcon.innerHTML = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <polygon points="5,3 13,8 5,13" fill="currentColor"/>
          </svg>`;
          hoverBtn.title = 'Start Python runtime';
        } else if (!hasSessionConfig) {
          // No config, no venv - show contextual prompt
          // But only if this looks like a Python-using document
          const doc = state.editor?.view?.state.doc.toString() || '';
          const hasPythonCode = /```python|```py/.test(doc);

          if (hasPythonCode) {
            sessionHoverTrigger.classList.add('visible');
            hoverText.textContent = 'Setup Python';
            hoverIcon.innerHTML = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="8" cy="8" r="7"/>
              <path d="M8 5v4M8 11v1"/>
            </svg>`;
            hoverBtn.title = 'Set up Python environment';
          } else {
            // No Python code - hide trigger
            sessionHoverTrigger.classList.remove('visible');
          }
        } else {
          // Has config but no venv detected - venv might be missing
          sessionHoverTrigger.classList.add('visible');
          hoverText.textContent = 'Create .venv';
          hoverIcon.innerHTML = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M8 3v10M3 8h10"/>
          </svg>`;
          hoverBtn.title = 'Create Python virtual environment';
        }
      }
    }

    /**
     * Check if current document has session config in frontmatter
     * Supports both verbose (session:) and minimal syntax (python:, bash:, etc.)
     */
    function checkDocumentHasSessionConfig() {
      if (!state.editor?.view) return false;

      const doc = state.editor.view.state.doc.toString();

      // Patterns for both verbose and minimal syntax
      // Verbose: session:
      // Minimal: python:, bash:, node:, julia:, r:, term:
      const runtimePatterns = ['session:', 'python:', 'bash:', 'node:', 'julia:', 'r:', 'term:'];

      // Check for frontmatter
      const frontmatterMatch = doc.match(/^---\n([\s\S]*?)\n---/);
      if (frontmatterMatch) {
        const yaml = frontmatterMatch[1];
        return runtimePatterns.some(p => yaml.includes(p));
      }

      // Also check for ```yaml config blocks with session
      if (doc.includes('```yaml')) {
        return runtimePatterns.some(p => doc.includes(p));
      }

      return false;
    }

    /**
     * Dismiss a hint
     */
    function dismissHint(hintId) {
      dismissedHints.add(hintId);
      updateSetupHints();
    }

    /**
     * Initialize current directory as mrmd project
     */
    async function initializeProject() {
      if (!state.projectDir) {
        alert('No directory to initialize');
        return;
      }

      try {
        // Get folder name for project name
        const folderName = state.projectDir.split('/').pop() || 'project';

        // Create mrmd.md with complete config template
        const mrmdConfig = `# ${folderName}

Project configuration for mrmd.

\`\`\`yaml config
name: "${folderName}"

session:
  python:
    venv: .venv
    cwd: .
    name: default
    auto_start: true
  bash:
    cwd: .
    name: default
    auto_start: true

assets:
  directory: _assets
\`\`\`
`;

        const mrmdPath = state.projectDir + '/mrmd.md';
        await electronAPI.file.write(mrmdPath, mrmdConfig);

        console.log('Project initialized:', mrmdPath);

        // Refresh project info
        const project = await electronAPI.project.get(state.currentFile);
        state.project = project;
        updateNavSidebar(project);
        updateSetupHints();
      } catch (e) {
        console.error('Failed to initialize project:', e);
        alert('Failed to initialize project: ' + e.message);
      }
    }

    /**
     * Handle contextual click on the session hover button.
     * Action depends on current state:
     * - If venv exists but not running: start Python
     * - If no venv: create one
     * - If no config: show setup prompt
     */
    async function handleSessionHoverClick() {
      const hasRuntime = state.pythonPort != null;
      const hasVenvDetected = state.pythonVenv || state.session?.config?.venv;
      const hasSessionConfig = checkDocumentHasSessionConfig();

      if (hasRuntime) {
        // Already running - nothing to do
        return;
      }

      if (hasVenvDetected) {
        // Venv exists but not running - start it
        const venvPath = state.pythonVenv?.path || state.session?.config?.venv;
        if (venvPath) {
          try {
            const hoverText = document.getElementById('session-hover-text');
            if (hoverText) hoverText.textContent = 'Starting...';

            const startResult = await electronAPI.startPython(venvPath);
            if (startResult?.success) {
              state.pythonPort = startResult.port;
              state.pythonVenv = { path: venvPath, runtimeId: startResult.runtimeId };
              updateSessionStatus('connected', 'Started');
              registerSessionWithEditor(startResult.port);
              updateSetupHints();
            }
          } catch (e) {
            console.error('Failed to start Python:', e);
          }
        }
      } else if (!hasSessionConfig) {
        // No config, no venv - show inline prompt (same as noRuntime handler)
        const doc = state.editor?.view?.state.doc.toString() || '';
        const cell = { language: 'python', code: '' };
        showNoRuntimePrompt(0, cell, 'python', null);
      } else {
        // Has config but no venv - create one
        await createVenvAndRetry();
      }
    }

    /**
     * Insert session config at the top of the document.
     * Uses minimal frontmatter syntax: python: .venv
     */
    function insertSessionConfig() {
      if (!state.editor?.view) return;

      const view = state.editor.view;
      const doc = view.state.doc.toString();

      // Check if document already has frontmatter
      if (doc.startsWith('---\n')) {
        // Has frontmatter - add python: .venv line to it
        const endIndex = doc.indexOf('\n---', 3);
        if (endIndex !== -1) {
          // Check if python: already exists
          const frontmatter = doc.slice(4, endIndex);
          if (!frontmatter.includes('python:') && !frontmatter.includes('session:')) {
            // Insert python: .venv before closing ---
            const insertPos = endIndex;
            view.dispatch({
              changes: { from: insertPos, insert: 'python: .venv\n' },
            });
          }
        }
      } else {
        // No frontmatter - add minimal frontmatter at the top
        const minimalFrontmatter = `---
python: .venv
---

`;
        view.dispatch({
          changes: { from: 0, insert: minimalFrontmatter },
          selection: { anchor: minimalFrontmatter.length },
        });
      }

      // Update hints
      setTimeout(updateSetupHints, 100);
    }

    // Note: showVenvPicker() is defined earlier in the VENV PICKER section (line ~3488)
    // It shows the proper venv discovery overlay

    // =========================================================================
    // THEME MANAGEMENT
    // =========================================================================

    const THEMES = ['github', 'midnight', 'nord', 'daylight', 'openresponses', 'grayscale-dark', 'grayscale-light'];
    let currentThemeIndex = 0;

    function applyTheme(themeName) {
      const theme = mrmd.getTheme(themeName);
      if (!theme) {
        console.error('Theme not found:', themeName);
        return;
      }

      // Inject font-face if theme has one
      if (theme.fontFace) {
        let fontStyle = document.getElementById('mrmd-theme-fonts');
        if (!fontStyle) {
          fontStyle = document.createElement('style');
          fontStyle.id = 'mrmd-theme-fonts';
          document.head.insertBefore(fontStyle, document.head.firstChild);
        }
        fontStyle.textContent = theme.fontFace;
      }

      // Apply all theme variables to :root
      const root = document.documentElement;
      for (const [key, value] of Object.entries(theme)) {
        if (key.startsWith('--')) {
          root.style.setProperty(key, value);
        }
      }

      // Set body class for light/dark mode (affects scrollbars, etc.)
      document.body.classList.toggle('light-theme', theme.isDark === false);
      document.body.classList.toggle('dark-theme', theme.isDark !== false);

      // Add theme-specific class for targeted styling
      THEMES.forEach(t => document.body.classList.remove(`theme-${t}`));
      document.body.classList.add(`theme-${themeName}`);

      // Update status bar and settings panel
      const statusThemeEl = document.getElementById('status-theme');
      const settingsThemeEl = document.getElementById('settings-theme');
      if (statusThemeEl) statusThemeEl.textContent = themeName;
      if (settingsThemeEl) settingsThemeEl.textContent = themeName;

      // Update editor if exists
      if (state.editor && state.editor.setTheme) {
        state.editor.setTheme(themeName);
      }

      // Dispatch theme change event for terminal and other listeners
      document.dispatchEvent(new CustomEvent('mrmd-theme-change', { detail: { theme: themeName } }));

      // Save preference
      localStorage.setItem('mrmd-theme', themeName);
      console.log('Applied theme:', themeName);
    }

    function cycleTheme() {
      currentThemeIndex = (currentThemeIndex + 1) % THEMES.length;
      applyTheme(THEMES[currentThemeIndex]);
    }

    function loadSavedTheme() {
      const saved = localStorage.getItem('mrmd-theme') || 'github';
      currentThemeIndex = THEMES.indexOf(saved);
      if (currentThemeIndex < 0) currentThemeIndex = 0;
      applyTheme(THEMES[currentThemeIndex]);
    }

    // =========================================================================
    // UTILITIES
    // =========================================================================

    function formatTimeAgo(date) {
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 60) return 'just now';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
      if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
      if (seconds < 604800) return Math.floor(seconds / 86400) + 'd ago';
      return date.toLocaleDateString();
    }

    // =========================================================================
    // KEYBOARD NAVIGATION
    // =========================================================================

    document.addEventListener('keydown', (e) => {
      const filePickerVisible = document.getElementById('file-picker-overlay').classList.contains('visible');
      const venvPickerVisible = document.getElementById('venv-picker-overlay').classList.contains('visible');

      // Global shortcuts
      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        if (!filePickerVisible) showFilePicker();
        return;
      }

      if ((e.ctrlKey || e.metaKey) && e.key === 'r' && !e.shiftKey) {
        e.preventDefault();
        if (!venvPickerVisible) showVenvPicker();
        return;
      }

      // File picker navigation
      if (filePickerVisible) {
        if (e.key === 'Escape') {
          hideFilePicker();
          return;
        }

        // Count total items including create options
        const totalItems = document.querySelectorAll('#file-list .picker-item').length;

        if (e.key === 'ArrowDown' || (e.ctrlKey && e.key === 'n') || (e.ctrlKey && e.key === 'j')) {
          e.preventDefault();
          if (state.selectedFileIndex < totalItems - 1) {
            selectFileItem(state.selectedFileIndex + 1);
          }
          return;
        }

        if (e.key === 'ArrowUp' || (e.ctrlKey && e.key === 'p') || (e.ctrlKey && e.key === 'k')) {
          e.preventDefault();
          if (state.selectedFileIndex > 0) {
            selectFileItem(state.selectedFileIndex - 1);
          }
          return;
        }

        // Ctrl/Cmd+Enter: Create file/project (jump to create option)
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          // Find the create option and trigger it
          const createItem = document.querySelector('#file-list .picker-item[data-action^="create"]');
          if (createItem) {
            const createIndex = parseInt(createItem.dataset.index);
            selectFileItem(createIndex);
            // Small delay to show selection, then trigger
            setTimeout(() => {
              if (createItem.dataset.action === 'create-file') {
                createNewFile();
              } else if (createItem.dataset.action === 'create-project') {
                createNewProject();
              }
            }, 100);
          }
          return;
        }

        if (e.key === 'Enter') {
          e.preventDefault();
          openSelectedFile();
          return;
        }

        // Tab completion
        if (e.key === 'Tab') {
          e.preventDefault();
          tabComplete();
          return;
        }

        // Backspace at empty input exits folder context
        if (e.key === 'Backspace' && state.folderContext) {
          const input = document.getElementById('file-search');
          if (input.value === '') {
            e.preventDefault();
            exitFolderContext();
            return;
          }
        }
      }

      // Venv picker navigation
      if (venvPickerVisible) {
        if (e.key === 'Escape') {
          hideVenvPicker();
          return;
        }

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          const totalItems = state.filteredRuntimes.length + state.filteredVenvs.length;
          if (state.selectedVenvIndex < totalItems - 1) {
            selectVenvItem(state.selectedVenvIndex + 1);
          }
          return;
        }

        if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (state.selectedVenvIndex > 0) {
            selectVenvItem(state.selectedVenvIndex - 1);
          }
          return;
        }

        if (e.key === 'Enter') {
          e.preventDefault();
          if (e.shiftKey) {
            // Shift+Enter: force new runtime for selected venv
            const numRuntimes = state.filteredRuntimes.length;
            const venvIndex = state.selectedVenvIndex - numRuntimes;
            if (venvIndex >= 0 && venvIndex < state.filteredVenvs.length) {
              startNewRuntime(state.filteredVenvs[venvIndex].path);
            }
          } else {
            selectVenv();
          }
          return;
        }
      }
    });

    // File search input handler
    document.getElementById('file-search').addEventListener('input', (e) => {
      filterFiles(e.target.value);
    });

    document.getElementById('venv-search').addEventListener('input', (e) => {
      filterVenvs(e.target.value);
    });

    document.getElementById('custom-python-path').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const customPath = e.target.value.trim();
        if (customPath) {
          // Expand ~ to home directory
          const expandedPath = customPath.replace(/^~/, '');
          startNewRuntime(expandedPath.startsWith('/') ? expandedPath : customPath);
        }
      }
      if (e.key === 'Escape') {
        hideVenvPicker();
      }
    });

    // =========================================================================
    // IPC EVENT HANDLERS
    // =========================================================================

    electronAPI.onFilesUpdate((data) => {
      state.files = data.files;
      const query = document.getElementById('file-search').value;
      filterFiles(query, { preserveSelection: true });
    });

    electronAPI.onVenvFound((venv) => {
      addVenv(venv);
    });

    electronAPI.onVenvScanDone(() => {
      console.log('Venv scan complete');
    });

    // =========================================================================
    // DATA LOSS PREVENTION
    // =========================================================================
    // Added after investigating unexplained data loss on 2026-01-16.
    // The sync server crashed with OOM, but the editor kept running with no
    // indication that changes weren't being saved. User lost ~2.5 hours of work.
    // These safeguards ensure:
    // 1. User is immediately warned when sync fails
    // 2. Content is automatically backed up to localStorage
    // 3. User can easily recover their content
    // =========================================================================

    let syncHealthy = true;
    let lastBackupTime = null;
    let watchdogInterval = null;
    let syncWarningTimer = null;
    let syncWarningReason = null;
    let syncProvider = null;
    let syncStatusHandler = null;
    let syncErrorHandler = null;
    let syncHasEverConnected = false;

    const SYNC_CONNECT_GRACE_MS = 10000;
    const SYNC_RECONNECT_GRACE_MS = 5000;

    // Handle sync server death notification from main process
    electronAPI.onSyncServerDied((data) => {
      console.error('SYNC SERVER DIED:', data);
      syncHealthy = false;
      clearSyncWarningTimer();
      triggerSyncWarning(data?.reason || 'exited', 'sync-died');

      // Play alert sound (if available)
      try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleQAAe8Te3JZfGBBPsOT/1GscAGTC/tuoXgAAfsT/26deBzSG0+3ZmmQlPnK96uypcTtMdbLt6qx1P0x0tezrrHU/THS07OusdD9Mc7Xs66x0P0xztezrrHQ/THS17Ousc0BNdLXs66xzP0xztOzrrHM/THOz6+urcz9Mc7Tr7KtzP0xztOvrrHM/THO16+yrcz5Mc7Xr66tzP0xztevrrHM/THO16+uscz9MdLXr66xzP0x0tevsq3M/THO16+yrcz9MdLXr7KtzP0x0tevsq3M/THS16+yrcz5MdLXr7KtzP0x0tevsq3M/');
        audio.volume = 0.5;
        audio.play().catch(() => {});
      } catch (e) {}
    });

    function showSyncWarning(data) {
      const banner = document.getElementById('sync-warning-banner');
      const details = document.getElementById('sync-warning-details');
      const reason = data && data.reason ? data.reason : 'connection lost';

      details.textContent = ` Sync server ${reason}. Your current changes exist only in memory!`;
      banner.classList.add('visible');

      // Also update status bar
      const syncDot = document.querySelector('.status-dot');
      if (syncDot) {
        syncDot.className = 'status-dot error';
      }
    }

    function hideSyncWarning() {
      document.getElementById('sync-warning-banner').classList.remove('visible');
    }

    function clearSyncWarningTimer() {
      if (syncWarningTimer) {
        clearTimeout(syncWarningTimer);
        syncWarningTimer = null;
      }
    }

    function triggerSyncWarning(reason, backupReason = 'sync-offline') {
      clearSyncWarningTimer();
      syncHealthy = false;
      showSyncWarning({ reason });
      saveLocalBackup(backupReason);
    }

    function scheduleSyncWarning(reason, delayMs) {
      syncWarningReason = reason;
      if (syncWarningTimer) return;

      syncWarningTimer = setTimeout(() => {
        syncWarningTimer = null;
        triggerSyncWarning(syncWarningReason);
      }, delayMs);
    }

    function detachSyncStatusHandlers() {
      if (!syncProvider) return;

      if (syncStatusHandler) {
        syncProvider.off('status', syncStatusHandler);
      }
      if (syncErrorHandler) {
        syncProvider.off('connection-error', syncErrorHandler);
      }

      syncProvider = null;
      syncStatusHandler = null;
      syncErrorHandler = null;
      syncHasEverConnected = false;
      clearSyncWarningTimer();
    }

    function attachSyncStatusHandlers(editor) {
      detachSyncStatusHandlers();
      if (!editor || !editor.provider) return;

      syncProvider = editor.provider;
      const initialConnected = !!(syncProvider.wsconnected || syncProvider.synced);
      syncHasEverConnected = initialConnected;

      syncStatusHandler = ({ status }) => {
        if (status === 'connected') {
          syncHasEverConnected = true;
          syncHealthy = true;
          clearSyncWarningTimer();
          hideSyncWarning();
          return;
        }

        const delayMs = syncHasEverConnected ? SYNC_RECONNECT_GRACE_MS : SYNC_CONNECT_GRACE_MS;
        const reason = status === 'connecting' ? 'reconnecting' : 'connection lost';
        scheduleSyncWarning(reason, delayMs);
      };

      syncErrorHandler = (event) => {
        console.error('Sync connection error:', event?.message || event);
        triggerSyncWarning('connection error', 'sync-connection-error');
      };

      syncProvider.on('status', syncStatusHandler);
      syncProvider.on('connection-error', syncErrorHandler);

      if (initialConnected) {
        syncHealthy = true;
        clearSyncWarningTimer();
        hideSyncWarning();
      } else {
        // Guard against cases where the provider never reaches "connected"
        scheduleSyncWarning('connection not established', SYNC_CONNECT_GRACE_MS);
      }
    }

    function saveLocalBackup(reason) {
      if (!state.editor || !state.currentFile) return;

      try {
        // Get current content from the editor
        const content = state.editor.getContent ? state.editor.getContent() : '';
        if (!content) return;

        const backup = {
          file: state.currentFile,
          content: content,
          timestamp: new Date().toISOString(),
          reason: reason,
          charCount: content.length,
        };

        // Save to localStorage with timestamp key for history
        const backupKey = `mrmd-backup-${Date.now()}`;
        localStorage.setItem(backupKey, JSON.stringify(backup));

        // Also save as "latest" for quick access
        localStorage.setItem('mrmd-backup-latest', JSON.stringify(backup));

        // Keep only last 10 backups
        const allKeys = Object.keys(localStorage).filter(k => k.startsWith('mrmd-backup-') && k !== 'mrmd-backup-latest');
        if (allKeys.length > 10) {
          allKeys.sort().slice(0, allKeys.length - 10).forEach(k => localStorage.removeItem(k));
        }

        lastBackupTime = new Date();
        console.log(`Backup saved: ${content.length} chars at ${lastBackupTime.toISOString()} (${reason})`);
      } catch (e) {
        console.error('Failed to save backup:', e);
      }
    }

    function copyBackupToClipboard() {
      if (!state.editor) {
        alert('No editor content to copy');
        return;
      }

      try {
        const content = state.editor.getContent ? state.editor.getContent() : '';
        navigator.clipboard.writeText(content).then(() => {
          alert(`Copied ${content.length} characters to clipboard!`);
        }).catch(e => {
          alert('Failed to copy: ' + e.message);
        });
      } catch (e) {
        alert('Failed to get content: ' + e.message);
      }
    }

    function downloadBackup() {
      if (!state.editor || !state.currentFile) {
        alert('No content to download');
        return;
      }

      try {
        const content = state.editor.getContent ? state.editor.getContent() : '';
        const filename = state.currentFile.split('/').pop().replace(/\.md$/, '') + '-backup-' + Date.now() + '.md';

        const blob = new Blob([content], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);

        console.log(`Downloaded backup: ${filename} (${content.length} chars)`);
      } catch (e) {
        alert('Failed to download: ' + e.message);
      }
    }

    async function attemptRecovery() {
      if (!state.currentFile) {
        alert('No file is currently open');
        return;
      }

      console.log('Attempting recovery...');

      // Save a backup first before any recovery attempt
      saveLocalBackup('pre-recovery');

      try {
        // Try to reopen the file (this will start a new sync server)
        await openFile(state.currentFile);

        // If successful, hide the warning
        hideSyncWarning();
        syncHealthy = true;

        alert('Recovery successful! Your document has been reconnected.');
      } catch (e) {
        alert('Recovery failed: ' + e.message + '\n\nPlease use Copy Content or Download Backup to save your work.');
      }
    }

    // Watchdog: periodically check sync health and save backups
    function startWatchdog() {
      if (watchdogInterval) return;

      watchdogInterval = setInterval(() => {
        // Save periodic backup if we have content (every 60 seconds)
        if (state.editor && state.currentFile) {
          saveLocalBackup('periodic');
        }

        // Check WebSocket connection health
        // This catches cases where the sync server is still running but
        // the WebSocket connection was silently dropped.
        if (syncProvider && syncHasEverConnected) {
          const isConnected = !!(syncProvider.wsconnected || syncProvider.synced);

          if (!isConnected && syncHealthy) {
            // Connection was healthy but now appears disconnected
            console.warn('[watchdog] WebSocket appears disconnected, scheduling warning...');
            scheduleSyncWarning('connection appears lost', SYNC_RECONNECT_GRACE_MS);
          } else if (isConnected && !syncHealthy) {
            // Connection was lost but now appears reconnected
            console.log('[watchdog] WebSocket reconnected');
            clearSyncWarningTimer();
            hideSyncWarning();
            syncHealthy = true;
          }
        }
      }, 60000); // Every 60 seconds

      console.log('Watchdog started: periodic backups every 60s, WebSocket health checks');
    }

    function stopWatchdog() {
      if (watchdogInterval) {
        clearInterval(watchdogInterval);
        watchdogInterval = null;
      }
    }

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    // Debounced project refresh
    let projectRefreshTimeout = null;
    function scheduleProjectRefresh() {
      if (projectRefreshTimeout) clearTimeout(projectRefreshTimeout);
      projectRefreshTimeout = setTimeout(async () => {
        if (state.project?.root) {
          console.log('[watch] Refreshing project nav...');
          const project = await electronAPI.project.get(state.currentFile || state.project.root + '/mrmd.md');
          if (project) {
            state.project = project;
            updateNavSidebar(project, state.currentFile);

            // Update wiki-link completion with new files
            if (state.editor && project.files) {
              const parsedFiles = parseProjectFiles(project.files);
              state.editor.setProjectFiles(parsedFiles);
              console.log(`[watch] Wiki-link completion updated with ${parsedFiles.length} files`);
            }
          }
        }
      }, 300); // 300ms debounce
    }

    async function init() {
      console.log('mrmd-electron ready');

      // Load home directory for path resolution
      state.homeDir = await electronAPI.getHomeDir();

      // Load saved theme (must be after mrmd.js is loaded)
      loadSavedTheme();

      // Set up project file change listener
      electronAPI.project.onChanged(({ projectRoot }) => {
        console.log('[watch] Project files changed:', projectRoot);
        scheduleProjectRefresh();
      });

      // Start AI in background
      electronAPI.getAi().then(result => {
        if (result.success) {
          state.aiPort = result.port;
          updateAiStatus('ready');
          // Connect AI client for AI Commands panel
          connectAiServer(`http://127.0.0.1:${result.port}`);
        }
      });

      // DATA LOSS PREVENTION: Start watchdog for periodic backups
      startWatchdog();

      // Show file picker on start
      setTimeout(showFilePicker, 100);
    }

    init();
  </script>
</body>
</html>
