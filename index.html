<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, interactive-widget=resizes-content">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: ws://127.0.0.1:* http://127.0.0.1:*; connect-src 'self' ws://127.0.0.1:* http://127.0.0.1:* https: http: data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://esm.sh https://unpkg.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com blob:; font-src 'self' https://fonts.gstatic.com https://www.openresponses.org; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https:; img-src 'self' data: blob: https: http:; frame-src 'self' blob: data:">
  <title>mrmd</title>
  <link rel="icon" type="image/png" sizes="32x32" href="./assets/icon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./assets/icon-16.png">

  <!-- Typography: Monaspace Neon (code) + Literata (prose) -->
  <!-- Also load Courier Prime + EB Garamond for Grayscale themes -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400;1,700&family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">

  <!-- Bundled fonts: Monaspace Neon + Literata (variable fonts) -->
  <style>
    @font-face {
      font-family: 'Monaspace Neon Var';
      font-style: normal;
      font-weight: 100 900;
      font-display: swap;
      src: url('./assets/fonts/MonaspaceNeon-Variable.woff2') format('woff2');
    }

    @font-face {
      font-family: 'Literata';
      font-style: normal;
      font-weight: 200 900;
      font-display: swap;
      src: url('./assets/fonts/Literata-Variable.ttf') format('truetype');
      font-optical-sizing: auto;
    }

    @font-face {
      font-family: 'Literata';
      font-style: italic;
      font-weight: 200 900;
      font-display: swap;
      src: url('./assets/fonts/Literata-Italic-Variable.ttf') format('truetype');
      font-optical-sizing: auto;
    }
  </style>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    /* Prevent pull-to-refresh on mobile — this is an app, not a webpage */
    html, body {
      overscroll-behavior: none;
      overscroll-behavior-y: none;
    }

    /* Theme variables - will be set by applyTheme() */
    :root {
      --bg: var(--mrmd-bg, #0d1117);
      --bg-secondary: var(--mrmd-panel-bg, #161b22);
      --bg-tertiary: var(--mrmd-hover-bg, #21262d);
      --border: var(--mrmd-border, #30363d);
      --text: var(--mrmd-fg, #c9d1d9);
      --text-muted: var(--mrmd-fg-muted, #8b949e);
      --text-dim: var(--mrmd-fg-dim, #6e7681);
      --accent: var(--mrmd-accent, #58a6ff);
      --success: var(--mrmd-success, #3fb950);
      --warning: var(--mrmd-warning, #d29922);
      --error: var(--mrmd-error, #f85149);

      /* Soft interaction colors (dark theme default) */
      --hover-bg: rgba(255, 255, 255, 0.04);
      --selected-bg: rgba(255, 255, 255, 0.08);
    }

    /* Light theme overrides */
    .light-theme {
      --hover-bg: rgba(0, 0, 0, 0.04);
      --selected-bg: rgba(0, 0, 0, 0.06);
    }

    html, body {
      height: 100%;
      background: var(--editor-background, var(--bg));
      color: var(--text);
      font-family: var(--mrmd-ui-font, -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif);
      font-size: var(--mrmd-ui-font-size, 13px);
      font-weight: var(--widget-font-weight, 400);
    }

    /* Custom scrollbar - subtle (dark theme default) */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.15);
    }
    ::-webkit-scrollbar-corner {
      background: transparent;
    }

    /* Light theme scrollbar */
    .light-theme ::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.15);
    }
    .light-theme ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 0, 0, 0.25);
    }

    /* =======================================================================
       OPENRESPONSES THEME - Matches openresponses.org styling
       Only applies when theme-openresponses class is on body
       ======================================================================= */

    /* Openresponses theme - slate-50 backgrounds like openresponses.org */
    body.theme-openresponses {
      --bg: #f8fafc; /* slate-50 */
      --bg-secondary: #f8fafc; /* slate-50 */
      --hover-bg: #f1f5f9; /* slate-100 */
      --border: #e2e8f0; /* slate-200 */
      --text: #0f172a; /* slate-900 */
      --text-muted: #64748b; /* slate-500 */
      --text-dim: #94a3b8; /* slate-400 */
      --accent: #ea580c; /* orange-600 */
    }

    body.theme-openresponses .app {
      background: #f8fafc !important; /* slate-50 */
    }

    body.theme-openresponses .nav-sidebar {
      background: #f8fafc !important; /* slate-50 */
      border-color: #e2e8f0 !important; /* slate-200 */
    }

    body.theme-openresponses .toc-sidebar {
      background: #f8fafc !important; /* slate-50 */
      border-left: 1px solid #e2e8f0 !important; /* slate-200 */
    }

    body.theme-openresponses .nav-header {
      border-color: #e2e8f0 !important; /* slate-200 */
    }

    body.theme-openresponses .titlebar {
      background: #f8fafc !important; /* slate-50 */
      border-color: #e2e8f0 !important; /* slate-200 */
    }

    body.theme-openresponses .content {
      background: #f8fafc !important; /* slate-50 */
    }

    /* Openresponses nav items - matches openresponses.org style */
    body.theme-openresponses .nav-item {
      border-left: none !important;
      border-radius: 0.75rem;
      margin: 2px 8px;
      padding: 8px 12px;
      font-size: 14px;
      color: #64748b; /* slate-500 */
      background: transparent;
    }

    body.theme-openresponses .nav-item:hover {
      background: #f1f5f9 !important; /* slate-100 */
      color: #334155; /* slate-700 */
    }

    body.theme-openresponses .nav-item.selected {
      background: #f1f5f9 !important; /* slate-100 - subtle gray like openresponses.org */
      color: #0f172a !important; /* slate-900 */
      border-left: none !important;
    }

    body.theme-openresponses .nav-item.folder {
      font-size: 10px;
      letter-spacing: 0.08em;
      color: #94a3b8; /* slate-400 */
      padding: 8px 12px;
      margin-top: 16px;
      background: transparent !important;
      text-transform: uppercase;
    }

    /* Openresponses TOC - matches openresponses.org style */
    body.theme-openresponses .toc-header {
      font-size: 10px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #94a3b8; /* slate-400 */
      padding: 20px 16px 12px 16px;
    }

    body.theme-openresponses .toc-item {
      border-left: 1px solid #e2e8f0; /* slate-200 */
      padding: 4px 0 4px 16px;
      margin-left: 16px;
      font-size: 14px;
      color: #64748b; /* slate-500 */
      background: transparent !important;
    }

    body.theme-openresponses .toc-item:hover {
      color: #334155; /* slate-700 */
      background: transparent !important;
    }

    body.theme-openresponses .toc-item.active {
      color: #ea580c !important; /* orange-600 */
      border-left: 2px solid #ea580c !important; /* orange-600 */
      background: transparent !important;
    }

    /* Status bar for openresponses */
    body.theme-openresponses .status-bar {
      background: #f8fafc !important; /* slate-50 */
      border-color: #e2e8f0 !important;
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    /* Titlebar */
    .titlebar {
      -webkit-app-region: drag;
      height: 38px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .titlebar-title {
      font-size: 13px;
      color: var(--text-dim);
      font-weight: 400;
    }

    .titlebar-btn {
      -webkit-app-region: no-drag;
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 28px;
      height: 28px;
      background: transparent;
      border: none;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-muted);
      transition: background 0.1s, color 0.1s;
    }

    .titlebar-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .titlebar-btn.active {
      color: var(--accent);
    }

    /* Mobile-only: hamburger nav button hidden on desktop */
    .titlebar-mobile-btn {
      display: none;
    }

    /* Search + AI actions: always visible (desktop position adjusted by CTA/account injection) */
    .titlebar-mobile-actions {
      display: flex;
      align-items: center;
      gap: 2px;
      position: absolute;
      right: 48px;
      top: 50%;
      transform: translateY(-50%);
      -webkit-app-region: no-drag;
    }
    .titlebar-mobile-actions .titlebar-mobile-btn {
      display: flex;
      position: static;
      transform: none;
      width: 28px;
      height: 28px;
      min-width: unset;
      min-height: unset;
    }

    /* Main content */
    .content {
      flex: 1;
      display: flex;
      align-items: stretch;
      overflow-y: auto;
      overflow-x: visible;
      position: relative;
      background: var(--editor-background, var(--bg));
    }

    #editor-container {
      flex: 1;
      min-height: 100%;
      padding: 40px 20px 40px 20px;
      padding-right: 10px; /* Account for scrollbar */
      display: none;
      overflow-y: auto;
      position: relative;
    }

    /* Center the editor within its container */
    #editor-container > #editor {
      max-width: 800px;
      margin: 0 auto;
    }

    #editor {
      min-height: 100%;
      border-radius: 0;
      overflow: visible;
    }

    /* Navigation Sidebar */
    .nav-sidebar {
      width: 240px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: none;
      flex-direction: column;
      flex-shrink: 0;
      position: relative;
      transition: width 0.2s ease;
      overflow: visible;
    }

    .nav-sidebar.visible {
      display: flex;
    }

    .nav-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav-title {
      flex: 1;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      cursor: pointer;
      padding: 2px 4px;
      margin: -2px -4px;
      border-radius: 3px;
    }

    .nav-title:hover {
      color: var(--text);
      background: var(--hover-bg);
    }

    .nav-action {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      border-radius: 4px;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 14px;
    }

    .nav-action:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .nav-tree {
      flex: 1;
      overflow-y: auto;
      padding: 12px 0;
    }

    /* Documentation-style navigation */
    .nav-item {
      display: flex;
      align-items: center;
      padding: 6px 16px;
      cursor: pointer;
      font-size: 13px;
      color: var(--text-muted);
      gap: 6px;
      user-select: none;
      border-left: 2px solid transparent;
      margin-left: 0;
      transition: color 0.1s, border-color 0.1s, background 0.1s;
    }

    .nav-item:hover {
      color: var(--text);
      background: var(--hover-bg);
    }

    .nav-item.selected {
      color: var(--accent);
      border-left-color: var(--accent);
      background: rgba(88, 166, 255, 0.08);
    }

    .nav-item.selected .nav-item-label {
      font-weight: 500;
    }

    /* Folder/section headers */
    .nav-item.folder {
      color: var(--text);
      font-weight: 500;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-top: 16px;
      padding-top: 8px;
      padding-bottom: 8px;
      border-left-color: transparent !important;
      background: transparent !important;
    }

    .nav-item.folder:first-child {
      margin-top: 0;
    }

    .nav-item.folder:hover {
      color: var(--text);
      background: transparent;
    }

    .nav-item.folder.selected {
      color: var(--text);
    }

    /* Expand/collapse arrow - subtle */
    .nav-expand {
      width: 14px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8px;
      color: var(--text-dim);
      transition: transform 0.15s ease;
      flex-shrink: 0;
      opacity: 0.6;
    }

    .nav-item:hover .nav-expand {
      opacity: 1;
    }

    .nav-expand.expanded {
      transform: rotate(90deg);
    }

    .nav-expand.hidden {
      width: 14px; /* Keep spacing consistent */
      visibility: hidden;
    }

    .nav-item-label {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Nested items get more indent */
    .nav-children .nav-item:not(.folder) {
      font-size: 13px;
      font-weight: 400;
      text-transform: none;
      letter-spacing: normal;
      margin-top: 0;
    }

    /* Inline rename input */
    .nav-rename-input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--accent);
      border-radius: 2px;
      padding: 2px 4px;
      font-size: 13px;
      color: var(--text);
      outline: none;
      min-width: 0;
    }

    .nav-children {
      /* Children are indented via padding-left on items */
    }

    .nav-children.collapsed {
      display: none;
    }

    /* Drag and drop states */
    .nav-item.dragging {
      opacity: 0.4;
    }

    .nav-item.drop-target {
      background: color-mix(in srgb, var(--accent) 15%, transparent) !important;
      border-left-color: var(--accent) !important;
    }

    .nav-item.drop-above::before {
      content: '';
      position: absolute;
      left: 16px;
      right: 0;
      top: -1px;
      height: 2px;
      background: var(--accent);
      border-radius: 1px;
    }

    .nav-item.drop-below::after {
      content: '';
      position: absolute;
      left: 16px;
      right: 0;
      bottom: -1px;
      height: 2px;
      background: var(--accent);
      border-radius: 1px;
    }

    .nav-item {
      position: relative;
    }

    /* Context menu */
    .nav-context-menu {
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px 0;
      min-width: 160px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      z-index: 1000;
      display: none;
    }

    .nav-context-menu.visible {
      display: block;
    }

    .nav-context-item {
      padding: 8px 12px;
      font-size: 13px;
      color: var(--text);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav-context-item:hover {
      background: var(--hover-bg);
    }

    .nav-context-item.danger {
      color: var(--error);
    }

    .nav-context-separator {
      height: 1px;
      background: var(--border);
      margin: 4px 0;
    }

    /* Status bar */
    .status-bar {
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      padding: 8px 20px;
      display: flex;
      align-items: center;
      gap: 20px;
      font-size: 12px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-muted);
      cursor: pointer;
      padding: 4px 8px;
      margin: -4px -8px;
      border-radius: 4px;
    }

    .status-item:hover { background: var(--hover-bg); }

    .status-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-dim);
      opacity: 0.5;
    }

    .status-dot.ready { background: var(--success); opacity: 0.8; }
    .status-dot.loading { background: var(--warning); opacity: 0.8; }
    .status-dot.error { background: var(--error); opacity: 0.8; }

    /* Session controls moved to CodeLens in editor */

    .status-spacer { flex: 1; }

    .status-file {
      color: var(--text-dim);
      max-width: 300px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .status-theme {
      color: var(--text-dim);
      cursor: pointer;
      padding: 4px 8px;
      margin: -4px -8px;
      border-radius: 4px;
    }
    .status-theme:hover { background: var(--hover-bg); }

    /* Table of Contents Sidebar (Right) */
    .toc-sidebar {
      width: 220px;
      flex-shrink: 0;
      display: none;
      flex-direction: column;
      position: relative;
      height: calc(100vh - 38px); /* Subtract titlebar */
      overflow: visible;
      transition: width 0.2s ease;
    }

    .toc-sidebar.visible {
      display: flex;
    }

    .toc-header {
      padding: 20px 16px 12px 16px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }

    .toc-list {
      flex: 1;
      overflow-y: auto;
      padding: 0 0 20px 0;
    }

    .toc-item {
      display: block;
      padding: 6px 16px;
      font-size: 13px;
      color: var(--text-muted);
      cursor: pointer;
      border-left: 2px solid transparent;
      text-decoration: none;
      line-height: 1.4;
      transition: color 0.1s, border-color 0.1s, background 0.1s;
    }

    .toc-item:hover {
      color: var(--text);
      background: var(--hover-bg);
    }

    .toc-item.active {
      color: var(--accent);
      border-left-color: var(--accent);
    }

    /* Indent based on heading level */
    .toc-item[data-level="1"] { padding-left: 16px; }
    .toc-item[data-level="2"] { padding-left: 16px; }
    .toc-item[data-level="3"] { padding-left: 28px; font-size: 12px; }
    .toc-item[data-level="4"] { padding-left: 40px; font-size: 12px; }
    .toc-item[data-level="5"] { padding-left: 52px; font-size: 12px; }
    .toc-item[data-level="6"] { padding-left: 64px; font-size: 12px; }

    .toc-empty {
      padding: 16px;
      color: var(--text-dim);
      font-size: 12px;
      font-style: italic;
    }

    /* =========================================================================
       SIDEBAR COLLAPSE TOGGLES
       Minimal arrow-only toggles for collapsing nav and TOC sidebars
       ========================================================================= */

    /* Shared toggle button styles - just an arrow, no chrome */
    .sidebar-toggle {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 24px;
      height: 32px;
      background: transparent;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-dim);
      font-size: 14px;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.2s, color 0.15s;
      padding: 0;
      margin: 0;
    }

    .sidebar-toggle:hover {
      color: var(--text);
    }

    /* Show on sidebar hover */
    .nav-sidebar:hover > .nav-toggle,
    .toc-sidebar:hover > .toc-toggle {
      opacity: 0.6;
    }

    .nav-sidebar:hover > .nav-toggle:hover,
    .toc-sidebar:hover > .toc-toggle:hover {
      opacity: 1;
    }

    /* Left nav toggle - inside right edge */
    .nav-toggle {
      right: 4px;
    }

    /* Right TOC toggle - inside left edge */
    .toc-toggle {
      left: 4px;
    }

    /* Collapsed nav sidebar */
    .nav-sidebar.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      border-right: none !important;
    }

    .nav-sidebar.collapsed > .nav-header,
    .nav-sidebar.collapsed > .nav-tree {
      display: none !important;
    }

    .nav-sidebar.collapsed > .nav-toggle {
      display: none !important;
    }

    /* Collapsed TOC sidebar */
    .toc-sidebar.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
    }

    .toc-sidebar.collapsed > .toc-header,
    .toc-sidebar.collapsed > .toc-list {
      display: none !important;
    }

    .toc-sidebar.collapsed > .toc-toggle {
      display: none !important;
    }

    /* Floating toggles (when sidebar collapsed) - also just arrows */
    .sidebar-toggle-floating {
      position: fixed;
      top: calc(50% + 19px);
      transform: translateY(-50%);
      width: 24px;
      height: 32px;
      background: transparent;
      border: none;
      display: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-dim);
      font-size: 14px;
      z-index: 200;
      padding: 0;
      margin: 0;
      transition: color 0.15s, opacity 0.15s;
      opacity: 0.4;
    }

    .sidebar-toggle-floating:hover {
      color: var(--text);
      opacity: 1;
    }

    .nav-toggle-floating {
      left: 4px;
    }

    .nav-toggle-floating.visible {
      display: flex;
    }

    .toc-toggle-floating {
      right: 4px;
    }

    .toc-toggle-floating.visible {
      display: flex;
    }

    /* =========================================================================
       SIDE RAIL SYSTEM
       A floating toggle button that expands into a side rail with tool panels
       ========================================================================= */

    /* Side rail - the vertical bar with icons */
    .side-rail {
      position: fixed;
      top: 38px; /* Below titlebar */
      right: 0;
      bottom: 0;
      width: 48px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      padding: 8px 0;
      z-index: 100;
      transform: translateX(100%);
      transition: transform 0.2s ease;
    }

    .side-rail.open {
      transform: translateX(0);
    }

    /* When rail is open, shift content left to make room */
    .content.rail-open {
      margin-right: 48px;
      transition: margin-right 0.2s ease;
    }

    /* Rail icon buttons */
    .rail-btn {
      width: 48px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 16px;
      position: relative;
      transition: color 0.1s, background 0.1s;
    }

    .rail-btn:hover {
      color: var(--text);
      background: var(--hover-bg);
    }

    .rail-btn.active {
      color: var(--accent);
    }

    /* Active indicator dot */
    .rail-btn.active::before {
      content: '';
      position: absolute;
      left: 4px;
      top: 50%;
      transform: translateY(-50%);
      width: 3px;
      height: 16px;
      background: var(--accent);
      border-radius: 2px;
    }

    /* Spacer to push items to bottom */
    .rail-spacer {
      flex: 1;
    }

    /* Rail section divider */
    .rail-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 8px;
    }

    /* Panel overlay - slides in from right */
    .rail-panel {
      position: fixed;
      top: 38px;
      right: 48px; /* Next to rail */
      bottom: 0;
      width: 280px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      z-index: 99;
      transform: translateX(calc(100% + 48px));
      transition: transform 0.2s ease;
    }

    .rail-panel.open {
      transform: translateX(0);
    }

    /* When a panel is pinned, push editor content left */
    .content.panel-pinned {
      margin-right: 368px; /* 280px panel + 48px rail + 40px padding */
      transition: margin-right 0.2s ease;
    }

    /* Wide panel pinned — hide TOC, use full right margin for panel */
    .content.panel-pinned-wide {
      margin-right: 548px; /* 500px panel + 48px rail */
      transition: margin-right 0.2s ease;
    }

    .content.panel-pinned-wide .toc-sidebar {
      display: none !important;
    }

    /* Panel header */
    .rail-panel-header {
      padding: 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .rail-panel-title {
      flex: 1;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text);
    }

    .rail-panel-close {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
    }

    .rail-panel-close:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .rail-panel-pin {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
      transition: color 0.1s, transform 0.2s;
    }

    .rail-panel-pin:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .rail-panel-pin.active {
      color: var(--accent);
      transform: rotate(45deg);
    }

    .rail-panel-refresh {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
      transition: transform 0.3s;
    }

    .rail-panel-refresh:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .rail-panel-refresh:active {
      transform: rotate(180deg);
    }

    /* Panel content */
    .rail-panel-content {
      flex: 1;
      overflow-y: auto;
      padding: 12px 0;
    }

    /* Wide panel variant (for source code) */
    .rail-panel-wide {
      width: 500px;
    }

    /* Artifact panel - larger for preview */
    .rail-panel-artifact {
      width: 45vw;
      max-width: 800px;
      min-width: 400px;
      display: flex;
      flex-direction: column;
    }

    .artifact-content {
      flex: 1;
      padding: 0;
      overflow: hidden;
      background: #fff;
      border-radius: 4px;
      margin: 8px;
    }

    .artifact-content iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: #fff;
    }

    .artifact-status {
      padding: 8px 16px;
      border-top: 1px solid var(--border);
      font-size: 11px;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .artifact-status-indicator {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--text-dim);
    }

    .artifact-status-indicator.active {
      background: #10b981;
    }

    .rail-panel-btn {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      border-radius: 4px;
    }

    .rail-panel-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    /* Artifact tabs */
    .artifact-tabs {
      display: flex;
      gap: 2px;
      padding: 8px 8px 0;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      overflow-x: auto;
      min-height: 28px;
    }

    .artifact-tabs:empty {
      display: none;
    }

    .artifact-tab {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      font-size: 11px;
      font-weight: 500;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      color: var(--text-muted);
      cursor: pointer;
      white-space: nowrap;
      margin-bottom: -1px;
    }

    .artifact-tab:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .artifact-tab.active {
      background: var(--bg);
      color: var(--text);
      border-bottom: 1px solid var(--bg);
    }

    .artifact-tab-close {
      font-size: 14px;
      line-height: 1;
      opacity: 0.5;
      padding: 0 2px;
      border-radius: 2px;
    }

    .artifact-tab-close:hover {
      opacity: 1;
      background: var(--hover-bg);
    }

    .artifact-status code {
      background: var(--bg-tertiary);
      padding: 1px 4px;
      border-radius: 3px;
      font-size: 10px;
    }

    /* Source panel styles */
    .source-back-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-dim);
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s;
    }
    .source-back-btn:hover:not(:disabled) {
      background: var(--hover-bg);
      color: var(--text);
    }
    .source-back-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    .source-file-path {
      padding: 8px 16px;
      font-size: 11px;
      color: var(--text-dim);
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      font-family: var(--font-mono);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .source-content {
      padding: 0 !important;
    }
    .source-code {
      margin: 0;
      padding: 16px;
      font-family: var(--font-mono);
      font-size: 12px;
      line-height: 1.5;
      overflow-x: auto;
      background: var(--bg-primary);
      color: var(--text);
      white-space: pre;
      tab-size: 4;
    }
    .source-code code {
      font-family: inherit;
    }
    /* Clickable type references in source */
    .source-type-ref {
      color: var(--accent);
      cursor: pointer;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 2px;
    }
    .source-type-ref:hover {
      text-decoration-style: solid;
    }
    /* Python syntax highlighting (basic) */
    .source-code .kw { color: #ff7b72; }  /* keywords */
    .source-code .str { color: #a5d6ff; } /* strings */
    .source-code .num { color: #79c0ff; } /* numbers */
    .source-code .cm { color: #8b949e; }  /* comments */
    .source-code .fn { color: #d2a8ff; }  /* function names */
    .source-code .cls { color: #ffa657; } /* class names */
    .source-code .dec { color: #ffa657; } /* decorators */
    .source-code .type { color: #79c0ff; } /* type annotations */

    /* Panel section */
    .rail-panel-section {
      padding: 0 16px;
      margin-bottom: 16px;
    }

    .rail-panel-section-title {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 8px;
    }

    /* Panel list items */
    .rail-panel-item {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      margin: 0 -12px;
      border-radius: 4px;
      cursor: pointer;
      gap: 10px;
      font-size: 13px;
      color: var(--text);
      transition: background 0.1s;
    }

    .rail-panel-item:hover {
      background: var(--hover-bg);
    }

    .help-snippet-block {
      margin: 8px 0 0;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-primary);
      overflow: hidden;
    }

    .help-snippet-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .help-snippet-title {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .help-snippet-copy {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
    }

    .help-snippet-copy:hover {
      background: var(--accent);
      color: #fff;
    }

    .help-snippet-code {
      margin: 0;
      padding: 10px;
      font-family: var(--font-mono);
      font-size: 11px;
      line-height: 1.45;
      color: var(--text-muted);
      white-space: pre;
      overflow-x: auto;
      max-height: 220px;
    }

    /* Theme Picker Menu */
    .theme-picker-menu {
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
      min-width: 200px;
      max-height: 400px;
      overflow-y: auto;
      z-index: 10000;
      font-size: 13px;
      color: var(--text);
    }

    .theme-picker-header {
      padding: 12px 16px;
      font-weight: 600;
      border-bottom: 1px solid var(--border);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }

    .theme-picker-section {
      padding: 8px 0;
    }

    .theme-picker-section-title {
      padding: 4px 16px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .theme-picker-item {
      padding: 8px 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .theme-picker-item:hover {
      background: var(--bg-tertiary);
    }

    .theme-picker-item.selected {
      background: var(--selected-bg);
      color: var(--accent);
    }

    .theme-picker-delete {
      opacity: 0;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 14px;
      color: var(--text-muted);
    }

    .theme-picker-item:hover .theme-picker-delete {
      opacity: 1;
    }

    .theme-picker-delete:hover {
      background: var(--error);
      color: white;
    }

    .theme-picker-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 0;
    }

    .theme-picker-import {
      color: var(--accent);
    }

    .theme-picker-help {
      color: var(--text-muted);
      font-size: 12px;
    }

    .theme-picker-help span {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 1px solid var(--text-muted);
      font-size: 11px;
      margin-right: 6px;
    }

    /* Theme Help Dialog */
    .theme-help-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
    }

    .theme-help-dialog {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      width: 500px;
      max-width: 90vw;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      color: var(--text);
    }

    .theme-help-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      border-bottom: 1px solid var(--border);
      font-weight: 600;
      font-size: 14px;
    }

    .theme-help-close {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: var(--text-muted);
      padding: 4px 8px;
      border-radius: 4px;
      line-height: 1;
    }

    .theme-help-close:hover {
      background: var(--bg-tertiary);
      color: var(--text);
    }

    .theme-help-content {
      padding: 16px;
      overflow-y: auto;
      font-size: 13px;
      line-height: 1.6;
    }

    .theme-help-content p {
      margin: 0 0 12px 0;
    }

    .theme-help-content pre {
      background: var(--bg);
      border: 1px solid var(--border);
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 12px;
      margin: 12px 0;
    }

    .theme-help-content code {
      font-family: 'SF Mono', Monaco, Consolas, monospace;
      background: var(--bg);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 12px;
      color: var(--accent);
    }

    .theme-help-content pre code {
      background: none;
      padding: 0;
      color: inherit;
    }

    .theme-help-content ul {
      margin: 8px 0;
      padding-left: 20px;
    }

    .theme-help-content li {
      margin: 4px 0;
    }

    .theme-help-dialog-large {
      width: 700px;
      max-height: 85vh;
    }

    .theme-help-content h3 {
      font-size: 15px;
      font-weight: 600;
      margin: 20px 0 10px 0;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--border);
    }

    .theme-help-content h3:first-child {
      margin-top: 0;
    }

    .theme-help-content h4 {
      font-size: 13px;
      font-weight: 600;
      margin: 16px 0 8px 0;
      color: var(--text-muted);
    }

    .theme-help-table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0;
      font-size: 12px;
    }

    .theme-help-table td {
      padding: 4px 8px;
      border-bottom: 1px solid var(--border);
      vertical-align: top;
    }

    .theme-help-table td:first-child {
      white-space: nowrap;
      width: 45%;
    }

    .theme-help-table td:last-child {
      color: var(--text-muted);
    }

    .theme-help-table tr:last-child td {
      border-bottom: none;
    }

    .theme-help-example {
      position: relative;
      margin: 12px 0;
    }

    .theme-help-copy {
      position: absolute;
      top: 8px;
      right: 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      z-index: 1;
    }

    .theme-help-copy:hover {
      background: var(--accent);
      color: white;
    }

    .theme-help-example pre {
      max-height: 400px;
      overflow-y: auto;
      padding-right: 70px;
    }

    .rail-panel-item-icon {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: var(--accent);
      flex-shrink: 0;
    }

    .rail-panel-item-label {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .rail-panel-item-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Variable item style (for Variables panel) */
    /* Variables panel - language tabs */
    .var-tabs {
      display: flex;
      border-bottom: 1px solid var(--border);
      padding: 0 8px;
      gap: 0;
      overflow-x: auto;
      flex-shrink: 0;
    }

    .var-tab {
      padding: 8px 14px;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-muted);
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      white-space: nowrap;
      transition: color 0.1s, border-color 0.1s;
    }

    .var-tab:hover {
      color: var(--text);
    }

    .var-tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    /* RStudio-style variable table */
    .var-table {
      width: 100%;
      font-size: 12px;
      border-collapse: collapse;
    }

    .var-table-header {
      display: flex;
      padding: 6px 12px;
      font-size: 11px;
      font-weight: 600;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .var-table-header-name { width: 30%; flex-shrink: 0; }
    .var-table-header-value { flex: 1; }
    .var-table-header-type { width: 80px; flex-shrink: 0; text-align: right; }

    .var-row {
      display: flex;
      align-items: baseline;
      padding: 4px 12px;
      gap: 8px;
      border-bottom: 1px solid var(--border-light, rgba(128,128,128,0.08));
      transition: background 0.1s;
      cursor: default;
    }

    .var-row:hover {
      background: var(--hover-bg);
    }

    .var-row-name {
      width: 30%;
      flex-shrink: 0;
      font-weight: 500;
      color: var(--text);
      font-family: var(--font-mono, 'SF Mono', Menlo, monospace);
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .var-row-value {
      flex: 1;
      color: var(--text-secondary, var(--text-muted, #a0a0a0));
      font-family: var(--font-mono, 'SF Mono', Menlo, monospace);
      font-size: 11.5px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .var-row-value-string { color: #ce9178; }
    .var-row-value-number { color: #b5cea8; }
    .var-row-value-bool { color: #569cd6; }

    .var-row-type {
      width: 80px;
      flex-shrink: 0;
      text-align: right;
      font-size: 11px;
      color: var(--text-dim);
    }

    .var-row-size {
      font-size: 10px;
      color: var(--text-dim);
      margin-left: 4px;
      opacity: 0.7;
    }

    .var-empty {
      padding: 20px 16px;
      text-align: center;
      color: var(--text-dim);
      font-size: 13px;
    }

    /* Runtime list items */
    .runtimes-list {
      padding: 8px 0;
    }

    .runtimes-empty {
      padding: 16px;
      color: var(--text-dim);
      font-size: 12px;
      text-align: center;
    }

    .runtime-item {
      display: flex;
      align-items: center;
      padding: 8px 16px;
      gap: 10px;
      cursor: pointer;
      transition: background 0.1s;
    }

    .runtime-item:hover {
      background: var(--hover-bg);
    }

    .runtime-item.attached {
      background: rgba(88, 166, 255, 0.08);
    }

    .runtime-item-status {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--success);
      flex-shrink: 0;
    }

    .runtime-item.attached .runtime-item-status {
      background: var(--accent);
      box-shadow: 0 0 0 2px rgba(88, 166, 255, 0.3);
    }

    .runtime-item-info {
      flex: 1;
      min-width: 0;
    }

    .runtime-item-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .runtime-item-meta {
      font-size: 11px;
      color: var(--text-muted);
    }

    .runtime-item-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .runtime-item:hover .runtime-item-actions {
      opacity: 1;
    }

    .runtime-item-btn {
      padding: 2px 6px;
      font-size: 10px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-muted);
      cursor: pointer;
      transition: background 0.1s, color 0.1s, border-color 0.1s;
    }

    .runtime-item-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .runtime-item-btn.danger:hover {
      border-color: var(--error);
      color: var(--error);
    }

    .runtime-lang-badge {
      display: inline-block;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      padding: 1px 4px;
      border-radius: 3px;
      margin-right: 6px;
      vertical-align: middle;
    }

    .runtime-lang-badge.python {
      background: rgba(53, 114, 165, 0.2);
      color: #5a9fd4;
    }

    .runtime-lang-badge.bash {
      background: rgba(76, 175, 80, 0.2);
      color: #81c784;
    }

    .runtime-lang-badge.r {
      background: rgba(39, 109, 195, 0.2);
      color: #6ba3d6;
    }

    .runtime-lang-badge.julia {
      background: rgba(149, 88, 178, 0.2);
      color: #b07fd0;
    }

    .runtime-lang-badge.javascript {
      background: rgba(241, 224, 90, 0.2);
      color: #e8d44d;
    }

    /* Runtime language section in notebook-scoped panel */
    .runtime-lang-section {
      margin-bottom: 4px;
    }

    .runtime-lang-section-header {
      padding: 8px 16px 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .runtime-item--inactive {
      opacity: 0.7;
    }

    .runtime-item--inactive:hover {
      opacity: 1;
    }

    /* Inline runtime configuration panel */
    .runtime-config-panel {
      padding: 8px 16px 12px 32px;
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      animation: config-slide-in 0.15s ease-out;
    }

    @keyframes config-slide-in {
      from { opacity: 0; max-height: 0; }
      to { opacity: 1; max-height: 200px; }
    }

    .runtime-config-field {
      margin-bottom: 8px;
    }

    .runtime-config-field label {
      display: block;
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.3px;
      margin-bottom: 3px;
    }

    .runtime-config-field input {
      width: 100%;
      padding: 5px 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text);
      font-size: 12px;
      font-family: var(--font-mono, 'SF Mono', Monaco, monospace);
      outline: none;
    }

    .runtime-config-field input:focus {
      border-color: var(--accent);
    }

    .runtime-config-field-row {
      display: flex;
      gap: 4px;
    }

    .runtime-config-field-row input {
      flex: 1;
    }

    .runtime-config-actions {
      margin-top: 8px;
      display: flex;
      gap: 8px;
    }

    .runtime-config-actions .runtime-item-btn {
      padding: 4px 12px;
      font-size: 11px;
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .runtime-config-actions .runtime-item-btn:hover {
      filter: brightness(1.1);
    }

    /* =========================================================================
       HOME VIEW
       ========================================================================= */

    /* Home view is a full-page takeover — hides all editor chrome */
    #home-view {
      display: none;
      position: fixed;
      top: 38px; /* below titlebar */
      left: 0;
      right: 0;
      bottom: 0;
      overflow-y: auto;
      padding: 60px 40px 40px;
      background: var(--editor-background, var(--bg));
      z-index: 500; /* above everything except modals */
    }

    #home-view.visible {
      display: block;
    }

    .home-container {
      max-width: 960px;
      margin: 0 auto;
    }

    .home-header {
      margin-bottom: 40px;
      text-align: center;
    }

    .home-title {
      font-size: 28px;
      font-weight: 700;
      color: var(--text);
      margin-bottom: 6px;
      letter-spacing: -0.02em;
    }

    .home-subtitle {
      font-size: 14px;
      color: var(--text-muted);
    }

    .home-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }

    .home-section {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    .home-section-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .home-section-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
    }

    .home-section-action {
      font-size: 11px;
      color: var(--accent);
      cursor: pointer;
      background: none;
      border: none;
      padding: 2px 6px;
      border-radius: 3px;
    }

    .home-section-action:hover {
      background: var(--hover-bg);
    }

    .home-section-content {
      padding: 8px 0;
      max-height: 400px;
      overflow-y: auto;
    }

    .home-file-item,
    .home-project-item,
    .home-runtime-item {
      display: flex;
      align-items: center;
      padding: 8px 16px;
      gap: 10px;
      cursor: pointer;
      transition: background 0.1s;
    }

    .home-file-item:hover,
    .home-project-item:hover,
    .home-runtime-item:hover {
      background: var(--hover-bg);
    }

    .home-item-icon {
      font-size: 14px;
      width: 20px;
      text-align: center;
      flex-shrink: 0;
      color: var(--text-dim);
    }

    .home-item-info {
      flex: 1;
      min-width: 0;
    }

    .home-item-name {
      font-size: 13px;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .home-item-meta {
      font-size: 11px;
      color: var(--text-dim);
      margin-top: 1px;
    }

    .home-item-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.15s;
    }

    .home-runtime-item:hover .home-item-actions {
      opacity: 1;
    }

    .home-item-btn {
      padding: 3px 8px;
      font-size: 10px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 3px;
      color: var(--text-muted);
      cursor: pointer;
    }

    .home-item-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .home-item-btn.danger:hover {
      border-color: var(--error);
      color: var(--error);
    }

    .home-runtime-status {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .home-runtime-status.running {
      background: var(--success);
    }

    .home-runtime-status.stopped {
      background: var(--text-dim);
      opacity: 0.4;
    }

    .home-empty {
      padding: 16px;
      text-align: center;
      color: var(--text-dim);
      font-size: 12px;
    }

    .home-footer {
      margin-top: 24px;
      text-align: center;
      color: var(--text-dim);
      font-size: 12px;
    }

    .home-footer-btn {
      padding: 6px 16px;
      background: var(--error);
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
    }

    .home-footer-btn:hover {
      filter: brightness(1.1);
    }

    /* Home button in titlebar */
    .titlebar-home-btn {
      -webkit-app-region: no-drag;
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 28px;
      height: 28px;
      background: transparent;
      border: none;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--text-muted);
      transition: background 0.1s, color 0.1s;
      font-size: 14px;
    }

    .titlebar-home-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .titlebar-home-btn.active {
      color: var(--accent);
    }

    /* AI Command items */
    .ai-cmd {
      display: flex;
      align-items: center;
      padding: 8px 16px;
      gap: 10px;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.1s;
    }

    .ai-cmd:hover {
      background: var(--hover-bg);
    }

    .ai-cmd.disabled {
      opacity: 0.5;
      pointer-events: none;
    }

    .ai-cmd.loading {
      opacity: 0.7;
      pointer-events: none;
    }

    .ai-cmd.loading .ai-cmd-icon {
      animation: ai-cmd-pulse 1s infinite;
    }

    @keyframes ai-cmd-pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    .ai-cmd-icon {
      width: 20px;
      text-align: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .ai-cmd-label {
      flex: 1;
      font-size: 13px;
      color: var(--text);
    }

    .ai-cmd-hint {
      font-size: 11px;
      color: var(--text-muted);
      opacity: 0.6;
    }

    .ai-cmd-key {
      width: 22px;
      height: 22px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      color: var(--accent);
      flex-shrink: 0;
    }

    .ai-cmd:hover .ai-cmd-key {
      border-color: var(--accent);
      background: rgba(88, 166, 255, 0.1);
    }

    /* Keyboard mode active indicator */
    #panel-ai.keyboard-mode .ai-cmd-key {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }

    #panel-ai.keyboard-mode {
      box-shadow: inset 0 0 0 2px var(--accent);
    }

    .ai-keyboard-hint {
      font-size: 11px;
      color: var(--accent);
      margin-left: auto;
      margin-right: 8px;
    }

    .ai-level-hint {
      font-size: 10px;
      color: var(--text-dim);
      font-weight: normal;
      margin-left: 6px;
    }

    .ai-panel-status {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 16px;
      background: rgba(255, 193, 7, 0.1);
      border-bottom: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 12px;
    }

    .ai-status-icon {
      color: #ffc107;
    }

    .ai-juice-selector {
      display: flex;
      gap: 4px;
      padding: 8px 16px;
    }

    .ai-juice-btn {
      flex: 1;
      padding: 8px 4px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      cursor: pointer;
      font-size: 16px;
      transition: all 0.15s;
    }

    .ai-juice-btn:hover {
      background: var(--hover-bg);
      border-color: var(--text-muted);
    }

    .ai-juice-btn.selected {
      background: var(--accent-bg, rgba(59, 130, 246, 0.15));
      border-color: var(--accent, #3b82f6);
    }

    .ai-reasoning-btn {
      flex: 1;
      padding: 8px 4px;
      border: 1px solid var(--border);
      border-radius: 4px;
      background: var(--bg);
      cursor: pointer;
      font-size: 14px;
      transition: all 0.15s;
    }

    .ai-reasoning-btn:hover {
      background: var(--hover-bg);
      border-color: var(--text-muted);
    }

    .ai-reasoning-btn.selected {
      background: var(--accent-bg, rgba(59, 130, 246, 0.15));
      border-color: var(--accent, #3b82f6);
    }

    .ai-reasoning-btn.disabled,
    .ai-reasoning-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
    }

    .ai-progress {
      padding: 12px 16px;
      background: var(--hover-bg);
      border-bottom: 1px solid var(--border);
    }

    .ai-progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .ai-progress-title {
      font-size: 12px;
      font-weight: 500;
      color: var(--text);
      animation: ai-progress-pulse 1.5s infinite;
    }

    @keyframes ai-progress-pulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    .ai-progress-model {
      font-size: 11px;
      color: var(--text-muted);
    }

    .ai-progress-models {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }

    .ai-progress-chip {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .ai-progress-chip.running {
      background: rgba(59, 130, 246, 0.15);
      border-color: var(--accent, #3b82f6);
      color: var(--accent, #3b82f6);
      animation: ai-progress-pulse 1s infinite;
    }

    .ai-progress-chip.done {
      background: rgba(34, 197, 94, 0.15);
      border-color: #22c55e;
      color: #22c55e;
    }

    .ai-progress-chip.pending {
      opacity: 0.5;
    }

    /* Setup hints banner */
    .setup-hints {
      background: var(--bg);
      border-bottom: 1px solid var(--border);
      padding: 8px 16px;
    }

    .setup-hint {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      background: var(--hover-bg);
      border-radius: 6px;
      margin-bottom: 6px;
    }

    .setup-hint:last-child {
      margin-bottom: 0;
    }

    .hint-icon {
      font-size: 16px;
      flex-shrink: 0;
    }

    .hint-text {
      flex: 1;
      font-size: 13px;
      color: var(--text);
    }

    .hint-action {
      padding: 4px 10px;
      font-size: 12px;
      background: var(--accent, #3b82f6);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      white-space: nowrap;
    }

    .hint-action:hover {
      opacity: 0.9;
    }

    .hint-dismiss {
      padding: 2px 6px;
      font-size: 14px;
      background: transparent;
      color: var(--text-muted);
      border: none;
      cursor: pointer;
      border-radius: 4px;
    }

    .hint-dismiss:hover {
      background: var(--border);
      color: var(--text);
    }

    /* Inline "no runtime" prompt - appears below code cells */
    .no-runtime-prompt {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 16px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 400px;
      animation: prompt-slide-in 0.2s ease-out;
    }

    @keyframes prompt-slide-in {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }

    .no-runtime-prompt-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--text);
    }

    .no-runtime-prompt-header svg {
      width: 16px;
      height: 16px;
      color: var(--warning, #f59e0b);
    }

    .no-runtime-prompt-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .no-runtime-prompt-btn {
      padding: 6px 12px;
      font-size: 12px;
      border-radius: 5px;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.15s;
    }

    .no-runtime-prompt-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--text-muted);
    }

    .no-runtime-prompt-btn.primary {
      background: var(--accent, #3b82f6);
      border-color: var(--accent, #3b82f6);
      color: white;
    }

    .no-runtime-prompt-btn.primary:hover {
      opacity: 0.9;
    }

    .no-runtime-prompt-btn.secondary {
      color: var(--text-muted);
      font-size: 11px;
    }

    .no-runtime-prompt-dismiss {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 2px 6px;
      font-size: 14px;
      background: transparent;
      color: var(--text-muted);
      border: none;
      cursor: pointer;
      border-radius: 4px;
      line-height: 1;
    }

    .no-runtime-prompt-dismiss:hover {
      background: var(--border);
      color: var(--text);
    }

    .no-runtime-prompt-progress {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .no-runtime-prompt-spinner {
      width: 14px;
      height: 14px;
      border: 2px solid var(--border);
      border-top-color: var(--accent, #3b82f6);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Subtle hover trigger for session config */
    .session-hover-trigger {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 48px;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .session-hover-trigger.visible {
      display: flex;
    }

    .session-hover-action {
      opacity: 0;
      padding: 6px 12px;
      font-size: 12px;
      color: var(--text-muted);
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: opacity 0.2s ease, background 0.15s, color 0.15s;
      white-space: nowrap;
    }

    .session-hover-trigger:hover .session-hover-action {
      opacity: 1;
    }

    .session-hover-action:hover {
      background: var(--bg-tertiary);
      color: var(--text);
      border-color: var(--accent);
    }

    .session-hover-action svg {
      width: 14px;
      height: 14px;
      opacity: 0.7;
    }

    /* =========================================================================
       SETTINGS MODAL
       ========================================================================= */

    .settings-modal {
      width: 700px;
      max-height: 80vh;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.4);
      overflow: hidden;
    }

    .settings-header {
      display: flex;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      gap: 12px;
    }

    .settings-header-icon {
      width: 20px;
      height: 20px;
      color: var(--text-muted);
    }

    .settings-header-icon svg {
      width: 20px;
      height: 20px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.5;
    }

    .settings-header-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      flex: 1;
    }

    .settings-header-close {
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      line-height: 1;
    }

    .settings-header-close:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .settings-body {
      display: flex;
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }

    .settings-tabs {
      width: 180px;
      border-right: 1px solid var(--border);
      padding: 12px;
      background: var(--bg);
      flex-shrink: 0;
    }

    .settings-tab {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-muted);
      font-size: 13px;
      margin-bottom: 4px;
      transition: all 0.15s ease;
    }

    .settings-tab:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .settings-tab.active {
      background: var(--accent);
      background: rgba(88, 166, 255, 0.15);
      color: var(--accent);
    }

    .settings-tab-icon {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .settings-tab-icon svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.5;
    }

    .settings-content {
      flex: 1;
      overflow-y: auto;
      padding: 20px 24px;
    }

    .settings-section {
      margin-bottom: 28px;
    }

    .settings-section:last-child {
      margin-bottom: 0;
    }

    .settings-section-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }

    .settings-section-desc {
      font-size: 12px;
      color: var(--text-dim);
      margin-bottom: 16px;
      line-height: 1.5;
    }

    /* API Key Input Row */
    .api-key-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
    }

    .api-key-row:last-child {
      border-bottom: none;
    }

    .api-key-provider {
      width: 120px;
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      flex-shrink: 0;
    }

    .api-key-input-wrap {
      flex: 1;
      position: relative;
    }

    .api-key-input {
      width: 100%;
      padding: 8px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 13px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      outline: none;
      transition: border-color 0.15s ease;
    }

    .api-key-input:focus {
      border-color: var(--accent);
    }

    .api-key-input::placeholder {
      color: var(--text-dim);
      font-family: inherit;
    }

    .api-key-status {
      width: 70px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      flex-shrink: 0;
    }

    .api-key-status.valid {
      color: #3fb950;
    }

    .api-key-status.invalid {
      color: #f85149;
    }

    .api-key-status.testing {
      color: var(--text-dim);
    }

    .api-key-status.empty {
      color: var(--text-dim);
    }

    .api-key-test-btn {
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-muted);
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .api-key-test-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .api-key-test-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .api-key-delete-btn {
      padding: 6px 8px;
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.15s ease;
      flex-shrink: 0;
    }

    .api-key-delete-btn:hover {
      background: rgba(248, 81, 73, 0.15);
      color: #f85149;
    }

    /* Quality Level Row */
    .quality-level-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 0;
      border-bottom: 1px solid var(--border);
    }

    .quality-level-row:last-child {
      border-bottom: none;
    }

    .quality-level-badge {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-tertiary);
      border-radius: 6px;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-muted);
      flex-shrink: 0;
    }

    .quality-level-info {
      flex: 1;
      min-width: 0;
    }

    .quality-level-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
    }

    .quality-level-desc {
      font-size: 11px;
      color: var(--text-dim);
      margin-top: 2px;
    }

    .quality-level-select,
    .quality-level-input {
      width: 280px;
      padding: 8px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 12px;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      outline: none;
      flex-shrink: 0;
    }

    .quality-level-select {
      cursor: pointer;
    }

    .quality-level-select:focus,
    .quality-level-input:focus {
      border-color: var(--accent);
    }

    .quality-level-input::placeholder {
      color: var(--text-dim);
      font-family: inherit;
    }

    /* Custom Commands Tab */
    .custom-section-row {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      background: var(--bg);
      border-radius: 6px;
      margin-bottom: 8px;
    }

    .custom-section-name {
      flex: 1;
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
    }

    .custom-section-count {
      font-size: 11px;
      color: var(--text-dim);
    }

    .custom-section-delete {
      padding: 4px 8px;
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      border-radius: 4px;
    }

    .custom-section-delete:hover {
      background: rgba(248, 81, 73, 0.15);
      color: #f85149;
    }

    .add-section-btn,
    .add-command-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg);
      border: 1px dashed var(--border);
      border-radius: 6px;
      color: var(--text-muted);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.15s ease;
      width: 100%;
      justify-content: center;
    }

    .add-section-btn:hover,
    .add-command-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(88, 166, 255, 0.05);
    }

    /* Custom Command Form */
    .command-form-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1100;
    }

    .command-form {
      width: 500px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 16px 48px rgba(0, 0, 0, 0.4);
      overflow: hidden;
    }

    .command-form-header {
      display: flex;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      gap: 12px;
    }

    .command-form-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      flex: 1;
    }

    .command-form-close {
      background: none;
      border: none;
      color: var(--text-dim);
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      line-height: 1;
    }

    .command-form-close:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .command-form-body {
      padding: 20px;
    }

    .command-form-field {
      margin-bottom: 16px;
    }

    .command-form-field:last-child {
      margin-bottom: 0;
    }

    .command-form-label {
      display: block;
      font-size: 12px;
      font-weight: 500;
      color: var(--text-muted);
      margin-bottom: 6px;
    }

    .command-form-input,
    .command-form-select,
    .command-form-textarea {
      width: 100%;
      padding: 10px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-size: 13px;
      outline: none;
      transition: border-color 0.15s ease;
    }

    .command-form-input:focus,
    .command-form-select:focus,
    .command-form-textarea:focus {
      border-color: var(--accent);
    }

    .command-form-input::placeholder,
    .command-form-textarea::placeholder {
      color: var(--text-dim);
    }

    .command-form-textarea {
      min-height: 100px;
      resize: vertical;
      font-family: inherit;
      line-height: 1.5;
    }

    .command-form-row {
      display: flex;
      gap: 12px;
    }

    .command-form-row .command-form-field {
      flex: 1;
    }

    .command-form-hint {
      font-size: 11px;
      color: var(--text-dim);
      margin-top: 4px;
    }

    .command-form-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      background: var(--bg);
    }

    /* Custom command item in list */
    .custom-command-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: var(--bg);
      border-radius: 6px;
      margin-bottom: 6px;
    }

    .custom-command-item:hover {
      background: var(--hover-bg);
    }

    .custom-command-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      flex: 1;
    }

    .custom-command-meta {
      font-size: 11px;
      color: var(--text-dim);
    }

    .custom-command-actions {
      display: flex;
      gap: 4px;
    }

    .custom-command-btn {
      padding: 4px 8px;
      background: none;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      border-radius: 4px;
      font-size: 11px;
    }

    .custom-command-btn:hover {
      background: var(--bg-tertiary);
      color: var(--text);
    }

    .custom-command-btn.delete:hover {
      background: rgba(248, 81, 73, 0.15);
      color: #f85149;
    }

    /* Settings Footer */
    .settings-footer {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
      padding: 16px 20px;
      border-top: 1px solid var(--border);
      background: var(--bg);
    }

    .settings-btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .settings-btn-secondary {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      color: var(--text-muted);
    }

    .settings-btn-secondary:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .settings-btn-primary {
      background: var(--accent);
      border: 1px solid var(--accent);
      color: white;
    }

    .settings-btn-primary:hover {
      filter: brightness(1.1);
    }

    /* AI Panel Settings Button */
    .ai-settings-btn {
      background: none;
      border: none;
      color: var(--text-dim);
      padding: 4px;
      cursor: pointer;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 4px;
    }

    .ai-settings-btn:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    .ai-settings-btn svg {
      width: 14px;
      height: 14px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.5;
    }

    /* Modal overlay */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(4, 8, 14, 0.62);
      backdrop-filter: blur(4px);
      display: none;
      align-items: flex-start;
      justify-content: center;
      padding-top: 10vh;
      z-index: 1000;
    }

    .modal-overlay.visible { display: flex; }

    /* File Picker Modal */
    .file-picker {
      width: min(960px, calc(100vw - 48px));
      max-height: 78vh;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 18px 50px rgba(0, 0, 0, 0.5);
    }

    .picker-header {
      padding: 16px 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0));
    }

    .picker-icon {
      color: var(--text-dim);
      width: 16px;
      height: 16px;
      flex-shrink: 0;
    }

    .picker-icon svg {
      width: 16px;
      height: 16px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.5;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .picker-input {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--text);
      font-size: 14px;
      outline: none;
    }

    .picker-input::placeholder { color: var(--text-dim); }

    .picker-hint {
      color: var(--text-dim);
      font-size: 11px;
      padding: 2px 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
    }

    .picker-body {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    .picker-list {
      flex: 1;
      overflow-y: auto;
      padding: 12px 12px 16px;
      position: relative;
    }

    .picker-virtual-root {
      position: relative;
      width: 100%;
    }

    .picker-virtual-row {
      position: absolute;
      left: 0;
      right: 0;
      padding: 0;
    }

    .picker-virtual-header {
      display: flex;
      align-items: flex-end;
      pointer-events: none;
    }

    .picker-section {
      margin-bottom: 20px;
    }

    .picker-section:last-child {
      margin-bottom: 0;
    }

    .picker-section-title {
      font-size: 10px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 0 8px 6px;
      margin-bottom: 0;
    }

    .picker-item {
      display: flex;
      align-items: center;
      padding: 10px 8px;
      border: 1px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      gap: 12px;
      transition: background 120ms ease, border-color 120ms ease;
    }

    .picker-item:hover {
      background: var(--hover-bg);
      border-color: rgba(255, 255, 255, 0.08);
    }
    .picker-item.selected {
      background: linear-gradient(90deg, rgba(88, 166, 255, 0.16), rgba(88, 166, 255, 0.08));
      border-color: rgba(88, 166, 255, 0.45);
    }
    .picker-item.selected .picker-item-name {
      color: var(--accent);
    }

    .picker-item-icon {
      width: 16px;
      text-align: center;
      color: var(--text-dim);
      font-size: 12px;
    }

    .picker-item-name {
      flex: 1;
      font-size: 13px;
      font-weight: 400;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .picker-item-path {
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 240px;
    }

    .picker-item-meta {
      font-size: 11px;
      color: var(--text-dim);
      white-space: nowrap;
    }

    .picker-item-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      font-weight: 500;
      text-transform: uppercase;
      flex-shrink: 0;
    }

    .picker-item-badge.notebook {
      background: #f59e0b20;
      color: #f59e0b;
    }

    .picker-preview {
      width: 320px;
      border-left: 1px solid var(--border);
      background: var(--bg);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .preview-header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      border-bottom: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.02);
    }

    .preview-file {
      font-size: 11px;
      color: var(--text-dim);
      max-width: 160px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .preview-content {
      flex: 1;
      padding: 0 16px 16px;
      font-family: inherit;
      font-size: 12px;
      line-height: 1.5;
      color: var(--text-muted);
      white-space: pre-wrap;
      overflow-y: auto;
    }

    .picker-footer {
      padding: 10px 20px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      font-size: 11px;
      color: var(--text-dim);
    }

    .picker-hints {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      min-width: 0;
    }

    .picker-footer kbd {
      background: var(--bg-tertiary);
      padding: 2px 5px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 10px;
    }

    .picker-status {
      margin-left: auto;
      color: var(--text-muted);
      white-space: nowrap;
    }

    /* Folder context bar */
    .picker-context {
      padding: 8px 20px;
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--text-muted);
    }

    .picker-context-path {
      color: var(--accent);
      font-weight: 500;
    }

    .picker-context-hint {
      margin-left: auto;
      font-size: 10px;
      color: var(--text-dim);
    }

    /* Create options */
    .picker-create-section {
      border-top: 1px solid var(--border);
      margin-top: 12px;
      padding-top: 12px;
      position: sticky;
      bottom: 0;
      background: linear-gradient(180deg, rgba(13, 17, 23, 0), rgba(13, 17, 23, 0.95) 35%, rgba(13, 17, 23, 0.98));
    }

    .picker-item.create {
      color: var(--accent);
    }

    .picker-item.create .picker-item-icon {
      color: var(--accent);
    }

    .picker-item.folder .picker-item-icon {
      color: var(--text-dim);
    }

    .picker-item.outside-scope {
      opacity: 0.82;
    }

    .picker-item-badge.scope {
      background: rgba(148, 163, 184, 0.16);
      color: var(--text-muted);
    }

    .picker-item-action {
      font-size: 10px;
      color: var(--text-dim);
      margin-left: auto;
    }

    /* Mode indicator */
    .picker-mode {
      font-size: 10px;
      padding: 2px 8px;
      background: var(--accent);
      color: var(--bg);
      border-radius: 4px;
      font-weight: 500;
    }

    /* Venv Selector Modal */
    .venv-picker {
      width: 420px;
      max-height: 60vh;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }

    .venv-picker .picker-header {
      padding: 16px 20px;
      border-bottom: none;
    }

    .venv-picker .picker-list {
      padding: 8px 12px 16px;
    }

    .venv-picker .picker-section {
      margin-bottom: 20px;
    }

    .venv-picker .picker-section:last-child {
      margin-bottom: 0;
    }

    .venv-picker .picker-section-title {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: none;
      letter-spacing: 0;
      padding: 0 8px 8px;
      margin-bottom: 0;
    }

    .venv-picker .picker-footer {
      padding: 12px 20px;
      border-top: 1px solid var(--border);
      opacity: 0.6;
    }

    .venv-item {
      display: flex;
      align-items: center;
      padding: 12px 8px;
      border-radius: 4px;
      cursor: pointer;
      gap: 12px;
    }

    .venv-item:hover { background: var(--hover-bg); }
    .venv-item.selected { background: var(--selected-bg); }

    .venv-item-info { flex: 1; min-width: 0; }

    .venv-item-name {
      font-size: 14px;
      font-weight: 400;
    }

    .venv-item-path {
      font-size: 12px;
      color: var(--text-muted);
      font-family: inherit;
      margin-top: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .venv-item-version {
      font-size: 12px;
      color: var(--text-muted);
      background: none;
      padding: 0;
    }

    .venv-item-badge {
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 4px;
      background: var(--bg-tertiary);
      color: var(--text-muted);
      font-weight: 400;
    }

    .venv-item-badge.warning {
      background: color-mix(in srgb, var(--warning) 15%, transparent);
      color: var(--warning);
    }

    .venv-item-badge.danger {
      background: color-mix(in srgb, var(--error) 15%, transparent);
      color: var(--error);
    }

    .picker-custom-path {
      padding: 8px 12px;
      border-top: 1px solid var(--border);
    }

    .picker-custom-path input {
      width: 100%;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 8px 12px;
      color: var(--text);
      font-size: 12px;
      outline: none;
    }

    .picker-custom-path input:focus {
      border-color: var(--accent);
    }

    .picker-custom-path input::placeholder {
      color: var(--text-dim);
    }

    /* Loading spinner */
    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
      font-size: 13px;
    }

    /* Match highlight */
    .match {
      color: var(--accent);
      font-weight: 500;
    }

    /* Notebook Open Dialog */
    .notebook-dialog {
      width: 420px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      padding: 24px;
    }

    .notebook-dialog h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }

    .notebook-dialog p {
      margin: 0 0 20px 0;
      font-size: 13px;
      color: var(--text-muted);
    }

    .notebook-dialog-filename {
      font-family: var(--font-mono);
      font-size: 12px;
      color: var(--accent);
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 3px;
      word-break: break-all;
    }

    .notebook-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 16px;
    }

    .notebook-option {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .notebook-option:hover {
      border-color: var(--accent);
      background: var(--hover-bg);
    }

    .notebook-option strong {
      font-size: 14px;
      font-weight: 500;
      color: var(--text);
    }

    .notebook-option span {
      font-size: 12px;
      color: var(--text-muted);
    }

    .notebook-option.convert:hover {
      border-color: var(--warning);
    }

    .notebook-dialog-cancel {
      width: 100%;
      padding: 10px;
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-muted);
      font-size: 13px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .notebook-dialog-cancel:hover {
      background: var(--hover-bg);
      color: var(--text);
    }

    /* =========================================================================
       DATA LOSS PREVENTION - Warning Banner
       =========================================================================
       Added after investigating unexplained data loss on 2026-01-16.
       When sync server crashes, this banner is shown IMMEDIATELY to warn
       the user that their changes are NOT being saved.
       ========================================================================= */
    .sync-warning-banner {
      display: none;
      position: fixed;
      top: 38px; /* Below titlebar */
      left: 0;
      right: 0;
      background: linear-gradient(90deg, #dc2626, #b91c1c);
      color: white;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      z-index: 9999;
      box-shadow: none;
      border-bottom: 1px solid rgba(0, 0, 0, 0.15);
    }

    .sync-warning-banner.visible {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .sync-warning-banner .warning-icon {
      font-size: 20px;
    }

    .sync-warning-banner .warning-message {
      flex: 1;
    }

    .sync-warning-banner .warning-actions {
      display: flex;
      gap: 8px;
    }

    .sync-warning-banner button {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
    }

    .sync-warning-banner button:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .sync-warning-banner button.primary {
      background: white;
      color: #dc2626;
      border-color: white;
    }

    @keyframes pulse-warning {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.85; }
    }

    /* =========================================================================
       MOBILE RESPONSIVE LAYER
       
       Inspired by Quarto, Astro docs, MkDocs Material, Docusaurus, and the
       best tech-blog reading experiences. These sites share a pattern:
       
       - Full-width, single-column content on mobile
       - Hamburger menu for navigation (off-canvas sidebar)
       - Generous typography, padding, and touch targets
       - Tables/code scroll horizontally within the content column
       - Sticky minimal header
       - No TOC on mobile (or behind a toggle)
       - Clean reading experience by default
       
       Uses @media (max-width: 768px) for narrow screens and
       @media (pointer: coarse) for touch-primary devices.
       ========================================================================= */

    /* ---- CORE LAYOUT: Single column, full-width content ---- */
    @media (max-width: 768px) {

      /* Hide sidebars, side rail, floating toggles — all of it */
      .nav-sidebar,
      .toc-sidebar,
      .side-rail,
      .sidebar-toggle-floating,
      .nav-toggle-floating,
      .toc-toggle-floating {
        display: none !important;
      }

      /* Titlebar becomes a slim sticky mobile header */
      .titlebar {
        height: 48px;
        -webkit-app-region: no-drag;
        position: sticky;
        top: 0;
        z-index: 500;
        padding: 0 4px;
        justify-content: space-between;
        align-items: center;
        gap: 0;
        background: var(--bg-secondary);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }

      .titlebar-title {
        font-size: 14px;
        font-weight: 500;
        color: var(--text);
        flex: 1;
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding: 0 4px;
      }

      /* Hide desktop rail toggle on mobile */
      .titlebar-desktop-btn {
        display: none !important;
      }

      /* Show ALL mobile buttons (hamburger too) */
      .titlebar-mobile-btn {
        display: flex !important;
        position: relative;
        right: auto;
        top: auto;
        transform: none;
        width: 44px;
        height: 44px;
        flex-shrink: 0;
        min-width: 44px;
        min-height: 44px;
      }

      .titlebar-mobile-actions {
        position: static;
        transform: none;
        display: flex !important;
        align-items: center;
        gap: 0;
      }

      .titlebar-mobile-btn svg {
        width: 18px;
        height: 18px;
      }

      /* Content area: full width, proper spacing */
      .content {
        flex-direction: column;
        margin-right: 0 !important; /* Override panel-pinned margins */
      }

      /* Editor container: generous mobile padding, no artificial max-width */
      #editor-container {
        padding: 16px 0 80px 0; /* Bottom padding for status bar / safe area */
        padding-bottom: calc(80px + env(safe-area-inset-bottom, 0px));
      }

      /* The editor wrapper: full width with reading-comfortable margins */
      #editor-container > #editor {
        max-width: 100%;
        margin: 0;
      }

      /* The CM editor itself: comfortable reading padding */
      #editor .cm-editor {
        font-size: 17px; /* Slightly larger for readability, like iA Writer */
      }

      #editor .cm-editor .cm-scroller {
        padding: 0 16px;
      }

      #editor .cm-editor .cm-content {
        max-width: 100%;
      }

      /* Status bar: bigger, mobile-friendly */
      .status-bar {
        padding: 10px 16px;
        gap: 12px;
        font-size: 13px;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 400;
        padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
        background: var(--bg-secondary);
        border-top: 1px solid var(--border);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }

      .status-item {
        padding: 8px 12px;
        margin: -8px -12px;
        min-height: 44px; /* Apple's minimum touch target */
        display: flex;
        align-items: center;
      }

      .status-dot {
        width: 8px;
        height: 8px;
      }

      /* Hide less important status items on mobile */
      .status-file {
        max-width: 50vw;
      }

      /* Side rail panels become bottom sheets on mobile */
      .rail-panel {
        position: fixed;
        top: auto;
        left: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        height: 70vh;
        border-left: none;
        border-top: 1px solid var(--border);
        border-radius: 16px 16px 0 0;
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.2);
        z-index: 600;
      }

      .rail-panel.open {
        transform: translateY(0);
      }

      .rail-panel-header {
        padding: 12px 16px;
        position: relative;
      }

      /* Bottom sheet drag handle */
      .rail-panel-header::before {
        content: '';
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
        width: 36px;
        height: 4px;
        background: var(--text-dim);
        border-radius: 2px;
        opacity: 0.4;
      }

      /* Session hover trigger — larger on mobile */
      .session-hover-trigger {
        margin: 8px 16px;
      }

      .session-hover-action {
        min-height: 44px;
        font-size: 14px;
        padding: 10px 16px;
      }

      /* Setup hints — full width */
      .setup-hints {
        margin: 0 16px;
      }

      .setup-hint {
        font-size: 13px;
        padding: 12px;
      }

      /* Context menus become bottom sheets */
      .nav-context-menu {
        position: fixed !important;
        top: auto !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important;
        border-radius: 16px 16px 0 0;
        box-shadow: 0 -4px 24px rgba(0, 0, 0, 0.3);
        padding: 8px 0;
        padding-bottom: calc(8px + env(safe-area-inset-bottom, 0px));
        z-index: 1000;
      }

      .nav-context-item {
        padding: 14px 20px;
        font-size: 16px;
        min-height: 48px;
      }

      /* Sync warning banner — stack buttons */
      .sync-warning-banner {
        flex-wrap: wrap;
      }

      .sync-warning-banner .warning-message {
        width: 100%;
      }

      .warning-actions {
        width: 100%;
        flex-wrap: wrap;
      }

      .sync-warning-banner button {
        flex: 1;
        min-width: 0;
      }
    }

    /* ---- TOUCH TARGETS: Bigger hit areas for coarse pointers ---- */
    @media (pointer: coarse) {

      /* All buttons & interactive elements: minimum 44px touch target */
      .titlebar-btn,
      .nav-action,
      .status-item,
      .rail-btn,
      .rail-panel-close,
      .rail-panel-pin,
      .rail-panel-refresh {
        min-width: 44px;
        min-height: 44px;
      }

      .rail-btn {
        height: 48px;
      }

      /* Nav items — bigger for finger tapping */
      .nav-item {
        padding: 12px 16px;
        font-size: 15px;
        min-height: 44px;
      }

      .nav-item.folder {
        padding: 12px 16px;
        margin-top: 20px;
        font-size: 13px;
      }

      /* TOC items — bigger */
      .toc-item {
        padding: 10px 16px;
        font-size: 14px;
        min-height: 44px;
      }

      /* Context menu items */
      .nav-context-item {
        padding: 14px 16px;
        font-size: 15px;
      }
    }

    /* ---- MOBILE HAMBURGER OVERLAY (Nav as a full-screen slide-over) ---- */
    @media (max-width: 768px) {

      /* When nav is explicitly shown on mobile, it overlays everything */
      .nav-sidebar.mobile-open {
        display: flex !important;
        position: fixed;
        top: 0;
        left: 0;
        bottom: 0;
        width: 85vw;
        max-width: 320px;
        z-index: 700;
        border-right: 1px solid var(--border);
        box-shadow: 4px 0 24px rgba(0, 0, 0, 0.3);
        animation: slideInLeft 0.25s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @keyframes slideInLeft {
        from { transform: translateX(-100%); }
        to { transform: translateX(0); }
      }

      /* Scrim/backdrop behind the mobile nav */
      .mobile-nav-scrim {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 699;
        animation: fadeIn 0.2s ease;
      }

      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }

      /* Override collapsed states on mobile — we control visibility ourselves */
      .nav-sidebar.collapsed.mobile-open {
        width: 85vw !important;
        max-width: 320px !important;
        padding: 0 !important;
        border-right: 1px solid var(--border) !important;
      }

      .nav-sidebar.collapsed.mobile-open > .nav-header,
      .nav-sidebar.collapsed.mobile-open > .nav-tree {
        display: flex !important;
      }

      .nav-sidebar.collapsed.mobile-open > .nav-tree {
        display: block !important;
      }

      /* Hide the collapse toggle inside the mobile nav — not needed */
      .nav-sidebar.mobile-open > .nav-toggle {
        display: none !important;
      }

      /* Nav tree items — larger on mobile overlay */
      .nav-sidebar.mobile-open .nav-item {
        padding: 14px 20px;
        font-size: 15px;
        min-height: 48px;
        border-left-width: 3px;
      }

      .nav-sidebar.mobile-open .nav-item.folder {
        padding: 14px 20px;
        font-size: 12px;
      }

      .nav-sidebar.mobile-open .nav-header {
        padding: 16px 20px;
        min-height: 56px;
      }

      .nav-sidebar.mobile-open .nav-action {
        width: 44px;
        height: 44px;
        font-size: 18px;
      }
    }

    /* ---- TYPOGRAPHY & READING COMFORT ---- */
    @media (max-width: 768px) {

      /* Code blocks: ensure horizontal scroll, no wrapping on narrow screens */
      #editor .cm-codeblock-line {
        font-size: max(var(--code-font-size, 0.8em), 13px);
      }

      #editor .cm-codeblock-fence {
        font-size: 0.55em;
      }

      /* Tables: horizontal scroll wrapper */
      #editor .cm-table-widget {
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
      }

      /* Images: full-width, respect safe area */
      #editor .cm-image-block-img {
        max-width: calc(100vw - 32px);
      }

      /* Wide images: don't break out of viewport on mobile */
      #editor .cm-image-pos-wide {
        width: calc(100vw - 32px);
        max-width: calc(100vw - 32px);
        margin-left: 0;
        margin-right: 0;
      }

      /* Blockquotes: slightly less padding */
      #editor .cm-md-blockquote-line {
        padding-left: 0.75em;
      }

      /* Inline code: ensure it doesn't overflow */
      #editor .cm-md-inline-code {
        word-break: break-all;
      }
    }

    /* ---- FILE PICKER (Ctrl+P): Full-screen bottom sheet on mobile ---- */
    @media (max-width: 768px) {

      /* Modal overlay: no top padding, fill screen */
      .modal-overlay {
        padding-top: 0;
        align-items: stretch;
      }

      /* File picker: full screen, no border radius */
      .file-picker {
        width: 100% !important;
        max-width: 100% !important;
        max-height: 100vh;
        height: 100vh;
        border-radius: 0;
        border: none;
      }

      /* Search header: bigger, more padding, sticky */
      .file-picker .picker-header {
        padding: 12px 16px;
        gap: 10px;
        position: sticky;
        top: 0;
        z-index: 10;
        background: var(--bg-secondary);
        min-height: 56px;
      }

      .file-picker .picker-icon {
        width: 20px;
        height: 20px;
      }

      .file-picker .picker-icon svg {
        width: 20px;
        height: 20px;
      }

      .file-picker .picker-input {
        font-size: 16px; /* Prevents iOS zoom-on-focus */
        padding: 4px 0;
      }

      /* Hide the esc hint on mobile (no keyboard) */
      .file-picker .picker-hint {
        display: none;
      }

      /* Context bar: slightly bigger */
      .picker-context {
        padding: 10px 16px;
        font-size: 13px;
      }

      .picker-context-hint {
        display: none; /* Hide keyboard hints */
      }

      /* Body: single column, no preview pane */
      .file-picker .picker-body {
        flex-direction: column;
        flex: 1;
        min-height: 0;
      }

      /* Hide preview pane entirely on mobile */
      .file-picker .picker-preview {
        display: none !important;
      }

      /* File list: full width, comfortable padding */
      .file-picker .picker-list {
        padding: 8px;
      }

      /* Items: much bigger touch targets */
      .picker-item {
        padding: 14px 12px !important;
        min-height: 52px;
        gap: 14px !important;
        border-radius: 10px !important;
      }

      .picker-item-icon {
        width: 24px !important;
        font-size: 16px !important;
      }

      .picker-item-name {
        font-size: 15px !important;
      }

      .picker-item-path {
        font-size: 12px !important;
        max-width: 50vw !important;
      }

      .picker-item-meta {
        font-size: 12px !important;
      }

      .picker-item-badge {
        font-size: 11px !important;
        padding: 3px 8px !important;
      }

      /* Section titles: larger */
      .picker-section-title {
        font-size: 11px !important;
        padding: 4px 12px 8px !important;
      }

      /* Footer: simplified for mobile */
      .picker-footer {
        padding: 12px 16px;
        padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
        gap: 8px;
      }

      .picker-footer kbd {
        display: none; /* Hide keyboard shortcuts */
      }

      .picker-hints {
        display: none; /* Hide keyboard hint row */
      }

      .picker-status {
        margin-left: 0;
        font-size: 13px;
      }

      /* Create section: full width, comfortable */
      .picker-create-section {
        margin-top: 8px;
        padding-top: 8px;
      }

      .picker-item.create {
        min-height: 52px;
      }

      /* Mode indicator: bigger */
      .picker-mode {
        font-size: 12px;
        padding: 4px 10px;
      }
    }

    /* ---- VENV PICKER: Bottom sheet on mobile ---- */
    @media (max-width: 768px) {

      .venv-picker {
        width: 100% !important;
        max-height: 85vh;
        border-radius: 16px 16px 0 0;
        border: none;
        border-top: 1px solid var(--border);
      }

      /* Reposition overlay for bottom sheets */
      #venv-picker-overlay.visible {
        align-items: flex-end;
        padding-top: 0;
      }

      .venv-picker .picker-header {
        padding: 16px;
        min-height: 56px;
        position: relative;
      }

      /* Drag handle */
      .venv-picker .picker-header::before {
        content: '';
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
        width: 36px;
        height: 4px;
        background: var(--text-dim);
        border-radius: 2px;
        opacity: 0.4;
      }

      .venv-picker .picker-input {
        font-size: 16px; /* Prevents iOS zoom */
      }

      .venv-picker .picker-hint {
        display: none;
      }

      .venv-picker .picker-list {
        max-height: 50vh !important;
      }

      .venv-item {
        padding: 14px 16px !important;
        min-height: 52px;
      }

      .venv-item-name {
        font-size: 15px !important;
      }

      .venv-item-path {
        font-size: 12px !important;
      }

      .venv-picker .picker-footer {
        padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
      }

      .venv-picker .picker-footer kbd {
        display: none;
      }

      .picker-custom-path input {
        font-size: 16px;
        padding: 12px;
      }
    }

    /* ---- SIDE RAIL: Mobile bottom toolbar ---- */
    /* Instead of hiding the rail completely, show it as a compact bottom bar
       above the status bar. This gives quick access to tools (runtimes,
       variables, AI, settings) like mobile app tab bars. */
    @media (max-width: 768px) {

      /* Override the previous display:none — show rail as bottom bar */
      .side-rail {
        display: flex !important;
        position: fixed !important;
        top: auto !important;
        right: auto !important;
        left: 0 !important;
        bottom: 0 !important;
        width: 100% !important;
        height: auto !important;
        flex-direction: row !important;
        justify-content: space-around;
        align-items: center;
        padding: 4px 0 !important;
        padding-bottom: calc(4px + env(safe-area-inset-bottom, 0px)) !important;
        border-left: none !important;
        border-top: 1px solid var(--border);
        background: var(--bg-secondary);
        backdrop-filter: blur(16px);
        -webkit-backdrop-filter: blur(16px);
        transform: none !important;
        z-index: 450 !important;
      }

      /* Always show rail on mobile (override .side-rail without .open) */
      .side-rail:not(.open) {
        transform: none !important;
      }

      /* Rail buttons: tab bar style */
      .rail-btn {
        width: auto !important;
        height: 44px !important;
        min-width: 44px;
        padding: 0 8px;
        flex-direction: column;
        gap: 2px;
      }

      .rail-btn svg {
        width: 18px;
        height: 18px;
      }

      /* Active indicator: bottom dot instead of left bar */
      .rail-btn.active::before {
        left: 50% !important;
        top: auto !important;
        bottom: 2px;
        transform: translateX(-50%) !important;
        width: 16px !important;
        height: 3px !important;
        border-radius: 2px;
      }

      /* Hide spacer and divider in horizontal layout */
      .rail-spacer {
        display: none;
      }

      .rail-divider {
        display: none;
      }

      /* Rail panels: become bottom sheets that slide up above the tab bar */
      .rail-panel {
        position: fixed !important;
        top: auto !important;
        left: 0 !important;
        right: 0 !important;
        bottom: 0 !important;
        width: 100% !important;
        height: 75vh !important;
        min-width: 100% !important;
        max-width: 100% !important;
        border-left: none !important;
        border-top: 1px solid var(--border);
        border-radius: 16px 16px 0 0 !important;
        box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.3) !important;
        z-index: 600 !important;
        transform: translateY(100%) !important;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
      }

      .rail-panel.open {
        transform: translateY(0) !important;
      }

      /* Pinning doesn't make sense on mobile — just overlay */
      .rail-panel.pinned {
        box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.3) !important;
      }

      .content.panel-pinned,
      .content.panel-pinned-wide {
        margin-right: 0 !important;
      }

      /* Panel header: bigger, with drag handle */
      .rail-panel-header {
        padding: 16px 16px 12px !important;
        min-height: 52px;
        position: relative;
      }

      .rail-panel-header::before {
        content: '';
        position: absolute;
        top: 8px;
        left: 50%;
        transform: translateX(-50%);
        width: 36px;
        height: 4px;
        background: var(--text-dim);
        border-radius: 2px;
        opacity: 0.4;
      }

      .rail-panel-title {
        font-size: 14px !important;
        padding-top: 4px;
      }

      .rail-panel-close,
      .rail-panel-pin,
      .rail-panel-refresh {
        width: 36px !important;
        height: 36px !important;
      }

      /* Hide pin button on mobile — not useful */
      .rail-panel-pin {
        display: none !important;
      }

      .rail-panel-content {
        padding: 8px 4px;
      }

      /* Panel items: bigger touch targets */
      .rail-panel-item {
        padding: 14px 16px !important;
        min-height: 48px;
        font-size: 14px;
      }

      .rail-panel-item-icon {
        width: 24px;
        font-size: 18px;
      }

      .rail-panel-item-label {
        font-size: 14px;
      }

      .rail-panel-item-meta {
        font-size: 12px;
      }

      /* Panel buttons: bigger */
      .rail-panel-btn {
        padding: 12px 16px !important;
        font-size: 14px !important;
        min-height: 44px;
      }

      /* Wide and artifact panels: same full-width treatment */
      .rail-panel-wide,
      .rail-panel-artifact {
        width: 100% !important;
        max-width: 100% !important;
        min-width: 100% !important;
      }

      /* Artifact content needs to be scrollable */
      .artifact-content {
        flex: 1;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
      }

      /* Section titles in panels */
      .rail-panel-section-title {
        font-size: 11px;
        padding: 8px 16px 6px;
      }

      /* Settings panel specifics */
      #panel-settings .rail-panel-item {
        padding: 14px 16px !important;
      }

      /* Push the editor bottom padding up to account for bottom tab bar */
      #editor-container {
        padding-bottom: calc(100px + env(safe-area-inset-bottom, 0px)) !important;
      }

      /* Status bar: sits above the rail bottom bar */
      .status-bar {
        bottom: calc(48px + env(safe-area-inset-bottom, 0px)) !important;
        z-index: 400;
      }

      /* Notebook/AI settings dialogs: full width on mobile */
      #notebook-dialog-overlay.visible,
      #ai-settings-overlay.visible {
        align-items: flex-end;
        padding-top: 0;
      }

      #notebook-dialog-overlay .venv-picker,
      #ai-settings-overlay .venv-picker {
        width: 100% !important;
        border-radius: 16px 16px 0 0;
      }
    }

    /* ---- PANELS & SETTINGS: Keyboard-aware, full-screen on mobile ---- */
    /* The virtual keyboard on phones shrinks the visual viewport but NOT
       the layout viewport. Using `vh` units means panels hide behind the
       keyboard. We use `dvh` (dynamic viewport height) where supported,
       and a JS-based fallback via CSS custom property --mobile-vh. */
    @media (max-width: 768px) {

      /* Rail panels: use full visual viewport, top-anchored */
      .rail-panel {
        top: 0 !important;
        bottom: auto !important;
        height: 100dvh !important;
        height: calc(var(--mobile-vh, 100vh)) !important;
        max-height: 100dvh !important;
        border-radius: 0 !important;
      }

      .rail-panel.open {
        transform: translateY(0) !important;
      }

      /* Panel content: fill remaining space, scroll */
      .rail-panel-content {
        flex: 1;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        padding-bottom: calc(16px + env(safe-area-inset-bottom, 0px));
      }

      /* AI panel: bigger touch targets for commands and selectors */
      .ai-juice-selector,
      .ai-reasoning-selector {
        display: flex;
        gap: 6px;
      }

      .ai-juice-btn,
      .ai-reasoning-btn {
        min-width: 44px;
        min-height: 44px;
        font-size: 16px !important;
        border-radius: 10px;
      }

      .ai-cmd {
        min-height: 52px;
        padding: 14px 16px !important;
        font-size: 15px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .ai-cmd-key {
        min-width: 32px;
        height: 32px;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 6px;
      }

      .ai-cmd-label {
        font-size: 15px;
      }

      .ai-cmd-hint {
        font-size: 12px;
      }

      .ai-level-hint {
        display: none; /* Hide keyboard shortcut hints */
      }

      .ai-settings-btn {
        min-width: 44px;
        min-height: 44px;
      }

      .ai-panel-status {
        padding: 12px 16px;
        font-size: 14px;
      }

      .rail-panel-section-title {
        padding: 12px 16px 8px !important;
        font-size: 12px !important;
      }

      /* --- AI Settings modal: full screen on mobile --- */
      #ai-settings-overlay.visible {
        align-items: stretch !important;
        padding-top: 0 !important;
      }

      .settings-modal {
        width: 100% !important;
        max-width: 100% !important;
        max-height: 100dvh !important;
        max-height: calc(var(--mobile-vh, 100vh)) !important;
        height: 100dvh;
        height: calc(var(--mobile-vh, 100vh));
        border-radius: 0 !important;
        border: none !important;
        box-shadow: none !important;
      }

      /* Tabs: horizontal scroll row at top instead of side column */
      .settings-body {
        flex-direction: column !important;
      }

      .settings-tabs {
        width: 100% !important;
        border-right: none !important;
        border-bottom: 1px solid var(--border);
        padding: 8px 12px !important;
        display: flex;
        flex-direction: row !important;
        gap: 4px;
        overflow-x: auto;
        -webkit-overflow-scrolling: touch;
        flex-shrink: 0;
      }

      .settings-tab {
        flex-shrink: 0;
        padding: 10px 14px !important;
        font-size: 13px;
        white-space: nowrap;
        border-radius: 8px;
        min-height: 44px;
      }

      .settings-content {
        flex: 1;
        padding: 16px !important;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      .settings-header {
        padding: 12px 16px;
        min-height: 52px;
      }

      .settings-header-title {
        font-size: 16px;
      }

      .settings-header-close {
        min-width: 44px;
        min-height: 44px;
        font-size: 24px;
      }

      .settings-footer {
        padding: 12px 16px;
        padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
        gap: 12px;
      }

      .settings-btn {
        min-height: 44px;
        font-size: 15px;
        padding: 12px 20px;
        border-radius: 10px;
      }

      .settings-section-title {
        font-size: 13px !important;
      }

      .settings-section-desc {
        font-size: 13px;
        line-height: 1.5;
      }

      /* All inputs in settings: 16px to prevent iOS zoom */
      .settings-modal input,
      .settings-modal textarea,
      .settings-modal select {
        font-size: 16px !important;
        padding: 12px !important;
        border-radius: 8px;
        min-height: 44px;
      }

      /* API key rows: stack vertically */
      .api-key-row {
        flex-direction: column !important;
        gap: 8px;
      }

      .api-key-row input {
        width: 100% !important;
      }

      .api-key-remove {
        min-width: 44px;
        min-height: 44px;
        align-self: flex-end;
      }

      /* Quality level rows */
      .quality-level-row {
        flex-direction: column !important;
        gap: 8px;
      }

      .quality-level-row input {
        width: 100% !important;
      }

      /* Add buttons */
      .add-section-btn {
        min-height: 48px;
        font-size: 15px;
        padding: 12px 16px;
        border-radius: 10px;
      }

      /* --- Notebook settings dialog: same treatment --- */
      #notebook-dialog-overlay.visible {
        align-items: stretch !important;
        padding-top: 0 !important;
      }

      .notebook-dialog {
        width: 100% !important;
        max-width: 100% !important;
        max-height: 100dvh !important;
        border-radius: 0 !important;
        border: none !important;
      }
    }

    /* ---- MOBILE RAIL PANEL SCRIM ---- */
    /* JS adds .mobile-rail-scrim when a panel opens on mobile */
    @media (max-width: 768px) {
      .mobile-rail-scrim {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.45);
        z-index: 550;
        animation: fadeIn 0.2s ease;
      }
    }

    /* ---- KILL UGLY SHADOWS ON MOBILE ---- */
    /* Tech blogs like Quarto/Astro use flat design with subtle borders,
       not heavy box-shadows. On mobile especially, shadows look muddy
       and cheap. Replace with clean borders or nothing. */
    @media (max-width: 768px) {

      /* Sync warning banner — the most visible offender */
      .sync-warning-banner {
        box-shadow: none !important;
      }

      /* Side rail bottom bar */
      .side-rail {
        box-shadow: none !important;
      }

      /* Rail panels (bottom sheets keep a very subtle one) */
      .rail-panel {
        box-shadow: 0 -1px 0 var(--border) !important;
      }

      /* Nav sidebar mobile overlay */
      .nav-sidebar.mobile-open {
        box-shadow: 2px 0 8px rgba(0, 0, 0, 0.15) !important;
      }

      /* File picker */
      .file-picker {
        box-shadow: none !important;
      }

      /* Venv picker */
      .venv-picker {
        box-shadow: none !important;
      }

      /* Context menus as bottom sheets */
      .nav-context-menu {
        box-shadow: none !important;
        border-top: 1px solid var(--border) !important;
      }

      /* Any modal overlays */
      .modal-overlay > * {
        box-shadow: none !important;
      }
    }

    /* ---- DARK THEME ADJUSTMENTS FOR MOBILE ---- */
    /* On mobile OLED screens, pure black backgrounds save battery */
    @media (max-width: 768px) and (prefers-color-scheme: dark) {
      :root {
        --bg: #000000;
        --bg-secondary: #0a0a0a;
      }
    }
  </style>
</head>
<body>
  <!-- =======================================================================
       DATA LOSS PREVENTION - Sync Warning Banner
       =======================================================================
       Added after investigating unexplained data loss on 2026-01-16.
       This banner is shown when the sync server crashes to immediately
       alert the user that their changes are NOT being saved.
       ======================================================================= -->
  <div class="sync-warning-banner" id="sync-warning-banner">
    <span class="warning-icon"><svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 2l6 12H2L8 2zM8 6v4M8 12v1"/></svg></span>
    <span class="warning-message">
      <strong>SYNC OFFLINE - CHANGES NOT BEING SAVED!</strong>
      <span id="sync-warning-details"></span>
    </span>
    <div class="warning-actions">
      <button onclick="copyBackupToClipboard()">Copy Content</button>
      <button onclick="downloadBackup()">Download Backup</button>
      <button class="primary" onclick="attemptRecovery()">Try to Recover</button>
    </div>
  </div>

  <div class="app">
    <div class="titlebar">
      <!-- Home button (top-left) -->
      <button class="titlebar-home-btn" id="home-btn" title="Home (Ctrl+Shift+H)">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
          <path d="M2 8l6-5.5L14 8"/>
          <path d="M4 7v5.5a1 1 0 001 1h2v-3h2v3h2a1 1 0 001-1V7"/>
        </svg>
      </button>

      <!-- Mobile: nav hamburger (left) — hidden on desktop -->
      <button class="titlebar-btn titlebar-mobile-btn" id="mobile-nav-btn" title="Menu">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
          <line x1="2.5" y1="4" x2="13.5" y2="4"/>
          <line x1="2.5" y1="8" x2="13.5" y2="8"/>
          <line x1="2.5" y1="12" x2="13.5" y2="12"/>
        </svg>
      </button>

      <span class="titlebar-title" id="titlebar-title">mrmd</span>

      <!-- Mobile: search + AI (right) — hidden on desktop -->
      <div class="titlebar-mobile-actions">
        <button class="titlebar-btn titlebar-mobile-btn" id="mobile-search-btn" title="Find file">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
            <circle cx="7" cy="7" r="4.5"/>
            <line x1="10.2" y1="10.2" x2="13.5" y2="13.5"/>
          </svg>
        </button>
        <button class="titlebar-btn titlebar-mobile-btn" id="mobile-image-btn" title="Add image">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <rect x="1.5" y="2.5" width="13" height="11" rx="1.5"/>
            <circle cx="5" cy="6.5" r="1.5"/>
            <path d="M1.5 11l3.5-3.5 2.5 2.5 2-2 5 5"/>
          </svg>
          <input type="file" id="mobile-image-input" accept="image/*" style="display:none">
        </button>
        <button class="titlebar-btn titlebar-mobile-btn" id="mobile-ai-btn" title="AI edit">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M8 2v3M8 11v3M2 8h3M11 8h3"/>
            <path d="M4.5 4.5l2 2M9.5 9.5l2 2M11.5 4.5l-2 2M4.5 11.5l2-2"/>
          </svg>
        </button>
      </div>

      <!-- Desktop: rail toggle (right, absolute) -->
      <button class="titlebar-btn rail-toggle titlebar-desktop-btn" id="rail-toggle" title="Toggle tools (Ctrl+\)">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
          <line x1="3" y1="4" x2="13" y2="4"/>
          <line x1="3" y1="8" x2="13" y2="8"/>
          <line x1="3" y1="12" x2="13" y2="12"/>
        </svg>
      </button>
    </div>

    <div class="content">
      <!-- Project Navigation Sidebar -->
      <div id="nav-sidebar" class="nav-sidebar">
        <button class="sidebar-toggle nav-toggle" id="nav-toggle" title="Collapse">‹</button>
        <div class="nav-header">
          <span class="nav-title" id="nav-title" title="Click to open project config">No Project</span>
          <button class="nav-action" id="nav-config-btn" title="Project config (mrmd.md)"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"><line x1="2" y1="4" x2="14" y2="4"/><circle cx="5" cy="4" r="1.5" fill="currentColor" stroke="none"/><line x1="2" y1="8" x2="14" y2="8"/><circle cx="10" cy="8" r="1.5" fill="currentColor" stroke="none"/><line x1="2" y1="12" x2="14" y2="12"/><circle cx="7" cy="12" r="1.5" fill="currentColor" stroke="none"/></svg></button>
          <button class="nav-action" id="nav-new-btn" title="New file (n)">+</button>
        </div>
        <div class="nav-tree" id="nav-tree">
          <!-- Nav tree renders here -->
        </div>
      </div>
      <!-- Floating toggle when nav is collapsed -->
      <button class="sidebar-toggle-floating nav-toggle-floating" id="nav-toggle-floating" title="Expand">›</button>

      <!-- Nav Context Menu -->
      <div class="nav-context-menu" id="nav-context-menu">
        <div class="nav-context-item" data-action="new-file">New File</div>
        <div class="nav-context-item" data-action="new-folder">New Folder</div>
        <div class="nav-context-separator"></div>
        <div class="nav-context-item" data-action="rename">Rename</div>
        <div class="nav-context-item" data-action="reveal">Reveal in File Manager</div>
        <div class="nav-context-separator"></div>
        <div class="nav-context-item danger" data-action="delete">Delete</div>
      </div>

      <div id="editor-container">
        <!-- Contextual Python status trigger (replaces old "Add notebook config" button) -->
        <div id="session-hover-trigger" class="session-hover-trigger">
          <button class="session-hover-action" id="session-hover-btn" onclick="handleSessionHoverClick()" title="Python environment status">
            <span id="session-hover-icon">
              <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
                <circle cx="8" cy="8" r="7"/>
                <path d="M8 5v4M8 11v1"/>
              </svg>
            </span>
            <span id="session-hover-text">Python</span>
          </button>
        </div>
        <!-- Setup hints banner (project/venv only) -->
        <div id="setup-hints" class="setup-hints" style="display: none;">
          <div class="setup-hint" id="hint-no-project">
            <span class="hint-icon"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 4v9a1 1 0 001 1h10a1 1 0 001-1V6a1 1 0 00-1-1H8L6.5 3H3a1 1 0 00-1 1z"/></svg></span>
            <span class="hint-text">This folder isn't an mrmd project yet</span>
            <button class="hint-action" onclick="initializeProject()">Initialize Project</button>
            <button class="hint-dismiss" onclick="dismissHint('no-project')">×</button>
          </div>
          <div class="setup-hint" id="hint-no-venv">
            <span class="hint-icon"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 2v12M12 2v12M4 8h8"/></svg></span>
            <span class="hint-text">No virtual environment found</span>
            <button class="hint-action" onclick="showVenvPicker()">Select venv</button>
            <button class="hint-dismiss" onclick="dismissHint('no-venv')">×</button>
          </div>
        </div>
        <div id="editor"></div>
      </div>

      <!-- Table of Contents Sidebar -->
      <div id="toc-sidebar" class="toc-sidebar">
        <button class="sidebar-toggle toc-toggle" id="toc-toggle" title="Collapse">›</button>
        <div class="toc-header">On This Page</div>
        <div class="toc-list" id="toc-list">
          <div class="toc-empty">No headings found</div>
        </div>
      </div>
      <!-- Floating toggle when TOC is collapsed -->
      <button class="sidebar-toggle-floating toc-toggle-floating" id="toc-toggle-floating" title="Expand">‹</button>
    </div>

    <!-- Side Rail -->
    <div class="side-rail" id="side-rail">
      <!-- Tool buttons -->
      <button class="rail-btn" data-panel="runtimes" title="Runtimes"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="3" width="12" height="10" rx="1"/><path d="M5 7h2M5 9h4"/></svg></button>
      <button class="rail-btn" data-panel="variables" title="Variables"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 4h4l2 8h4M10 4l2 8"/></svg></button>
      <button class="rail-btn" data-panel="artifact" title="Artifact Preview"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="2" y="2" width="12" height="12" rx="1"/><path d="M2 5h12M5 5v9"/></svg></button>
      <button class="rail-btn" data-panel="ai" title="AI Commands"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><rect x="3" y="4" width="10" height="8" rx="2"/><circle cx="6" cy="8" r="1" fill="currentColor" stroke="none"/><circle cx="10" cy="8" r="1" fill="currentColor" stroke="none"/></svg></button>
      <button class="rail-btn" data-panel="help" title="Help"><svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="8" cy="8" r="6"/><path d="M6 6a2 2 0 112 2v1M8 11v1"/></svg></button>

      <div class="rail-spacer"></div>

      <div class="rail-divider"></div>
      <button class="rail-btn" data-panel="settings" title="Settings">
        <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
          <line x1="2" y1="4" x2="14" y2="4"/><circle cx="5" cy="4" r="1.5" fill="currentColor" stroke="none"/>
          <line x1="2" y1="8" x2="14" y2="8"/><circle cx="10" cy="8" r="1.5" fill="currentColor" stroke="none"/>
          <line x1="2" y1="12" x2="14" y2="12"/><circle cx="7" cy="12" r="1.5" fill="currentColor" stroke="none"/>
        </svg>
      </button>
    </div>

    <!-- Panel: Runtimes -->
    <div class="rail-panel" id="panel-runtimes">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Runtimes</span>
        <button class="rail-panel-refresh" id="runtimes-refresh" title="Refresh"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8a6 6 0 0111.5-2.5M14 8a6 6 0 01-11.5 2.5M2 3v3h3M14 13v-3h-3"/></svg></button>
        <button class="rail-panel-pin" data-pin-panel="runtimes" title="Pin panel"><svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5a.5.5 0 0 1-1 0V10h-4A.5.5 0 0 1 3 9.5c0-.973.64-1.725 1.17-2.189A5.9 5.9 0 0 1 5 6.708V2.277a2.8 2.8 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354z"/></svg></button><button class="rail-panel-pin" data-pin-panel="runtimes" title="Pin panel"><svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5a.5.5 0 0 1-1 0V10h-4A.5.5 0 0 1 3 9.5c0-.973.64-1.725 1.17-2.189A5.9 5.9 0 0 1 5 6.708V2.277a2.8 2.8 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354z"/></svg></button><button class="rail-panel-close" data-close-panel="runtimes">×</button>
      </div>
      <div class="rail-panel-content">
        <div id="runtimes-list" class="runtimes-list">
          <div class="runtimes-empty">No running runtimes</div>
        </div>
      </div>
    </div>

    <!-- Panel: Variables -->
    <div class="rail-panel rail-panel-wide" id="panel-variables">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Environment</span>
        <button class="rail-panel-refresh" id="variables-refresh" title="Refresh"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8a6 6 0 0111.5-2.5M14 8a6 6 0 01-11.5 2.5M2 3v3h3M14 13v-3h-3"/></svg></button>
        <button class="rail-panel-pin" data-pin-panel="variables" title="Pin panel"><svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5a.5.5 0 0 1-1 0V10h-4A.5.5 0 0 1 3 9.5c0-.973.64-1.725 1.17-2.189A5.9 5.9 0 0 1 5 6.708V2.277a2.8 2.8 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354z"/></svg></button><button class="rail-panel-close" data-close-panel="variables">×</button>
      </div>
      <div id="variables-tabs" class="var-tabs"></div>
      <div class="rail-panel-content" style="padding: 0;">
        <div id="variables-list"></div>
      </div>
    </div>

    <!-- Panel: Artifact Preview -->
    <div class="rail-panel rail-panel-artifact" id="panel-artifact">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Artifacts</span>
        <button class="rail-panel-btn" id="artifact-clear" title="Clear current"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M4 4l8 8M4 12l8-8"/></svg></button>
        <button class="rail-panel-btn" id="artifact-reload" title="Reload current"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 8a6 6 0 0111.5-2.5M14 8a6 6 0 01-11.5 2.5M2 3v3h3M14 13v-3h-3"/></svg></button>
        <button class="rail-panel-pin" data-pin-panel="artifact" title="Pin panel"><svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5a.5.5 0 0 1-1 0V10h-4A.5.5 0 0 1 3 9.5c0-.973.64-1.725 1.17-2.189A5.9 5.9 0 0 1 5 6.708V2.277a2.8 2.8 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354z"/></svg></button><button class="rail-panel-close" data-close-panel="artifact">×</button>
      </div>
      <div class="artifact-tabs" id="artifact-tabs">
        <!-- Tabs generated dynamically -->
      </div>
      <div class="artifact-content">
        <iframe id="artifact-iframe" title="Artifact Preview"></iframe>
      </div>
      <div class="artifact-status" id="artifact-status">
        <span class="artifact-status-text">Use <code>html:name</code>, <code>css:name</code>, <code>js:name</code> cells to create artifacts</span>
      </div>
    </div>

    <!-- Panel: Source -->
    <div class="rail-panel rail-panel-wide" id="panel-source">
      <div class="rail-panel-header">
        <button class="source-back-btn" id="source-back" title="Back" disabled>←</button>
        <span class="rail-panel-title" id="source-title">Source</span>
        <button class="rail-panel-pin" data-pin-panel="source" title="Pin panel"><svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5a.5.5 0 0 1-1 0V10h-4A.5.5 0 0 1 3 9.5c0-.973.64-1.725 1.17-2.189A5.9 5.9 0 0 1 5 6.708V2.277a2.8 2.8 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354z"/></svg></button><button class="rail-panel-close" data-close-panel="source">×</button>
      </div>
      <div class="source-file-path" id="source-file"></div>
      <div class="rail-panel-content source-content">
        <pre class="source-code" id="source-code"><code>Press F12 on a symbol to view its source code.</code></pre>
      </div>
    </div>

    <!-- Panel: Help -->
    <div class="rail-panel" id="panel-help">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Help</span>
        <button class="rail-panel-pin" data-pin-panel="help" title="Pin panel"><svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5a.5.5 0 0 1-1 0V10h-4A.5.5 0 0 1 3 9.5c0-.973.64-1.725 1.17-2.189A5.9 5.9 0 0 1 5 6.708V2.277a2.8 2.8 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354z"/></svg></button><button class="rail-panel-close" data-close-panel="help">×</button>
      </div>
      <div class="rail-panel-content">
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Keyboard Shortcuts</div>
          <div class="rail-panel-item">
            <span class="rail-panel-item-label">Run cell</span>
            <span class="rail-panel-item-meta">Ctrl+Enter</span>
          </div>
          <div class="rail-panel-item">
            <span class="rail-panel-item-label">Run all cells</span>
            <span class="rail-panel-item-meta">Ctrl+Shift+Enter</span>
          </div>
          <div class="rail-panel-item">
            <span class="rail-panel-item-label">Open file</span>
            <span class="rail-panel-item-meta">Ctrl+P</span>
          </div>
          <div class="rail-panel-item">
            <span class="rail-panel-item-label">Toggle rail</span>
            <span class="rail-panel-item-meta">Ctrl+\</span>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Tips</div>
          <div class="rail-panel-item">
            <div class="rail-panel-item-icon"></div>
            <span class="rail-panel-item-label">Use ```python to create code cells</span>
          </div>
          <div class="rail-panel-item">
            <div class="rail-panel-item-icon"></div>
            <span class="rail-panel-item-label">Click the play button to run code</span>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">JavaScript Imports</div>
          <div class="rail-panel-item" style="cursor: default; align-items: flex-start;">
            <div class="rail-panel-item-icon"></div>
            <span class="rail-panel-item-label" style="white-space: normal;">
              JS cells run as scripts (eval context), so use <code>await import(...)</code> instead of <code>import ... from ...</code>.
            </span>
          </div>
          <div class="rail-panel-item" style="cursor: default; align-items: flex-start;">
            <div class="rail-panel-item-icon"></div>
            <span class="rail-panel-item-label" style="white-space: normal;">
              For cross-cell reuse, assign package handles to globals (example: <code>d3 = await ...</code>).
            </span>
          </div>
          <div class="help-snippet-block">
            <div class="help-snippet-header">
              <span class="help-snippet-title">Reusable Package Loader</span>
              <button class="help-snippet-copy" onclick="copyJavaScriptImportHelper(this)">Copy</button>
            </div>
            <pre class="help-snippet-code" id="help-js-import-code"></pre>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Runtimes Configuration</div>
          <div class="rail-panel-item" style="cursor: default; align-items: flex-start;">
            <div class="rail-panel-item-icon"></div>
            <span class="rail-panel-item-label" style="white-space: normal;">
              Configure named runtime sessions in your document's YAML frontmatter using the <code>session</code> key.
            </span>
          </div>
          <div class="help-snippet-block">
            <div class="help-snippet-header">
              <span class="help-snippet-title">Example Frontmatter</span>
            </div>
            <pre class="help-snippet-code">---
session:
  python:
    name: python-env
    venv: .venv
  bash:
    name: bash-session
    cwd: /tmp
  node:
    name: node-backend
    cwd: ./backend
  julia:
    name: julia-session
    cwd: /tmp
  r:
    name: r-session
    cwd: /tmp
---</pre>
          </div>
          <div class="rail-panel-item" style="cursor: default; align-items: flex-start;">
            <div class="rail-panel-item-icon"></div>
            <span class="rail-panel-item-label" style="white-space: normal;">
              <strong>name</strong> — display name for the session<br>
              <strong>venv</strong> — Python virtual environment path (Python only)<br>
              <strong>cwd</strong> — working directory for the runtime
            </span>
          </div>
        </div>
      </div>
    </div>

    <!-- Panel: Settings -->
    <div class="rail-panel" id="panel-settings">
      <div class="rail-panel-header">
        <span class="rail-panel-title">Settings</span>
        <button class="rail-panel-pin" data-pin-panel="settings" title="Pin panel"><svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5a.5.5 0 0 1-1 0V10h-4A.5.5 0 0 1 3 9.5c0-.973.64-1.725 1.17-2.189A5.9 5.9 0 0 1 5 6.708V2.277a2.8 2.8 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354z"/></svg></button><button class="rail-panel-close" data-close-panel="settings">×</button>
      </div>
      <div class="rail-panel-content">
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Appearance</div>
          <div class="rail-panel-item" onclick="cycleTheme()">
            <span class="rail-panel-item-label">Theme</span>
            <span class="rail-panel-item-meta" id="settings-theme">github</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Panel: AI Commands -->
    <div class="rail-panel" id="panel-ai">
      <div class="rail-panel-header">
        <span class="rail-panel-title">AI Commands</span>
        <span class="ai-keyboard-hint" id="ai-keyboard-hint" style="display: none;">Press key or Esc</span>
        <button class="ai-settings-btn" id="ai-settings-btn" title="AI Settings (API Keys, Models)">
          <svg viewBox="0 0 16 16"><path d="M8 10a2 2 0 100-4 2 2 0 000 4z"/><path d="M13.3 8.9l.9.5c.2.1.3.4.2.6l-.9 1.5c-.1.2-.4.3-.6.2l-.9-.5c-.3.2-.6.4-1 .5l-.1 1c0 .3-.2.5-.5.5h-1.8c-.3 0-.5-.2-.5-.5l-.1-1c-.4-.1-.7-.3-1-.5l-.9.5c-.2.1-.5 0-.6-.2l-.9-1.5c-.1-.2 0-.5.2-.6l.9-.5c0-.3 0-.6 0-.9 0-.3 0-.6 0-.9l-.9-.5c-.2-.1-.3-.4-.2-.6l.9-1.5c.1-.2.4-.3.6-.2l.9.5c.3-.2.6-.4 1-.5l.1-1c0-.3.2-.5.5-.5h1.8c.3 0 .5.2.5.5l.1 1c.4.1.7.3 1 .5l.9-.5c.2-.1.5 0 .6.2l.9 1.5c.1.2 0 .5-.2.6l-.9.5c0 .3 0 .6 0 .9 0 .3 0 .6 0 .9z"/></svg>
        </button>
        <button class="rail-panel-pin" data-pin-panel="ai" title="Pin panel"><svg width="12" height="12" viewBox="0 0 16 16" fill="currentColor"><path d="M4.146.146A.5.5 0 0 1 4.5 0h7a.5.5 0 0 1 .5.5c0 .68-.342 1.174-.646 1.479-.126.125-.25.224-.354.298v4.431l.078.048c.203.127.476.314.751.555C12.36 7.775 13 8.527 13 9.5a.5.5 0 0 1-.5.5h-4v4.5a.5.5 0 0 1-1 0V10h-4A.5.5 0 0 1 3 9.5c0-.973.64-1.725 1.17-2.189A5.9 5.9 0 0 1 5 6.708V2.277a2.8 2.8 0 0 1-.354-.298C4.342 1.674 4 1.179 4 .5a.5.5 0 0 1 .146-.354z"/></svg></button><button class="rail-panel-close" data-close-panel="ai">×</button>
      </div>
      <div class="rail-panel-content">
        <div id="ai-panel-status" class="ai-panel-status" style="display: none;">
          <span class="ai-status-icon"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 2l6 12H2L8 2zM8 6v4M8 12v1"/></svg></span>
          <span class="ai-status-text">AI server not connected</span>
        </div>
        <div id="ai-progress" class="ai-progress" style="display: none;">
          <div class="ai-progress-header">
            <span class="ai-progress-title">Working...</span>
            <span class="ai-progress-model" id="ai-progress-model"></span>
          </div>
          <div class="ai-progress-models" id="ai-progress-models"></div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Quality <span class="ai-level-hint">Shift+1-5</span></div>
          <div class="ai-juice-selector">
            <button class="ai-juice-btn" data-juice="0" title="Quick - Fast & cheap (Shift+1)">1</button>
            <button class="ai-juice-btn selected" data-juice="1" title="Balanced - Good quality (Shift+2)">2</button>
            <button class="ai-juice-btn" data-juice="2" title="Deep - Deep reasoning (Shift+3)">3</button>
            <button class="ai-juice-btn" data-juice="3" title="Maximum - Best single model (Shift+4)">4</button>
            <button class="ai-juice-btn" data-juice="4" title="Ultimate - Multi-model (Shift+5)">5</button>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Reasoning <span class="ai-level-hint">0-5</span></div>
          <div class="ai-juice-selector">
            <button class="ai-reasoning-btn" data-reasoning="0" title="Off - No extended thinking (0)">0</button>
            <button class="ai-reasoning-btn selected" data-reasoning="1" title="Minimal - Light reasoning (1)">1</button>
            <button class="ai-reasoning-btn" data-reasoning="2" title="Low - Some reasoning (2)">2</button>
            <button class="ai-reasoning-btn" data-reasoning="3" title="Medium - Moderate reasoning (3)">3</button>
            <button class="ai-reasoning-btn" data-reasoning="4" title="High - Deep reasoning (4)">4</button>
            <button class="ai-reasoning-btn" data-reasoning="5" title="Maximum - Full reasoning budget (5)">5</button>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Text</div>
          <div class="ai-cmd" data-cmd="fix-grammar" data-key="g">
            <span class="ai-cmd-key">g</span>
            <span class="ai-cmd-label">Fix Grammar</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="fix-transcription" data-key="t">
            <span class="ai-cmd-key">t</span>
            <span class="ai-cmd-label">Fix Transcription</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="finish-sentence" data-key="s">
            <span class="ai-cmd-key">s</span>
            <span class="ai-cmd-label">Complete Sentence</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
          <div class="ai-cmd" data-cmd="finish-paragraph" data-key="p">
            <span class="ai-cmd-key">p</span>
            <span class="ai-cmd-label">Complete Paragraph</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Code</div>
          <div class="ai-cmd" data-cmd="finish-code-line" data-key="l">
            <span class="ai-cmd-key">l</span>
            <span class="ai-cmd-label">Complete Line</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
          <div class="ai-cmd" data-cmd="finish-code-section" data-key="c">
            <span class="ai-cmd-key">c</span>
            <span class="ai-cmd-label">Complete Section</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
          <div class="ai-cmd" data-cmd="document-code" data-key="d">
            <span class="ai-cmd-key">d</span>
            <span class="ai-cmd-label">Add Docstrings</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="add-types" data-key="y">
            <span class="ai-cmd-key">y</span>
            <span class="ai-cmd-label">Add Type Hints</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="improve-names" data-key="n">
            <span class="ai-cmd-key">n</span>
            <span class="ai-cmd-label">Improve Names</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
          <div class="ai-cmd" data-cmd="refactor" data-key="r">
            <span class="ai-cmd-key">r</span>
            <span class="ai-cmd-label">Refactor Code</span>
            <span class="ai-cmd-hint">selection</span>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Document</div>
          <div class="ai-cmd" data-cmd="document-continue" data-key="o">
            <span class="ai-cmd-key">o</span>
            <span class="ai-cmd-label">Continue Document</span>
            <span class="ai-cmd-hint">append</span>
          </div>
        </div>
        <div class="rail-panel-section">
          <div class="rail-panel-section-title">Comments</div>
          <div class="ai-cmd" data-cmd="address-comment" data-key="m">
            <span class="ai-cmd-key">m</span>
            <span class="ai-cmd-label">Address Nearby</span>
            <span class="ai-cmd-hint">cursor</span>
          </div>
          <div class="ai-cmd" data-cmd="address-all-comments" data-key="M">
            <span class="ai-cmd-key">M</span>
            <span class="ai-cmd-label">Address All</span>
            <span class="ai-cmd-hint">document</span>
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- Home View — full-page takeover, independent of editor chrome -->
  <div id="home-view">
    <div class="home-container">
      <div class="home-header">
        <div class="home-title" id="home-title">mrmd</div>
        <div class="home-subtitle" id="home-subtitle">Welcome back</div>
      </div>
      <div class="home-grid">
        <!-- Recent Files -->
        <div class="home-section">
          <div class="home-section-header">
            <span class="home-section-title">Recent Files</span>
          </div>
          <div class="home-section-content" id="home-recent-files">
            <div class="home-empty">No recent files</div>
          </div>
        </div>

        <!-- Running Runtimes (Global) -->
        <div class="home-section" style="grid-row: span 2;">
          <div class="home-section-header">
            <span class="home-section-title">Running Runtimes</span>
            <button class="home-section-action" onclick="refreshHomeRuntimes()">Refresh</button>
          </div>
          <div class="home-section-content" id="home-runtimes">
            <div class="home-empty">No runtimes running</div>
          </div>
          <div style="padding: 8px 16px; border-top: 1px solid var(--border);">
            <button class="home-footer-btn" id="home-stop-all" style="display: none; width: 100%;" onclick="stopAllRuntimes()">Stop All Runtimes</button>
          </div>
        </div>

        <!-- Recent Projects -->
        <div class="home-section">
          <div class="home-section-header">
            <span class="home-section-title">Recent Projects</span>
            <button class="home-section-action" onclick="openProjectPicker()">Open project...</button>
          </div>
          <div class="home-section-content" id="home-recent-projects">
            <div class="home-empty">No recent projects</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden elements for JavaScript compatibility -->
  <div style="display: none;">
    <span id="status-file"></span>
    <span id="status-theme">github</span>
  </div>

  <!-- File Picker Modal -->
  <div class="modal-overlay" id="file-picker-overlay">
    <div class="file-picker">
      <div class="picker-header">
        <span class="picker-icon"><svg viewBox="0 0 16 16"><circle cx="7" cy="7" r="4"/><path d="M10 10l3.5 3.5"/></svg></span>
        <input type="text" class="picker-input" id="file-search" placeholder="Find or create file... (use / for progressive narrowing)" autocomplete="off" spellcheck="false">
        <span class="picker-mode" id="picker-mode" style="display: none;">PATH</span>
        <span class="picker-hint">esc</span>
      </div>
      <div class="picker-context" id="picker-context" style="display: none;">
        <span>SCOPE:</span>
        <span class="picker-context-path" id="picker-context-path"></span>
        <span class="picker-context-hint">[← / ⇧Tab / Backspace up]</span>
      </div>
      <div class="picker-body">
        <div class="picker-list" id="file-list"></div>
        <div class="picker-preview">
          <div class="preview-header">
            <span>Preview</span>
            <span class="preview-file" id="preview-file"></span>
          </div>
          <div class="preview-content" id="preview-content">Select a file to preview</div>
        </div>
      </div>
      <div class="picker-footer" id="picker-footer">
        <div class="picker-hints" id="picker-hints"></div>
        <span class="picker-status" id="picker-status">Ready</span>
      </div>
    </div>
  </div>

  <!-- Venv Picker Modal -->
  <div class="modal-overlay" id="venv-picker-overlay">
    <div class="venv-picker">
      <div class="picker-header">
        <span class="picker-icon"><svg viewBox="0 0 16 16"><path d="M8 1L14.5 5v6L8 15L1.5 11V5L8 1z"/></svg></span>
        <input type="text" class="picker-input" id="venv-search" placeholder="Search environments..." autocomplete="off" spellcheck="false">
        <span class="picker-hint">esc</span>
      </div>
      <div class="picker-list" id="venv-list" style="max-height: 400px;"></div>
      <div class="picker-custom-path">
        <input type="text" id="custom-python-path" placeholder="Or enter path to Python environment..." autocomplete="off" spellcheck="false">
      </div>
      <div class="picker-footer">
        <span><kbd>↑↓</kbd> navigate</span>
        <span><kbd>⏎</kbd> select</span>
        <span><kbd>⇧⏎</kbd> new</span>
        <span><kbd>esc</kbd> close</span>
      </div>
    </div>
  </div>

  <!-- Notebook Open Dialog -->
  <div class="modal-overlay" id="notebook-dialog-overlay">
    <div class="notebook-dialog">
      <h3>Open Jupyter Notebook</h3>
      <p>Opening <span class="notebook-dialog-filename" id="notebook-dialog-filename"></span></p>
      <div class="notebook-options">
        <button class="notebook-option" id="notebook-sync-btn">
          <strong>Keep as Notebook</strong>
          <span>Edit in MRMD while keeping the .ipynb synced with Jupyter</span>
        </button>
        <button class="notebook-option convert" id="notebook-convert-btn">
          <strong>Convert to Markdown</strong>
          <span>Replace the .ipynb file with a .md file (cannot be undone)</span>
        </button>
      </div>
      <button class="notebook-dialog-cancel" id="notebook-cancel-btn">Cancel</button>
    </div>
  </div>

  <!-- AI Settings Modal -->
  <div class="modal-overlay" id="ai-settings-overlay">
    <div class="settings-modal">
      <div class="settings-header">
        <span class="settings-header-icon">
          <svg viewBox="0 0 16 16"><path d="M8 10a2 2 0 100-4 2 2 0 000 4z"/><path d="M13.3 8.9l.9.5c.2.1.3.4.2.6l-.9 1.5c-.1.2-.4.3-.6.2l-.9-.5c-.3.2-.6.4-1 .5l-.1 1c0 .3-.2.5-.5.5h-1.8c-.3 0-.5-.2-.5-.5l-.1-1c-.4-.1-.7-.3-1-.5l-.9.5c-.2.1-.5 0-.6-.2l-.9-1.5c-.1-.2 0-.5.2-.6l.9-.5c0-.3 0-.6 0-.9 0-.3 0-.6 0-.9l-.9-.5c-.2-.1-.3-.4-.2-.6l.9-1.5c.1-.2.4-.3.6-.2l.9.5c.3-.2.6-.4 1-.5l.1-1c0-.3.2-.5.5-.5h1.8c.3 0 .5.2.5.5l.1 1c.4.1.7.3 1 .5l.9-.5c.2-.1.5 0 .6.2l.9 1.5c.1.2 0 .5-.2.6l-.9.5c0 .3 0 .6 0 .9 0 .3 0 .6 0 .9z"/></svg>
        </span>
        <span class="settings-header-title">AI Settings</span>
        <button class="settings-header-close" id="ai-settings-close">&times;</button>
      </div>
      <div class="settings-body">
        <div class="settings-tabs">
          <div class="settings-tab active" data-tab="api-keys">
            <span class="settings-tab-icon">
              <svg viewBox="0 0 16 16"><path d="M10.5 1a4.5 4.5 0 00-4.38 5.58L2 10.7V14h3.3l.12-.12a.75.75 0 001.01-1.01l.12-.12h.7l.12-.12a.75.75 0 001.01-1.01L8.5 11.5v-.75l3.92-3.92A4.5 4.5 0 0010.5 1zm1 3a1 1 0 11-2 0 1 1 0 012 0z"/></svg>
            </span>
            <span>API Keys</span>
          </div>
          <div class="settings-tab" data-tab="quality-levels">
            <span class="settings-tab-icon">
              <svg viewBox="0 0 16 16"><path d="M8 2l1.5 3 3.5.5-2.5 2.5.5 3.5L8 10l-3 1.5.5-3.5L3 5.5l3.5-.5L8 2z"/></svg>
            </span>
            <span>Quality Levels</span>
          </div>
          <div class="settings-tab" data-tab="custom-commands">
            <span class="settings-tab-icon">
              <svg viewBox="0 0 16 16"><path d="M4 4h8M4 8h8M4 12h5"/><path d="M12 10l2 2-2 2"/></svg>
            </span>
            <span>Custom Commands</span>
          </div>
        </div>
        <div class="settings-content">
          <!-- API Keys Tab -->
          <div class="settings-tab-content" id="tab-api-keys">
            <div class="settings-section">
              <div class="settings-section-title">API Keys</div>
              <div class="settings-section-desc">
                Enter API keys for your LLM providers. Uses <a href="https://docs.litellm.ai/docs/providers" target="_blank" style="color: var(--accent);">LiteLLM</a> format.
                Keys are stored locally and sent with each AI request.
              </div>
              <div id="api-keys-list">
                <!-- Dynamically populated -->
              </div>
              <button class="add-section-btn" id="add-api-key-btn" style="margin-top: 12px;">
                <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 3v10M3 8h10"/></svg>
                Add Provider
              </button>
              <div class="settings-section" style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
                <div class="settings-section-title">Common Providers</div>
                <div style="font-size: 11px; color: var(--text-dim); line-height: 1.6; font-family: 'SF Mono', Monaco, monospace;">
                  anthropic, openai, groq, gemini, openrouter, together_ai, fireworks_ai, azure, bedrock, vertex_ai, cohere, mistral, deepseek, ollama
                </div>
              </div>
            </div>
          </div>

          <!-- Quality Levels Tab -->
          <div class="settings-tab-content" id="tab-quality-levels" style="display: none;">
            <div class="settings-section">
              <div class="settings-section-title">Quality Level Models</div>
              <div class="settings-section-desc">
                Enter model names in <a href="https://docs.litellm.ai/docs/providers" target="_blank" style="color: var(--accent);">LiteLLM format</a>: <code style="background: var(--bg-tertiary); padding: 2px 6px; border-radius: 3px;">provider/model-name</code>
              </div>
              <div id="quality-levels-list">
                <!-- Dynamically populated -->
              </div>
              <div class="settings-section" style="margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
                <div class="settings-section-title">Model Format Examples</div>
                <div style="font-size: 11px; color: var(--text-dim); line-height: 1.8; font-family: 'SF Mono', Monaco, monospace;">
                  anthropic/claude-sonnet-4-5<br>
                  openai/gpt-4o<br>
                  groq/llama-3.3-70b-versatile<br>
                  gemini/gemini-2.0-flash<br>
                  openrouter/anthropic/claude-3.5-sonnet<br>
                  together_ai/meta-llama/Llama-3-70b<br>
                  ollama/llama3.2
                </div>
              </div>
            </div>
          </div>

          <!-- Custom Commands Tab -->
          <div class="settings-tab-content" id="tab-custom-commands" style="display: none;">
            <div class="settings-section">
              <div class="settings-section-title">Custom AI Commands</div>
              <div class="settings-section-desc">
                Create your own AI commands organized into sections. Commands will appear in the AI panel.
              </div>
              <div id="custom-sections-list">
                <!-- Dynamically populated -->
              </div>
              <button class="add-section-btn" id="add-section-btn">
                <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 3v10M3 8h10"/></svg>
                Add Section
              </button>
            </div>
          </div>
        </div>
      </div>
      <div class="settings-footer">
        <button class="settings-btn settings-btn-secondary" id="ai-settings-reset">Reset to Defaults</button>
        <button class="settings-btn settings-btn-primary" id="ai-settings-done">Done</button>
      </div>
    </div>
  </div>

  <!-- Custom Command Form (sub-modal) -->
  <div class="command-form-overlay" id="command-form-overlay" style="display: none;">
    <div class="command-form">
      <div class="command-form-header">
        <span class="command-form-title" id="command-form-title">New Command</span>
        <button class="command-form-close" id="command-form-close">&times;</button>
      </div>
      <div class="command-form-body">
        <div class="command-form-field">
          <label class="command-form-label">Command Name</label>
          <input type="text" class="command-form-input" id="command-name" placeholder="e.g., Simplify Text">
        </div>

        <div class="command-form-row">
          <div class="command-form-field">
            <label class="command-form-label">Input</label>
            <select class="command-form-select" id="command-input-type">
              <option value="selection">Selected text</option>
              <option value="cursor">Text before cursor</option>
              <option value="fullDoc">Full document</option>
            </select>
            <div class="command-form-hint">What text to send to the AI</div>
          </div>
          <div class="command-form-field">
            <label class="command-form-label">Output</label>
            <select class="command-form-select" id="command-output-type">
              <option value="replace">Replace input</option>
              <option value="insert">Insert at cursor</option>
            </select>
            <div class="command-form-hint">What to do with the result</div>
          </div>
        </div>

        <div class="command-form-field">
          <label class="command-form-label">Instructions</label>
          <textarea class="command-form-textarea" id="command-instructions"
                    placeholder="Tell the AI what to do with the text...&#10;&#10;Example: Rewrite this text to be simpler and easier to read. Use shorter sentences. Keep the same meaning."></textarea>
          <div class="command-form-hint">This becomes the AI's prompt. Be specific about what you want.</div>
        </div>

        <div class="command-form-field">
          <label class="command-form-label">Keyboard Shortcut (optional)</label>
          <input type="text" class="command-form-input" id="command-key" placeholder="e.g., x" maxlength="1" style="width: 60px;">
          <div class="command-form-hint">Single letter to trigger this command when AI panel is focused</div>
        </div>
      </div>
      <div class="command-form-footer">
        <button class="settings-btn settings-btn-secondary" id="command-form-cancel">Cancel</button>
        <button class="settings-btn settings-btn-primary" id="command-form-save">Save Command</button>
      </div>
    </div>
  </div>

  <!-- Load mrmd-editor -->
  <script src="../mrmd-editor/dist/mrmd.iife.js"></script>

  <!-- Load xterm.js for terminal blocks -->
  <link rel="stylesheet" href="./node_modules/xterm/css/xterm.css">
  <script src="./node_modules/xterm/lib/xterm.js"></script>
  <script src="./node_modules/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
  <script src="./node_modules/xterm-addon-web-links/lib/xterm-addon-web-links.js"></script>

  <script>
    // =========================================================================
    // STATE
    // =========================================================================

    const state = {
      files: [],
      scannedDirs: [],
      filteredFiles: [],
      recentFiles: [],
      selectedFileIndex: 0,
      previewRequestId: 0,
      venvs: [],
      filteredVenvs: [],
      filteredRuntimes: [],
      selectedVenvIndex: 0,
      venvQuery: '',
      runningRuntimes: [],
      pythonPort: null,
      pythonVenv: null,
      bashPort: null,
      bashSession: null,
      ptySession: null,  // PTY session for terminal blocks
      aiPort: null,
      jsRuntime: null,
      currentFile: null,
      projectDir: null,
      editor: null,
      variablesCellCompleteUnsub: null,
      variablesCellErrorUnsub: null,
      drive: null,
      homeDir: null,  // Will be set on init
      // New: Project state
      project: null,  // ProjectInfo from service
      // Enhanced file picker state
      pickerMode: 'fuzzy',  // 'fuzzy' | 'path' | 'create-file' | 'create-project'
      defaultScopeRoot: null, // initial scope root for picker session
      folderContext: null,  // Current folder being browsed (absolute path)
      createTarget: null,   // Path to create (file or project)
      // Session state (new)
      session: {
        name: null,           // e.g., "thesis:default"
        status: 'none',       // 'none' | 'starting' | 'connected' | 'error'
        config: null,         // Resolved session config from Project.resolveSession
        info: null,           // SessionInfo from SessionService (pid, port, etc.)
      },
      // Multi-session state: tracks ALL runtimes independently
      // sessionName → { language, status, config, info }
      sessions: new Map(),
      // Notebook sync state: maps shadow .md path to original .ipynb path
      syncedNotebooks: new Map(),
      // File picker performance state
      fileIndex: {
        allFiles: [],
        folders: [],
        recentByPath: new Map(),
        ready: false,
      },
      fileScanStatus: 'idle', // 'idle' | 'scanning' | 'ready'
      fileScanToken: null,
      fileScanRoot: null,
      filesUpdateTimer: null,
      filterDebounceTimer: null,
      previewDebounceTimer: null,
      previewCache: new Map(),
      lastFilterMs: 0,
      lastPickerNavTs: 0,
      filterWorker: null,
      filterWorkerReady: false,
      filterRequestId: 0,
      pendingFilterRequests: new Map(),
      pickerSelectable: [],
      pickerRows: [],
      pickerRowBySelectable: new Map(),
      pickerRowOffsets: [],
      pickerRowHeights: [],
      pickerTotalHeight: 0,
      pickerVirtualInit: false,
      pickerShowAllFolders: false,
    };

    // DEBUG: Expose state to window for console debugging
    window._state = state;

    // =========================================================================
    // DOCUMENT EXTENSIONS
    // =========================================================================

    const DOC_EXTENSIONS = ['.md', '.qmd'];

    function getDocExtension(filePath) {
      if (!filePath) return '';
      const lower = filePath.toLowerCase();
      for (const ext of DOC_EXTENSIONS) {
        if (lower.endsWith(ext)) return ext;
      }
      return '';
    }

    function isDocFile(filePath) {
      return !!getDocExtension(filePath);
    }

    function stripDocExtension(filePath) {
      const ext = getDocExtension(filePath);
      return ext ? filePath.slice(0, -ext.length) : filePath.replace(/\.[^.]+$/, '');
    }

    function ensureDocExtension(filePath, preferredExt = '.md') {
      return isDocFile(filePath) ? filePath : filePath + preferredExt;
    }

    // =========================================================================
    // FSML HELPERS (for wiki-link completion)
    // =========================================================================

    /**
     * Parse a file path for wiki-link completion.
     * Simplified version of FSML.parsePath from mrmd-project.
     *
     * @param {string} path - Relative path (e.g., '02-getting-started/01-setup.md')
     * @returns {{path: string, title: string, name: string}}
     */
    function parseProjectFile(path) {
      if (!path) return { path: '', title: '', name: '' };

      // Get filename without directory
      const segments = path.split('/');
      const filename = segments[segments.length - 1];

      // Remove extension
      let name = filename.replace(/\.[^.]+$/, '');

      // Remove numeric prefix (e.g., "01-" or "02_")
      name = name.replace(/^\d+[-_]/, '');

      // Derive title: replace - and _ with spaces, title case
      const title = name
        .replace(/[-_]/g, ' ')
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');

      return { path, title, name };
    }

    /**
     * Parse all project files for wiki-link completion.
     *
     * @param {string[]} files - Array of relative paths
     * @returns {Array<{path: string, title: string, name: string}>}
     */
    function parseProjectFiles(files) {
      if (!files) return [];
      return files
        .filter(f => isDocFile(f) && f !== 'mrmd.md')
        .map(parseProjectFile);
    }

    // =========================================================================
    // FILE PICKER QUERY INTENT
    // =========================================================================

    /**
     * Detect create intent from query without introducing explicit UI modes.
     * Returns: { mode: 'fuzzy', mayCreate: boolean, isFile: boolean, basePath: string|null }
     */
    function detectPickerMode(query) {
      const q = (query || '').trim();
      if (!q) return { mode: 'fuzzy', mayCreate: false, isFile: false, basePath: null };

      const endsWithDoc = isDocFile(q);
      const endsWithIpynb = q.toLowerCase().endsWith('.ipynb');
      const endsWithSlash = q.endsWith('/');
      const hasExtension = /\.[^/]+$/.test(q);
      const looksLikeFilename = /^[\w.-]+\/?[\w.-]*\.(md|qmd|ipynb)$/i.test(q);
      const looksLikeFolderName = /^[\w./~-]+$/.test(q) && !hasExtension;

      let basePath = null;
      if (q.startsWith('~/')) {
        basePath = q.replace('~', state.homeDir || '/home');
      } else if (q.startsWith('/')) {
        basePath = q;
      } else if (q.startsWith('./') || q.startsWith('../')) {
        const baseDir = getActiveScopePath()
          || state.project?.root
          || (state.currentFile ? state.currentFile.replace(/\/[^/]+$/, '') : null);
        if (baseDir) basePath = resolvePath(q, baseDir);
      }

      const isFile = endsWithDoc || endsWithIpynb || looksLikeFilename;
      const mayCreate = isFile || endsWithSlash || looksLikeFolderName;
      return { mode: 'fuzzy', mayCreate, isFile, basePath };
    }

    /**
     * Resolve relative path to absolute
     */
    function resolvePath(relativePath, basePath) {
      if (relativePath.startsWith('/')) return relativePath;
      if (relativePath.startsWith('~/')) {
        return relativePath.replace('~', state.homeDir || '/home');
      }

      const parts = basePath.split('/').filter(p => p);
      const relParts = relativePath.split('/').filter(p => p);

      for (const part of relParts) {
        if (part === '.') continue;
        if (part === '..') {
          parts.pop();
        } else {
          parts.push(part);
        }
      }

      return '/' + parts.join('/');
    }

    // =========================================================================
    // FUZZY MATCHING (fzf-style with path support)
    // =========================================================================

    function fuzzyMatch(pattern, str) {
      if (!pattern) return { score: 0, matches: [] };

      const pLower = pattern.toLowerCase();
      const sLower = str.toLowerCase();
      let pi = 0;
      let score = 0;
      const matches = [];
      let prevMatch = -1;
      let consecutive = 0;

      for (let si = 0; si < str.length && pi < pattern.length; si++) {
        if (sLower[si] === pLower[pi]) {
          matches.push(si);

          // Scoring
          if (prevMatch === si - 1) {
            consecutive++;
            score += 2 + consecutive;
          } else {
            consecutive = 0;
            score += 1;
          }

          // Bonus for word boundaries
          if (si === 0 || '/._-'.includes(str[si - 1])) {
            score += 5;
          }

          // Bonus for uppercase after lowercase (camelCase)
          if (si > 0 && str[si] === str[si].toUpperCase() && str[si - 1] === str[si - 1].toLowerCase()) {
            score += 3;
          }

          prevMatch = si;
          pi++;
        }
      }

      if (pi !== pattern.length) return { score: 0, matches: [] };
      return { score, matches };
    }

    // Match against full path, return separate matches for name and dir
    function fuzzyMatchPath(pattern, fullPath) {
      // Create display path (~/Projects/foo/file.md)
      const displayPath = fullPath.replace(/^\/home\/[^/]+/, '~');
      const lastSlash = displayPath.lastIndexOf('/');
      const dir = lastSlash >= 0 ? displayPath.slice(0, lastSlash) : '';
      const name = lastSlash >= 0 ? displayPath.slice(lastSlash + 1) : displayPath;

      const normalizedPattern = (pattern || '').trim();
      if (!normalizedPattern) return { score: 0, nameMatches: [], dirMatches: [], displayPath, dir, name };

      if (normalizedPattern.includes('/')) {
        const querySegments = normalizedPattern.split('/').map(s => s.trim()).filter(Boolean);
        const pathSegments = displayPath.split('/').filter(Boolean);
        if (!querySegments.length || !pathSegments.length) {
          return { score: 0, nameMatches: [], dirMatches: [], displayPath, dir, name };
        }

        let cursor = 0;
        let totalScore = 0;
        let lastSegmentMatches = [];
        let lastMatchedPathSegment = -1;

        for (const querySegment of querySegments) {
          let bestScore = 0;
          let bestIndex = -1;
          let bestMatches = [];

          for (let i = cursor; i < pathSegments.length; i++) {
            const segmentMatch = fuzzyMatch(querySegment, pathSegments[i]);
            if (segmentMatch.score <= 0) continue;
            const continuityBonus = i === cursor ? 3 : 0;
            const depthPenalty = (i - cursor) * 0.4;
            const candidateScore = segmentMatch.score + continuityBonus - depthPenalty;
            if (candidateScore > bestScore) {
              bestScore = candidateScore;
              bestIndex = i;
              bestMatches = segmentMatch.matches;
            }
          }

          if (bestIndex === -1) {
            return { score: 0, nameMatches: [], dirMatches: [], displayPath, dir, name };
          }

          totalScore += bestScore;
          cursor = bestIndex + 1;
          lastSegmentMatches = bestMatches;
          lastMatchedPathSegment = bestIndex;
        }

        return {
          score: totalScore + (lastMatchedPathSegment === pathSegments.length - 1 ? 8 : 3),
          nameMatches: lastMatchedPathSegment === pathSegments.length - 1 ? lastSegmentMatches : [],
          dirMatches: [],
          displayPath,
          dir,
          name,
        };
      }

      // Try matching filename first (higher priority)
      const nameResult = fuzzyMatch(normalizedPattern, name);
      if (nameResult.score > 0) {
        return {
          score: nameResult.score * 2,  // Filename matches worth more
          nameMatches: nameResult.matches,
          dirMatches: [],
          displayPath,
          dir,
          name,
        };
      }

      // Try matching full path
      const pathResult = fuzzyMatch(normalizedPattern, displayPath);
      if (pathResult.score > 0) {
        // Split matches into dir and name portions
        const nameMatches = [];
        const dirMatches = [];
        for (const idx of pathResult.matches) {
          if (idx <= lastSlash) {
            dirMatches.push(idx);
          } else {
            nameMatches.push(idx - lastSlash - 1);
          }
        }
        return {
          score: pathResult.score,
          nameMatches,
          dirMatches,
          displayPath,
          dir,
          name,
        };
      }

      return { score: 0, nameMatches: [], dirMatches: [], displayPath, dir, name };
    }

    function highlightMatches(str, matches) {
      if (!matches || !matches.length) return escapeHtml(str);

      let result = '';
      let lastIndex = 0;
      const sortedMatches = [...matches].sort((a, b) => a - b);

      for (const idx of sortedMatches) {
        if (idx >= str.length) continue;
        result += escapeHtml(str.slice(lastIndex, idx));
        result += `<span class="match">${escapeHtml(str[idx])}</span>`;
        lastIndex = idx + 1;
      }

      result += escapeHtml(str.slice(lastIndex));
      return result;
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // =========================================================================
    // FILE PICKER
    // =========================================================================

    const FILTER_DEBOUNCE_MS = 45;
    const PREVIEW_DEBOUNCE_MS = 180;
    const FILE_INDEX_REFRESH_DEBOUNCE_MS = 120;
    const FILE_INDEX_REFRESH_NAV_GRACE_MS = 260;
    const PREVIEW_CACHE_LIMIT = 200;
    const MAX_FILTER_RESULTS = 2000;
    const FOLDER_RESULT_RESERVE = 20;
    const DIRECT_CHILD_QUERY_BOOST_MAX_LEN = 4;
    const VIRTUAL_ITEM_ROW_HEIGHT = 42;
    const VIRTUAL_HEADER_ROW_HEIGHT = 24;
    const VIRTUAL_EMPTY_ROW_HEIGHT = 72;
    const VIRTUAL_OVERSCAN_ROWS = 8;
    const FOLDER_SECTION_COLLAPSED_LIMIT = 4;
    const RECENT_MAX_RECENCY_BOOST = 260;
    const RECENT_RECENCY_HALF_LIFE_HOURS = 42;
    const RECENT_FREQUENCY_WEIGHT = 85;
    const RECENT_MAX_FREQUENCY_BOOST = 240;

    function normalizeRecentEntry(entry) {
      if (!entry) return null;

      if (typeof entry === 'string') {
        return { path: entry, opened: null, count: 1 };
      }

      if (typeof entry !== 'object' || typeof entry.path !== 'string') {
        return null;
      }

      const normalized = {
        path: entry.path,
        opened: typeof entry.opened === 'string'
          ? entry.opened
          : (typeof entry.used === 'string' ? entry.used : null),
        count: 1,
      };

      const parsedCount = Number(entry.count ?? entry.frequency ?? entry.opens ?? 1);
      if (Number.isFinite(parsedCount) && parsedCount > 0) {
        normalized.count = parsedCount;
      }

      return normalized;
    }

    function computeRecentBias(entry, nowMs = Date.now()) {
      if (!entry) return 0;

      const openedMs = Date.parse(entry.opened || '');
      let recencyBoost = 0;
      if (Number.isFinite(openedMs) && openedMs > 0) {
        const ageHours = Math.max(0, (nowMs - openedMs) / 3600000);
        recencyBoost = RECENT_MAX_RECENCY_BOOST * Math.exp(-ageHours / RECENT_RECENCY_HALF_LIFE_HOURS);
      }

      const count = Math.max(1, Number(entry.count) || 1);
      const frequencyBoost = Math.min(
        RECENT_MAX_FREQUENCY_BOOST,
        Math.log2(count + 1) * RECENT_FREQUENCY_WEIGHT
      );

      return recencyBoost + frequencyBoost;
    }

    function isRecentEntry(entry) {
      return !!entry;
    }

    function isFilePickerVisible() {
      return document.getElementById('file-picker-overlay').classList.contains('visible');
    }

    function getActiveScopePath() {
      return typeof state.folderContext === 'string' && state.folderContext.length > 0
        ? state.folderContext
        : null;
    }

    function isInScopePath(filePath, scopePath) {
      if (!scopePath) return true;
      if (scopePath === '/') return filePath.startsWith('/');
      if (filePath === scopePath) return true;
      return filePath.startsWith(scopePath + '/');
    }

    function toScopeRelativePath(filePath, scopePath) {
      if (!scopePath || !isInScopePath(filePath, scopePath)) return filePath;
      if (scopePath === '/') return filePath.replace(/^\/+/, '');
      if (filePath === scopePath) return '';
      return filePath.slice(scopePath.length + 1);
    }

    function sortPickerResults(a, b) {
      if (a.isFolder && !b.isFolder) return -1;
      if (!a.isFolder && b.isFolder) return 1;
      if (a.isRecent && !b.isRecent) return -1;
      if (!a.isRecent && b.isRecent) return 1;

      const aRecentBias = Number(a.recentBias || 0);
      const bRecentBias = Number(b.recentBias || 0);
      if (aRecentBias !== bRecentBias) return bRecentBias - aRecentBias;

      const aOpened = a.opened ? new Date(a.opened).getTime() : 0;
      const bOpened = b.opened ? new Date(b.opened).getTime() : 0;
      if (aOpened !== bOpened) return bOpened - aOpened;

      if (a.score !== b.score) return b.score - a.score;

      const aDepth = a.path ? a.path.split('/').filter(Boolean).length : 0;
      const bDepth = b.path ? b.path.split('/').filter(Boolean).length : 0;
      if (aDepth !== bDepth) return aDepth - bDepth;

      return (a.path || '').localeCompare(b.path || '');
    }

    function getPickerParentPath(absPath) {
      if (!absPath) return null;
      if (absPath === '/') return null;
      const normalized = absPath.replace(/\/+$/, '') || '/';
      if (normalized === '/') return null;
      const parent = normalized.split('/').slice(0, -1).join('/');
      return parent || '/';
    }

    function getDirectChildNameInScope(absPath, scopePath) {
      if (!scopePath || !isInScopePath(absPath, scopePath)) return null;
      const rel = toScopeRelativePath(absPath, scopePath);
      if (!rel) return null;
      const parts = rel.split('/').filter(Boolean);
      return parts.length ? parts[0] : null;
    }

    function applyFolderReserve(rows, { limit = MAX_FILTER_RESULTS, hasQuery = false } = {}) {
      const sliced = rows.slice(0, limit);
      if (!hasQuery || rows.length <= limit) return sliced;

      const mustKeep = rows.filter(r => r.isFolder).slice(0, FOLDER_RESULT_RESERVE);
      if (!mustKeep.length) return sliced;

      const selected = [...sliced];
      const selectedPathSet = new Set(selected.map(r => r.path));
      const missing = mustKeep.filter(r => !selectedPathSet.has(r.path));
      if (!missing.length) return selected;

      for (const folderRow of missing) {
        let replaceIdx = -1;
        for (let i = selected.length - 1; i >= 0; i--) {
          if (!selected[i].isFolder) {
            replaceIdx = i;
            break;
          }
        }
        if (replaceIdx === -1) break;
        selected[replaceIdx] = folderRow;
      }

      selected.sort(sortPickerResults);
      return selected;
    }

    function scheduleFileIndexRefresh({ immediate = false } = {}) {
      clearTimeout(state.filesUpdateTimer);
      const navRecently = (performance.now() - state.lastPickerNavTs) < FILE_INDEX_REFRESH_NAV_GRACE_MS;
      const delay = immediate ? 0 : (navRecently ? FILE_INDEX_REFRESH_NAV_GRACE_MS : FILE_INDEX_REFRESH_DEBOUNCE_MS);

      state.filesUpdateTimer = setTimeout(() => {
        rebuildFileIndex();
        if (!isFilePickerVisible()) return;
        const query = document.getElementById('file-search').value;
        scheduleFilter(query, {
          preserveSelection: true,
          immediate: immediate || navRecently,
        });
      }, delay);
    }

    function recentEntryPath(entry) {
      if (!entry) return null;
      if (typeof entry === 'string') return entry;
      if (typeof entry.path === 'string') return entry.path;
      return null;
    }

    function rebuildFileIndex() {
      const seen = new Set();
      const allFiles = [];
      const folders = new Set();
      const recentByPath = new Map();

      const recentList = Array.isArray(state.recentFiles) ? state.recentFiles : [];
      const nowMs = Date.now();
      for (let i = 0; i < recentList.length; i++) {
        const entry = recentList[i];
        const normalizedRecent = normalizeRecentEntry(entry);
        const filePath = normalizedRecent?.path || null;
        if (!filePath) continue;

        if (!normalizedRecent.opened) {
          normalizedRecent.opened = new Date(nowMs - i).toISOString();
        }

        recentByPath.set(filePath, normalizedRecent);
        if (!seen.has(filePath)) {
          seen.add(filePath);
          allFiles.push(filePath);
        }
      }

      for (const filePath of state.files || []) {
        if (!filePath || seen.has(filePath)) continue;
        seen.add(filePath);
        allFiles.push(filePath);
      }

      for (const filePath of allFiles) {
        const isAbsolute = filePath.startsWith('/');
        const parts = filePath.split('/').filter(Boolean);
        let current = isAbsolute ? '/' : '';
        for (let i = 0; i < parts.length - 1; i++) {
          const part = parts[i];
          if (current === '/') current = '/' + part;
          else current = current ? current + '/' + part : part;
          folders.add(current);
        }
      }

      for (const dirPath of state.scannedDirs || []) {
        if (!dirPath) continue;
        folders.add(dirPath);
      }

      state.fileIndex.allFiles = allFiles;
      state.fileIndex.folders = Array.from(folders);
      state.fileIndex.recentByPath = recentByPath;
      state.fileIndex.ready = true;
      syncFilterWorkerIndex();
    }

    function serializeRecentMap() {
      const serialized = {};
      for (const [filePath, entry] of state.fileIndex.recentByPath.entries()) {
        const normalized = normalizeRecentEntry(entry);
        serialized[filePath] = normalized
          ? { opened: normalized.opened || null, count: normalized.count || 1 }
          : null;
      }
      return serialized;
    }

    function createFileFilterWorkerSource() {
      return `
        const workerState = {
          allFiles: [],
          folders: [],
          recentByPath: {},
          maxResults: 2000,
          folderReserve: 20,
          directChildBoostMaxLen: 4,
          recentMaxRecencyBoost: 260,
          recentRecencyHalfLifeHours: 42,
          recentFrequencyWeight: 85,
          recentMaxFrequencyBoost: 240,
        };

        function fuzzyMatch(pattern, str) {
          if (!pattern) return { score: 0, matches: [] };
          const pLower = pattern.toLowerCase();
          const sLower = str.toLowerCase();
          let pi = 0;
          let score = 0;
          const matches = [];
          let prevMatch = -1;
          let consecutive = 0;
          for (let si = 0; si < str.length && pi < pattern.length; si++) {
            if (sLower[si] === pLower[pi]) {
              matches.push(si);
              if (prevMatch === si - 1) {
                consecutive++;
                score += 2 + consecutive;
              } else {
                consecutive = 0;
                score += 1;
              }
              if (si === 0 || '/._-'.includes(str[si - 1])) score += 5;
              if (si > 0 && str[si] === str[si].toUpperCase() && str[si - 1] === str[si - 1].toLowerCase()) {
                score += 3;
              }
              prevMatch = si;
              pi++;
            }
          }
          if (pi !== pattern.length) return { score: 0, matches: [] };
          return { score, matches };
        }

        function fuzzyMatchPath(pattern, fullPath) {
          const displayPath = fullPath.replace(/^\\\\/home\\\\/[^/]+/, '~');
          const lastSlash = displayPath.lastIndexOf('/');
          const dir = lastSlash >= 0 ? displayPath.slice(0, lastSlash) : '';
          const name = lastSlash >= 0 ? displayPath.slice(lastSlash + 1) : displayPath;
          const normalizedPattern = (pattern || '').trim();
          if (!normalizedPattern) return { score: 0, nameMatches: [], dirMatches: [], dir, name };
          if (normalizedPattern.includes('/')) {
            const querySegments = normalizedPattern.split('/').map(s => s.trim()).filter(Boolean);
            const pathSegments = displayPath.split('/').filter(Boolean);
            if (!querySegments.length || !pathSegments.length) {
              return { score: 0, nameMatches: [], dirMatches: [], dir, name };
            }

            let cursor = 0;
            let totalScore = 0;
            let lastSegmentMatches = [];
            let lastMatchedPathSegment = -1;

            for (const querySegment of querySegments) {
              let bestScore = 0;
              let bestIndex = -1;
              let bestMatches = [];
              for (let i = cursor; i < pathSegments.length; i++) {
                const segmentMatch = fuzzyMatch(querySegment, pathSegments[i]);
                if (segmentMatch.score <= 0) continue;
                const continuityBonus = i === cursor ? 3 : 0;
                const depthPenalty = (i - cursor) * 0.4;
                const candidateScore = segmentMatch.score + continuityBonus - depthPenalty;
                if (candidateScore > bestScore) {
                  bestScore = candidateScore;
                  bestIndex = i;
                  bestMatches = segmentMatch.matches;
                }
              }
              if (bestIndex === -1) {
                return { score: 0, nameMatches: [], dirMatches: [], dir, name };
              }
              totalScore += bestScore;
              cursor = bestIndex + 1;
              lastSegmentMatches = bestMatches;
              lastMatchedPathSegment = bestIndex;
            }

            return {
              score: totalScore + (lastMatchedPathSegment === pathSegments.length - 1 ? 8 : 3),
              nameMatches: lastMatchedPathSegment === pathSegments.length - 1 ? lastSegmentMatches : [],
              dirMatches: [],
              dir,
              name,
            };
          }

          const nameResult = fuzzyMatch(normalizedPattern, name);
          if (nameResult.score > 0) {
            return {
              score: nameResult.score * 2,
              nameMatches: nameResult.matches,
              dirMatches: [],
              dir,
              name,
            };
          }
          const pathResult = fuzzyMatch(normalizedPattern, displayPath);
          if (pathResult.score <= 0) {
            return { score: 0, nameMatches: [], dirMatches: [], dir, name };
          }
          const nameMatches = [];
          const dirMatches = [];
          for (const idx of pathResult.matches) {
            if (idx <= lastSlash) dirMatches.push(idx);
            else nameMatches.push(idx - lastSlash - 1);
          }
          return { score: pathResult.score, nameMatches, dirMatches, dir, name };
        }

        function isInScopePath(filePath, scopePath) {
          if (!scopePath) return true;
          if (scopePath === '/') return filePath.startsWith('/');
          if (filePath === scopePath) return true;
          return filePath.startsWith(scopePath + '/');
        }

        function toScopeRelativePath(filePath, scopePath) {
          if (!scopePath || !isInScopePath(filePath, scopePath)) return filePath;
          if (scopePath === '/') return filePath.replace(/^\\/+/, '');
          if (filePath === scopePath) return '';
          return filePath.slice(scopePath.length + 1);
        }

        function normalizeRecentEntry(entry, filePath) {
          if (!entry && !filePath) return null;

          if (typeof entry === 'string') {
            return { path: filePath || null, opened: entry, count: 1 };
          }

          if (!entry || typeof entry !== 'object') {
            return filePath ? { path: filePath, opened: null, count: 1 } : null;
          }

          const parsedCount = Number(entry.count ?? entry.frequency ?? entry.opens ?? 1);
          return {
            path: filePath || entry.path || null,
            opened: typeof entry.opened === 'string'
              ? entry.opened
              : (typeof entry.used === 'string' ? entry.used : null),
            count: Number.isFinite(parsedCount) && parsedCount > 0 ? parsedCount : 1,
          };
        }

        function computeRecentBias(entry, nowMs = Date.now()) {
          if (!entry) return 0;

          const openedMs = Date.parse(entry.opened || '');
          let recencyBoost = 0;
          if (Number.isFinite(openedMs) && openedMs > 0) {
            const ageHours = Math.max(0, (nowMs - openedMs) / 3600000);
            recencyBoost = workerState.recentMaxRecencyBoost * Math.exp(-ageHours / workerState.recentRecencyHalfLifeHours);
          }

          const count = Math.max(1, Number(entry.count) || 1);
          const frequencyBoost = Math.min(
            workerState.recentMaxFrequencyBoost,
            Math.log2(count + 1) * workerState.recentFrequencyWeight
          );

          return recencyBoost + frequencyBoost;
        }

        function sortPickerResults(a, b) {
          if (a.isFolder && !b.isFolder) return -1;
          if (!a.isFolder && b.isFolder) return 1;
          if (a.isRecent && !b.isRecent) return -1;
          if (!a.isRecent && b.isRecent) return 1;

          const aRecentBias = Number(a.recentBias || 0);
          const bRecentBias = Number(b.recentBias || 0);
          if (aRecentBias !== bRecentBias) return bRecentBias - aRecentBias;

          const aOpened = a.opened ? Date.parse(a.opened) : 0;
          const bOpened = b.opened ? Date.parse(b.opened) : 0;
          if (aOpened !== bOpened) return bOpened - aOpened;

          if (a.score !== b.score) return b.score - a.score;

          const aDepth = a.path ? a.path.split('/').filter(Boolean).length : 0;
          const bDepth = b.path ? b.path.split('/').filter(Boolean).length : 0;
          if (aDepth !== bDepth) return aDepth - bDepth;

          return (a.path || '').localeCompare(b.path || '');
        }

        function getDirectChildNameInScope(absPath, scopePath) {
          if (!scopePath || !isInScopePath(absPath, scopePath)) return null;
          const rel = toScopeRelativePath(absPath, scopePath);
          if (!rel) return null;
          const parts = rel.split('/').filter(Boolean);
          return parts.length ? parts[0] : null;
        }

        function applyFolderReserve(rows, limit, hasQuery) {
          const sliced = rows.slice(0, limit);
          if (!hasQuery || rows.length <= limit) return sliced;

          const mustKeep = rows.filter(r => r.isFolder).slice(0, workerState.folderReserve);
          if (!mustKeep.length) return sliced;

          const selected = [...sliced];
          const selectedSet = new Set(selected.map(r => r.path));
          const missing = mustKeep.filter(r => !selectedSet.has(r.path));
          if (!missing.length) return selected;

          for (const folderRow of missing) {
            let replaceIdx = -1;
            for (let i = selected.length - 1; i >= 0; i--) {
              if (!selected[i].isFolder) {
                replaceIdx = i;
                break;
              }
            }
            if (replaceIdx === -1) break;
            selected[replaceIdx] = folderRow;
          }

          selected.sort(sortPickerResults);
          return selected;
        }

        function filterFiles(payload) {
          const start = Date.now();
          const {
            requestId,
            query = '',
            scopePath = null,
            includeOutsideScope = false,
          } = payload;

          const effectiveQuery = query || '';
          const hasQuery = effectiveQuery.length > 0;
          const trimmedQuery = effectiveQuery.trim();
          const resultPaths = new Set();
          const witnessFolders = new Map();
          const localResults = [];
          const outsideResults = [];

          for (const filePath of workerState.allFiles) {
            const inScope = isInScopePath(filePath, scopePath);
            if (!inScope && !includeOutsideScope) continue;
            const candidatePath = toScopeRelativePath(filePath, inScope ? scopePath : null);
            const matchResult = hasQuery
              ? fuzzyMatchPath(effectiveQuery, candidatePath)
              : fuzzyMatchPath('', candidatePath);
            if (hasQuery && matchResult.score <= 0) continue;

            const recentEntry = normalizeRecentEntry(workerState.recentByPath[filePath], filePath);
            const isRecent = !!recentEntry;
            if (!hasQuery && !isRecent && !scopePath && localResults.length >= workerState.maxResults * 2) continue;

            const recentBias = computeRecentBias(recentEntry);
            resultPaths.add(filePath);
            const row = {
              path: filePath,
              name: matchResult.name,
              dir: matchResult.dir,
              score: matchResult.score + recentBias,
              recentBias,
              recentCount: recentEntry?.count || 0,
              nameMatches: matchResult.nameMatches,
              dirMatches: matchResult.dirMatches,
              isRecent,
              opened: recentEntry?.opened || null,
              isFolder: false,
              isOutsideScope: !inScope,
            };
            if (inScope && scopePath && hasQuery && trimmedQuery.length <= workerState.directChildBoostMaxLen) {
              const directChild = getDirectChildNameInScope(filePath, scopePath);
              if (directChild && fuzzyMatch(trimmedQuery, directChild).score > 0) {
                row.score += 8;
              }
            }
            if (inScope) localResults.push(row);
            else outsideResults.push(row);

            if (inScope && hasQuery) {
              const parent = filePath.split('/').slice(0, -1).join('/');
              if (parent && parent !== scopePath && !resultPaths.has(parent)) {
                const current = witnessFolders.get(parent) || 0;
                witnessFolders.set(parent, Math.max(current, row.score * 0.72));
              }
            }
          }

          for (const folderPath of workerState.folders) {
            const inScope = isInScopePath(folderPath, scopePath);
            if (!inScope && !includeOutsideScope) continue;
            if (scopePath && folderPath === scopePath) continue;
            if (inScope && scopePath && !hasQuery) {
              const relative = toScopeRelativePath(folderPath, scopePath);
              if (relative.includes('/')) continue;
            }

            const candidatePath = toScopeRelativePath(folderPath, inScope ? scopePath : null);
            const matchResult = fuzzyMatchPath(effectiveQuery, candidatePath);
            if (hasQuery && matchResult.score <= 0) continue;
            if (resultPaths.has(folderPath)) continue;
            resultPaths.add(folderPath);

            const row = {
              path: folderPath,
              name: folderPath.split('/').pop(),
              dir: folderPath.split('/').slice(0, -1).join('/').replace(/^\\\\/home\\\\/[^/]+/, '~') || '~',
              score: matchResult.score,
              nameMatches: matchResult.nameMatches || [],
              dirMatches: matchResult.dirMatches || [],
              isRecent: false,
              opened: null,
              isFolder: true,
              isOutsideScope: !inScope,
            };
            if (inScope && scopePath && hasQuery && trimmedQuery.length <= workerState.directChildBoostMaxLen) {
              const directChild = getDirectChildNameInScope(folderPath, scopePath);
              if (directChild && fuzzyMatch(trimmedQuery, directChild).score > 0) {
                row.score += 14;
              }
            }
            if (inScope) localResults.push(row);
            else outsideResults.push(row);
          }

          if (hasQuery) {
            for (const [folderPath, score] of witnessFolders.entries()) {
              if (resultPaths.has(folderPath)) continue;
              const inScope = isInScopePath(folderPath, scopePath);
              if (!inScope && !includeOutsideScope) continue;
              resultPaths.add(folderPath);
              const row = {
                path: folderPath,
                name: folderPath.split('/').pop(),
                dir: folderPath.split('/').slice(0, -1).join('/').replace(/^\\\\/home\\\\/[^/]+/, '~') || '~',
                score,
                nameMatches: [],
                dirMatches: [],
                isRecent: false,
                opened: null,
                isFolder: true,
                isOutsideScope: !inScope,
                isWitness: true,
              };
              if (inScope) localResults.push(row);
              else outsideResults.push(row);
            }
          }

          localResults.sort(sortPickerResults);
          outsideResults.sort(sortPickerResults);
          const localLimited = applyFolderReserve(localResults, workerState.maxResults, hasQuery);
          const remaining = Math.max(0, workerState.maxResults - localLimited.length);
          const outsideLimited = remaining > 0
            ? applyFolderReserve(outsideResults, remaining, hasQuery)
            : [];
          const results = localLimited.concat(outsideLimited);

          self.postMessage({
            type: 'filter-result',
            requestId,
            results,
            durationMs: Date.now() - start,
          });
        }

        self.onmessage = (event) => {
          const msg = event.data || {};
          if (msg.type === 'set-index') {
            workerState.allFiles = Array.isArray(msg.allFiles) ? msg.allFiles : [];
            workerState.folders = Array.isArray(msg.folders) ? msg.folders : [];
            workerState.recentByPath = msg.recentByPath || {};
            workerState.maxResults = msg.maxResults || workerState.maxResults;
            workerState.folderReserve = msg.folderReserve || workerState.folderReserve;
            workerState.directChildBoostMaxLen = msg.directChildBoostMaxLen || workerState.directChildBoostMaxLen;
            return;
          }
          if (msg.type === 'filter') {
            filterFiles(msg);
          }
        };
      `;
    }

    function ensureFilterWorker() {
      if (state.filterWorkerReady || !window.Worker) return;
      try {
        const blob = new Blob([createFileFilterWorkerSource()], { type: 'application/javascript' });
        const worker = new Worker(URL.createObjectURL(blob));
        worker.onmessage = (event) => {
          const msg = event.data || {};
          if (msg.type !== 'filter-result') return;
          const meta = state.pendingFilterRequests.get(msg.requestId);
          if (!meta) return;
          state.pendingFilterRequests.delete(msg.requestId);
          if (msg.requestId !== state.filterRequestId) return;
          applyFilteredResults(msg.results || [], meta, msg.durationMs);
        };
        worker.onerror = (err) => {
          console.warn('[file-picker] Worker error, falling back to main-thread filtering:', err.message);
          state.filterWorkerReady = false;
        };
        state.filterWorker = worker;
        state.filterWorkerReady = true;
        syncFilterWorkerIndex();
      } catch (err) {
        console.warn('[file-picker] Failed to initialize worker:', err.message);
        state.filterWorkerReady = false;
      }
    }

    function syncFilterWorkerIndex() {
      if (!state.filterWorkerReady || !state.filterWorker) return;
      state.filterWorker.postMessage({
        type: 'set-index',
        allFiles: state.fileIndex.allFiles,
        folders: state.fileIndex.folders,
        recentByPath: serializeRecentMap(),
        maxResults: MAX_FILTER_RESULTS,
        folderReserve: FOLDER_RESULT_RESERVE,
        directChildBoostMaxLen: DIRECT_CHILD_QUERY_BOOST_MAX_LEN,
      });
    }

    function updatePickerModeUI(modeInfo) {
      const modeEl = document.getElementById('picker-mode');
      modeEl.style.display = 'none';
      modeEl.textContent = '';
    }

    function formatScopeBreadcrumb(scopePath) {
      if (!scopePath) return '';
      const root = state.defaultScopeRoot || scopePath;
      const rootLabel = root.replace(state.homeDir, '~');
      if (scopePath === root) return rootLabel;
      if (!scopePath.startsWith(root + '/')) return scopePath.replace(state.homeDir, '~');
      const relative = scopePath.slice(root.length + 1);
      const trail = relative.split('/').filter(Boolean).join(' › ');
      return trail ? `${rootLabel} › ${trail}` : rootLabel;
    }

    function updatePickerContextUI() {
      const contextEl = document.getElementById('picker-context');
      const contextPathEl = document.getElementById('picker-context-path');
      const contextHintEl = contextEl.querySelector('.picker-context-hint');
      const scopePath = getActiveScopePath();
      if (scopePath) {
        contextEl.style.display = 'flex';
        contextPathEl.textContent = formatScopeBreadcrumb(scopePath);
        if (contextHintEl) {
          contextHintEl.textContent = '[← / ⇧Tab / Backspace up]';
        }
      } else {
        contextEl.style.display = 'none';
      }
    }

    function renderPickerHint(key, label) {
      return `<span><kbd>${key}</kbd> ${label}</span>`;
    }

    function updatePickerHints() {
      const hintsEl = document.getElementById('picker-hints');
      if (!hintsEl) return;

      const selected = state.pickerSelectable[state.selectedFileIndex];
      const hasSelectable = state.pickerSelectable.length > 0;
      const hints = [];
      const hasCreateEntry = state.pickerSelectable.some(item =>
        item.kind === 'create-file' || item.kind === 'create-project'
      );
      const scopePath = getActiveScopePath();

      if (hasSelectable) {
        hints.push(renderPickerHint('↑↓', 'navigate'));

        if (selected?.kind === 'scope-up') {
          hints.push(renderPickerHint('Enter / Tab', 'up'));
        } else if (selected?.kind === 'folders-more') {
          hints.push(renderPickerHint('Enter / Tab', 'show more'));
        } else if (selected?.kind === 'file') {
          if (selected.file?.isFolder) {
            hints.push(renderPickerHint('Enter', 'open folder'));
            hints.push(renderPickerHint('→ / Tab', 'enter'));
          } else {
            hints.push(renderPickerHint('Enter', 'open'));
            hints.push(renderPickerHint('Tab', 'complete'));
          }
        } else if (selected?.kind === 'create-file' || selected?.kind === 'create-project') {
          hints.push(renderPickerHint('Enter', 'create'));
        } else {
          hints.push(renderPickerHint('Enter', 'open'));
        }
      }

      if (scopePath) hints.push(renderPickerHint('← / ⇧Tab', 'up'));
      if (hasCreateEntry) hints.push(renderPickerHint('⌘⏎', 'create'));
      hints.push(renderPickerHint('Esc', 'close'));

      hintsEl.innerHTML = hints.join('');
    }

    function computeFilteredFilesSync(query, modeInfo) {
      const localResults = [];
      const outsideResults = [];
      const resultPaths = new Set();
      const witnessFolders = new Map();
      const allFiles = state.fileIndex.allFiles;
      const allFolders = state.fileIndex.folders;
      const recentByPath = state.fileIndex.recentByPath;
      const effectiveQuery = query || '';
      const hasQuery = effectiveQuery.length > 0;
      const trimmedQuery = effectiveQuery.trim();
      const scopePath = getActiveScopePath();
      const includeOutsideScope = Boolean(hasQuery && scopePath);

      for (const filePath of allFiles) {
        const inScope = isInScopePath(filePath, scopePath);
        if (!inScope && !includeOutsideScope) continue;
        const candidatePath = toScopeRelativePath(filePath, inScope ? scopePath : null);
        const matchResult = hasQuery
          ? fuzzyMatchPath(effectiveQuery, candidatePath)
          : fuzzyMatchPath('', candidatePath);
        if (hasQuery && matchResult.score <= 0) continue;

        const recentEntry = normalizeRecentEntry(recentByPath.get(filePath));
        const isRecent = isRecentEntry(recentEntry);
        if (!hasQuery && !isRecent && !scopePath && localResults.length >= MAX_FILTER_RESULTS * 2) continue;

        const recentBias = computeRecentBias(recentEntry);
        resultPaths.add(filePath);
        const row = {
          path: filePath,
          name: matchResult.name,
          dir: matchResult.dir,
          score: matchResult.score + recentBias,
          recentBias,
          recentCount: recentEntry?.count || 0,
          nameMatches: matchResult.nameMatches,
          dirMatches: matchResult.dirMatches,
          isRecent,
          opened: recentEntry?.opened || null,
          isFolder: false,
          isOutsideScope: !inScope,
        };
        if (inScope && scopePath && hasQuery && trimmedQuery.length <= DIRECT_CHILD_QUERY_BOOST_MAX_LEN) {
          const directChild = getDirectChildNameInScope(filePath, scopePath);
          if (directChild && fuzzyMatch(trimmedQuery, directChild).score > 0) {
            row.score += 8;
          }
        }
        if (inScope) localResults.push(row);
        else outsideResults.push(row);

        if (inScope && hasQuery) {
          const parent = filePath.split('/').slice(0, -1).join('/');
          if (parent && parent !== scopePath && !resultPaths.has(parent)) {
            const current = witnessFolders.get(parent) || 0;
            witnessFolders.set(parent, Math.max(current, row.score * 0.72));
          }
        }
      }

      for (const folderPath of allFolders) {
        const inScope = isInScopePath(folderPath, scopePath);
        if (!inScope && !includeOutsideScope) continue;
        if (scopePath && folderPath === scopePath) continue;
        if (inScope && scopePath && !hasQuery) {
          const relative = toScopeRelativePath(folderPath, scopePath);
          if (relative.includes('/')) continue;
        }

        const candidatePath = toScopeRelativePath(folderPath, inScope ? scopePath : null);
        const matchResult = fuzzyMatchPath(effectiveQuery, candidatePath);
        if (hasQuery && matchResult.score <= 0) continue;
        if (resultPaths.has(folderPath)) continue;
        resultPaths.add(folderPath);

        const row = {
          path: folderPath,
          name: folderPath.split('/').pop(),
          dir: folderPath.split('/').slice(0, -1).join('/').replace(state.homeDir, '~') || '~',
          score: matchResult.score,
          nameMatches: matchResult.nameMatches || [],
          dirMatches: matchResult.dirMatches || [],
          isRecent: false,
          isFolder: true,
          isOutsideScope: !inScope,
        };
        if (inScope && scopePath && hasQuery && trimmedQuery.length <= DIRECT_CHILD_QUERY_BOOST_MAX_LEN) {
          const directChild = getDirectChildNameInScope(folderPath, scopePath);
          if (directChild && fuzzyMatch(trimmedQuery, directChild).score > 0) {
            row.score += 14;
          }
        }
        if (inScope) localResults.push(row);
        else outsideResults.push(row);
      }

      if (hasQuery) {
        for (const [folderPath, score] of witnessFolders.entries()) {
          if (resultPaths.has(folderPath)) continue;
          const inScope = isInScopePath(folderPath, scopePath);
          if (!inScope && !includeOutsideScope) continue;
          resultPaths.add(folderPath);
          const row = {
            path: folderPath,
            name: folderPath.split('/').pop(),
            dir: folderPath.split('/').slice(0, -1).join('/').replace(state.homeDir, '~') || '~',
            score,
            nameMatches: [],
            dirMatches: [],
            isRecent: false,
            isFolder: true,
            isOutsideScope: !inScope,
            isWitness: true,
          };
          if (inScope) localResults.push(row);
          else outsideResults.push(row);
        }
      }

      localResults.sort(sortPickerResults);
      outsideResults.sort(sortPickerResults);
      const localLimited = applyFolderReserve(localResults, {
        limit: MAX_FILTER_RESULTS,
        hasQuery,
      });
      const remaining = Math.max(0, MAX_FILTER_RESULTS - localLimited.length);
      const outsideLimited = remaining > 0
        ? applyFolderReserve(outsideResults, { limit: remaining, hasQuery })
        : [];
      return localLimited.concat(outsideLimited);
    }

    function applyFilteredResults(results, meta, durationMs) {
      state.filteredFiles = Array.isArray(results) ? results : [];
      state.lastFilterMs = Number.isFinite(durationMs) ? durationMs : (performance.now() - meta.startedAt);
      setPickerStatus(state.filteredFiles.length, state.lastFilterMs);

      let newSelectedIndex = 0;
      if (meta.preserveSelection && meta.previousSelectedPath) {
        const foundIndex = state.filteredFiles.findIndex(f => f.path === meta.previousSelectedPath);
        if (foundIndex !== -1) newSelectedIndex = foundIndex;
      }

      state.selectedFileIndex = newSelectedIndex;
      renderFileList(meta.modeInfo);

      const selectedEntry = state.pickerSelectable[state.selectedFileIndex];
      const selectionChanged = selectedEntry?.path !== meta.previousSelectedPath;
      if (selectedEntry?.kind === 'file' && !selectedEntry.file.isFolder && (!meta.preserveSelection || selectionChanged)) {
        schedulePreview(selectedEntry.path);
      }
    }

    function setPickerStatus(results = null, tookMs = null) {
      const statusEl = document.getElementById('picker-status');
      if (!statusEl) return;

      if (state.fileScanStatus === 'scanning') {
        statusEl.textContent = `Indexing...${typeof results === 'number' ? ` (${results})` : ''}`;
        return;
      }

      if (typeof results === 'number') {
        const suffix = Number.isFinite(tookMs) ? ` • ${tookMs.toFixed(1)}ms` : '';
        statusEl.textContent = `${results} result${results === 1 ? '' : 's'}${suffix}`;
        return;
      }

      statusEl.textContent = 'Ready';
    }

    function scheduleFilter(query, { preserveSelection = false, immediate = false } = {}) {
      clearTimeout(state.filterDebounceTimer);
      if (immediate) {
        filterFiles(query, { preserveSelection });
        return;
      }
      state.filterDebounceTimer = setTimeout(() => {
        filterFiles(query, { preserveSelection });
      }, FILTER_DEBOUNCE_MS);
    }

    function cachePreview(filePath, previewText) {
      state.previewCache.set(filePath, previewText);
      if (state.previewCache.size > PREVIEW_CACHE_LIMIT) {
        const oldestKey = state.previewCache.keys().next().value;
        state.previewCache.delete(oldestKey);
      }
    }

    function schedulePreview(filePath) {
      clearTimeout(state.previewDebounceTimer);
      const navRecently = (performance.now() - state.lastPickerNavTs) < FILE_INDEX_REFRESH_NAV_GRACE_MS;
      const delay = navRecently ? PREVIEW_DEBOUNCE_MS + 120 : PREVIEW_DEBOUNCE_MS;
      state.previewDebounceTimer = setTimeout(() => {
        loadPreview(filePath);
      }, delay);
    }

    function normalizeScopeForScanRoot(scopePath) {
      if (!scopePath || scopePath === '/') return state.homeDir || '/';
      return scopePath;
    }

    function isScopeInsideScanRoot(scopePath, scanRoot) {
      if (!scopePath || !scanRoot) return false;
      if (scopePath === scanRoot) return true;
      return scopePath.startsWith(scanRoot + '/');
    }

    function startFileScan(searchDir) {
      const targetRoot = normalizeScopeForScanRoot(searchDir);
      state.fileScanRoot = targetRoot;
      state.fileScanToken = null;
      state.files = [];
      state.scannedDirs = [];
      state.fileIndex.ready = false;
      state.fileScanStatus = 'scanning';
      clearTimeout(state.filesUpdateTimer);
      setPickerStatus();
      electronAPI.scanFiles(targetRoot);
    }

    function ensureScanCoverageForScope(scopePath) {
      const targetRoot = normalizeScopeForScanRoot(scopePath);
      if (!isScopeInsideScanRoot(targetRoot, state.fileScanRoot)) {
        startFileScan(targetRoot);
      }
    }

    /**
     * Start a background rescan that merges new results without clearing existing data.
     * This keeps the picker responsive while updating the index.
     * We set a flag so the files-update handler knows to skip the reset.
     */
    function startBackgroundRescan(searchDir) {
      const targetRoot = normalizeScopeForScanRoot(searchDir);
      state.fileScanRoot = targetRoot;
      state.fileScanStatus = 'scanning';
      state._backgroundRescan = true; // Skip reset on next scan-files response
      electronAPI.scanFiles(targetRoot);
    }

    function showFilePicker() {
      document.getElementById('file-picker-overlay').classList.add('visible');

      // On mobile: add a close button if not already present
      if (isMobileLayout()) {
        const pickerHeader = document.querySelector('.file-picker .picker-header');
        if (pickerHeader && !pickerHeader.querySelector('.picker-close-btn')) {
          const closeBtn = document.createElement('button');
          closeBtn.className = 'picker-close-btn';
          closeBtn.innerHTML = '×';
          closeBtn.style.cssText = `
            background: transparent; border: none; color: var(--text-muted);
            font-size: 24px; width: 44px; height: 44px; display: flex;
            align-items: center; justify-content: center; cursor: pointer;
            flex-shrink: 0; border-radius: 8px; margin-left: 4px;
          `;
          closeBtn.addEventListener('click', hideFilePicker);
          pickerHeader.appendChild(closeBtn);
        }
      }

      const input = document.getElementById('file-search');
      input.value = '';
      input.focus();
      ensureFilterWorker();
      initFilePickerVirtualization();
      state.defaultScopeRoot = state.project?.root
        || (state.currentFile ? state.currentFile.replace(/\/[^/]+$/, '') : null)
        || state.homeDir
        || '/';
      state.folderContext = state.defaultScopeRoot;
      state.pickerShowAllFolders = false;
      updatePickerContextUI();
      updatePickerHints();

      const preview = document.getElementById('preview-content');
      const previewFile = document.getElementById('preview-file');
      preview.textContent = 'Select a file to preview';
      previewFile.textContent = '';

      // Load recent files first
      loadRecentFiles();

      // Only start a fresh scan if we have no cached data or scope changed
      const needsScan = !state.fileIndex.ready
        || !state.files || state.files.length === 0
        || !isScopeInsideScanRoot(state.folderContext, state.fileScanRoot);
      if (needsScan) {
        startFileScan(state.folderContext);
      } else {
        // Reuse cached data - just refresh the filter
        scheduleFilter('', { immediate: true });
        // Start a background rescan to pick up any new files
        startBackgroundRescan(state.folderContext);
      }
    }

    function hideFilePicker() {
      document.getElementById('file-picker-overlay').classList.remove('visible');
      clearTimeout(state.filterDebounceTimer);
      clearTimeout(state.previewDebounceTimer);
      clearTimeout(state.filesUpdateTimer);
      state.pendingFilterRequests.clear();
      // Don't clear files/scannedDirs/fileIndex - keep them cached for next open
      // Only reset scan status so we know we can do incremental updates
      state.fileScanStatus = 'idle';
      document.getElementById('picker-hints').innerHTML = '';
      setPickerStatus();
      resetPickerState();
    }

    async function loadRecentFiles() {
      const recent = await electronAPI.getRecent();
      state.recentFiles = recent.files || [];
      rebuildFileIndex();
      scheduleFilter('', { immediate: true });
    }

    function filterFiles(query, { preserveSelection = false } = {}) {
      if (!state.fileIndex.ready) {
        rebuildFileIndex();
      }

      const previousSelectedPath = state.pickerSelectable[state.selectedFileIndex]?.path
        || state.filteredFiles[state.selectedFileIndex]?.path;
      const modeInfo = detectPickerMode(query);
      state.pickerMode = modeInfo.mode;
      state.createTarget = modeInfo.mayCreate ? query : null;
      updatePickerModeUI(modeInfo);
      updatePickerContextUI();
      const scopePath = getActiveScopePath();
      const includeOutsideScope = Boolean((query || '').trim() && scopePath);

      const meta = {
        preserveSelection,
        previousSelectedPath,
        modeInfo,
        startedAt: performance.now(),
      };

      if (state.filterWorkerReady && state.filterWorker) {
        const requestId = ++state.filterRequestId;
        state.pendingFilterRequests.set(requestId, meta);
        state.filterWorker.postMessage({
          type: 'filter',
          requestId,
          query: query || '',
          scopePath: scopePath || null,
          includeOutsideScope,
        });
        return;
      }

      const results = computeFilteredFilesSync(query || '', modeInfo);
      applyFilteredResults(results, meta, performance.now() - meta.startedAt);
    }

    function initFilePickerVirtualization() {
      if (state.pickerVirtualInit) return;
      const list = document.getElementById('file-list');
      list.addEventListener('scroll', () => renderVirtualRows());
      window.addEventListener('resize', () => {
        const visible = document.getElementById('file-picker-overlay').classList.contains('visible');
        if (visible) renderVirtualRows();
      });
      state.pickerVirtualInit = true;
    }

    function getPickerRowHeight(row) {
      if (row.type === 'header') return VIRTUAL_HEADER_ROW_HEIGHT;
      if (row.type === 'empty') return VIRTUAL_EMPTY_ROW_HEIGHT;
      return VIRTUAL_ITEM_ROW_HEIGHT;
    }

    function buildPickerRows(modeInfo = {}, query = '') {
      const hasQuery = (query || '').trim().length > 0;
      const localItems = state.filteredFiles.filter(f => !f.isOutsideScope);
      const outsideItems = state.filteredFiles.filter(f => f.isOutsideScope);
      const recent = hasQuery ? [] : localItems.filter(f => f.isRecent && !f.isFolder);
      const folders = localItems.filter(f => f.isFolder);
      const files = hasQuery
        ? localItems.filter(f => !f.isFolder)
        : localItems.filter(f => !f.isRecent && !f.isFolder);
      const outsideFolders = outsideItems.filter(f => f.isFolder);
      const outsideFiles = outsideItems.filter(f => !f.isFolder);
      const scopePath = getActiveScopePath();
      const parentScope = getPickerParentPath(scopePath);

      const rows = [];
      const selectable = [];
      const rowBySelectable = new Map();
      let selectableIndex = 0;

      const addHeader = (title) => {
        rows.push({ type: 'header', title });
      };

      const addFileRows = (items) => {
        for (const file of items) {
          rowBySelectable.set(selectableIndex, rows.length);
          rows.push({ type: 'file', file, selectableIndex });
          selectable.push({
            kind: 'file',
            path: file.path,
            file,
          });
          selectableIndex++;
        }
      };

      if (scopePath && parentScope) {
        addHeader('Navigate');
        rowBySelectable.set(selectableIndex, rows.length);
        rows.push({
          type: 'scope-up',
          parentPath: parentScope,
          parentDisplay: parentScope.replace(state.homeDir, '~'),
          selectableIndex,
        });
        selectable.push({
          kind: 'scope-up',
          path: parentScope,
        });
        selectableIndex++;
      }

      const shouldCollapseFolders = !hasQuery && !state.pickerShowAllFolders;
      const visibleFolders = shouldCollapseFolders
        ? folders.slice(0, FOLDER_SECTION_COLLAPSED_LIMIT)
        : folders;
      const hiddenFolders = shouldCollapseFolders
        ? folders.slice(FOLDER_SECTION_COLLAPSED_LIMIT)
        : [];

      if (visibleFolders.length > 0) {
        addHeader('Folders');
        addFileRows(visibleFolders);

        if (hiddenFolders.length > 0) {
          const revealPath = hiddenFolders[0]?.path || null;
          rowBySelectable.set(selectableIndex, rows.length);
          rows.push({
            type: 'folders-more',
            remaining: hiddenFolders.length,
            revealPath,
            selectableIndex,
          });
          selectable.push({
            kind: 'folders-more',
            path: revealPath || '__folders_more__',
          });
          selectableIndex++;
        }
      }

      if (recent.length > 0) {
        addHeader('Recent');
        addFileRows(recent);
      }

      if (files.length > 0) {
        addHeader('Files');
        addFileRows(files);
      }
      if (outsideFolders.length > 0 || outsideFiles.length > 0) {
        addHeader('Outside Scope');
        addFileRows(outsideFolders.concat(outsideFiles));
      }

      const noMatches = state.filteredFiles.length === 0;
      if (noMatches && !modeInfo.mayCreate) {
        rows.push({ type: 'empty', text: 'No files found' });
      }

      if (query && (modeInfo.mayCreate || noMatches)) {
        addHeader('Create');

        const createPath = modeInfo.basePath
          ? modeInfo.basePath
          : scopePath
          ? `${scopePath}/${query.replace(/^\.\//, '')}`
          : (state.project?.root
            ? `${state.project.root}/${query.replace(/^\.\//, '')}`
            : query);
        const displayPath = createPath.replace(state.homeDir, '~');

        if (modeInfo.isFile || isDocFile(query)) {
          const fileName = ensureDocExtension(query);
          rowBySelectable.set(selectableIndex, rows.length);
          rows.push({
            type: 'create',
            action: 'create-file',
            fileName,
            displayPath,
            selectableIndex,
          });
          selectable.push({
            kind: 'create-file',
            path: createPath,
          });
          selectableIndex++;
        } else if (!modeInfo.isFile && query.length > 0) {
          rowBySelectable.set(selectableIndex, rows.length);
          rows.push({
            type: 'create',
            action: 'create-project',
            projectName: query,
            selectableIndex,
          });
          selectable.push({
            kind: 'create-project',
            path: createPath,
          });
          selectableIndex++;
        }
      }

      return { rows, selectable, rowBySelectable };
    }

    function renderFileList(modeInfo = {}) {
      const list = document.getElementById('file-list');
      const query = document.getElementById('file-search').value;
      const { rows, selectable, rowBySelectable } = buildPickerRows(modeInfo, query);
      state.pickerRows = rows;
      state.pickerSelectable = selectable;
      state.pickerRowBySelectable = rowBySelectable;

      if (selectable.length === 0) {
        state.selectedFileIndex = 0;
      } else if (state.selectedFileIndex >= selectable.length) {
        state.selectedFileIndex = selectable.length - 1;
      } else if (state.selectedFileIndex < 0) {
        state.selectedFileIndex = 0;
      }
      updatePickerHints();

      const offsets = [];
      const heights = [];
      let totalHeight = 0;
      for (const row of rows) {
        offsets.push(totalHeight);
        const h = getPickerRowHeight(row);
        heights.push(h);
        totalHeight += h;
      }

      state.pickerRowOffsets = offsets;
      state.pickerRowHeights = heights;
      state.pickerTotalHeight = totalHeight;

      const maxScrollTop = Math.max(0, totalHeight - list.clientHeight);
      if (list.scrollTop > maxScrollTop) list.scrollTop = maxScrollTop;
      renderVirtualRows();
    }

    function lowerBound(arr, value) {
      let lo = 0;
      let hi = arr.length;
      while (lo < hi) {
        const mid = (lo + hi) >> 1;
        if (arr[mid] < value) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    }

    function renderVirtualRows() {
      const list = document.getElementById('file-list');
      const rows = state.pickerRows;
      if (!rows || rows.length === 0) {
        list.innerHTML = '';
        return;
      }

      const offsets = state.pickerRowOffsets;
      const heights = state.pickerRowHeights;
      const totalHeight = state.pickerTotalHeight;
      const viewHeight = Math.max(1, list.clientHeight || 400);
      const overscanPx = VIRTUAL_OVERSCAN_ROWS * VIRTUAL_ITEM_ROW_HEIGHT;
      const startPx = Math.max(0, list.scrollTop - overscanPx);
      const endPx = list.scrollTop + viewHeight + overscanPx;

      const startRow = Math.max(0, lowerBound(offsets, startPx) - 1);
      let endRow = lowerBound(offsets, endPx + 1) + VIRTUAL_OVERSCAN_ROWS;
      endRow = Math.min(rows.length, endRow);

      const html = [];
      for (let i = startRow; i < endRow; i++) {
        const row = rows[i];
        const top = offsets[i];
        const height = heights[i];
        if (row.type === 'header') {
          html.push(`
            <div class="picker-virtual-row picker-virtual-header" style="top:${top}px;height:${height}px;">
              <div class="picker-section-title">${row.title}</div>
            </div>
          `);
        } else if (row.type === 'empty') {
          html.push(`
            <div class="picker-virtual-row empty-state" style="top:${top}px;height:${height}px;display:flex;align-items:center;justify-content:center;">
              ${row.text}
            </div>
          `);
        } else if (row.type === 'scope-up') {
          html.push(renderScopeUpRow(row, row.selectableIndex, { top, height }));
        } else if (row.type === 'folders-more') {
          html.push(renderFoldersMoreRow(row, row.selectableIndex, { top, height }));
        } else if (row.type === 'create') {
          html.push(renderCreateRow(row, row.selectableIndex, { top, height }));
        } else if (row.type === 'file') {
          html.push(renderFileItem(row.file, row.selectableIndex, { top, height }));
        }
      }

      list.innerHTML = `<div class="picker-virtual-root" style="height:${totalHeight}px">${html.join('')}</div>`;
    }

    function ensureSelectedVisible(index) {
      const list = document.getElementById('file-list');
      const rowIndex = state.pickerRowBySelectable.get(index);
      if (rowIndex === undefined) return;

      const top = state.pickerRowOffsets[rowIndex];
      const bottom = top + state.pickerRowHeights[rowIndex];
      const margin = 12;
      const viewTop = list.scrollTop;
      const viewBottom = list.scrollTop + list.clientHeight;
      let scrolled = false;

      if (top < viewTop + margin) {
        list.scrollTop = Math.max(0, top - margin);
        scrolled = true;
      } else if (bottom > viewBottom - margin) {
        list.scrollTop = Math.max(0, bottom - list.clientHeight + margin);
        scrolled = true;
      }
      if (scrolled) renderVirtualRows();
    }

    function renderScopeUpRow(row, index, layout = null) {
      const selected = index === state.selectedFileIndex ? 'selected' : '';
      const rowClass = layout ? 'picker-virtual-row' : '';
      const style = layout ? `style="top:${layout.top}px;height:${layout.height}px"` : '';
      return `
        <div class="${rowClass} picker-item folder ${selected}" ${style}
             data-index="${index}" data-action="scope-up"
             onclick="selectFileItem(${index})" ondblclick="exitFolderContext()">
          <span class="picker-item-icon">←</span>
          <span class="picker-item-name">..</span>
          <span class="picker-item-path">${row.parentDisplay}</span>
          <span class="picker-item-action">[Enter]</span>
        </div>
      `;
    }

    function renderFoldersMoreRow(row, index, layout = null) {
      const selected = index === state.selectedFileIndex ? 'selected' : '';
      const rowClass = layout ? 'picker-virtual-row' : '';
      const style = layout ? `style="top:${layout.top}px;height:${layout.height}px"` : '';
      const countLabel = row.remaining === 1 ? 'folder' : 'folders';

      return `
        <div class="${rowClass} picker-item folder ${selected}" ${style}
             data-index="${index}" data-action="folders-more"
             onclick="selectFileItem(${index})" ondblclick="showMoreFolders()">
          <span class="picker-item-icon">⋯</span>
          <span class="picker-item-name">Show ${row.remaining} more ${countLabel}</span>
          <span class="picker-item-path">Expand folder list</span>
          ${selected ? '<span class="picker-item-action">[Enter]</span>' : ''}
        </div>
      `;
    }

    function renderCreateRow(row, index, layout = null) {
      const selected = index === state.selectedFileIndex ? 'selected' : '';
      const rowClass = layout ? 'picker-virtual-row' : '';
      const style = layout ? `style="top:${layout.top}px;height:${layout.height}px"` : '';

      if (row.action === 'create-file') {
        return `
          <div class="${rowClass} picker-item create ${selected}" ${style}
               data-index="${index}" data-action="create-file"
               onclick="selectFileItem(${index})" ondblclick="createNewFile()">
            <span class="picker-item-icon">+</span>
            <span class="picker-item-name">Create: ${row.fileName}</span>
            <span class="picker-item-path">${row.displayPath}</span>
            ${selected ? '<span class="picker-item-action">[Enter]</span>' : ''}
          </div>
        `;
      }

      return `
        <div class="${rowClass} picker-item create ${selected}" ${style}
             data-index="${index}" data-action="create-project"
             onclick="selectFileItem(${index})" ondblclick="createNewProject()">
          <span class="picker-item-icon">+</span>
          <span class="picker-item-name">Create PROJECT: ${row.projectName}</span>
          <span class="picker-item-path">with mrmd.md, .venv</span>
          ${selected ? '<span class="picker-item-action">[Enter]</span>' : ''}
        </div>
      `;
    }

    function renderFileItem(file, index, layout = null) {
      const selected = index === state.selectedFileIndex ? 'selected' : '';
      const timeAgo = file.opened ? formatTimeAgo(new Date(file.opened)) : '';
      const usageCount = Math.max(0, Number(file.recentCount || 0));
      const usageMeta = usageCount > 1 ? `${Math.round(usageCount)}x` : '';
      const timeMeta = [timeAgo, usageMeta].filter(Boolean).join(' • ');
      const isFolder = file.isFolder;
      const isNotebook = file.path.endsWith('.ipynb');
      const isOutsideScope = !!file.isOutsideScope;
      const rowClass = layout ? 'picker-virtual-row' : '';
      const style = layout ? `style="top:${layout.top}px;height:${layout.height}px"` : '';

      const icon = isFolder ? '<svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 4v9a1 1 0 001 1h10a1 1 0 001-1V6a1 1 0 00-1-1H8L6.5 3H3a1 1 0 00-1 1z"/></svg>' : (file.isRecent ? '·' : '');
      const classes = `picker-item ${selected} ${isFolder ? 'folder' : ''} ${isNotebook ? 'notebook' : ''} ${isOutsideScope ? 'outside-scope' : ''}`;
      const notebookBadge = isNotebook ? '<span class="picker-item-badge notebook">ipynb</span>' : '';
      const outsideBadge = isOutsideScope ? '<span class="picker-item-badge scope">outside</span>' : '';

      return `
        <div class="${rowClass} ${classes}" ${style} data-index="${index}" data-path="${file.path}" ${isFolder ? 'data-folder="true"' : ''}
             onclick="selectFileItem(${index})" ondblclick="${isFolder ? 'enterFolder' : 'openSelectedFile'}('${file.path.replace(/'/g, "\\'")}')">
          <span class="picker-item-icon">${icon}</span>
          <span class="picker-item-name">${highlightMatches(file.name, file.nameMatches)}</span>
          ${notebookBadge}
          ${outsideBadge}
          <span class="picker-item-path">${highlightMatches(file.dir, file.dirMatches)}</span>
          ${isFolder ? '<span class="picker-item-action">[→ or Tab]</span>' : ''}
          ${timeMeta ? `<span class="picker-item-meta">${timeMeta}</span>` : ''}
        </div>
      `;
    }

    function selectFileItem(index) {
      state.lastPickerNavTs = performance.now();
      const total = state.pickerSelectable.length;
      if (total <= 0) {
        state.selectedFileIndex = 0;
        renderVirtualRows();
        return;
      }

      const clampedIndex = Math.max(0, Math.min(index, total - 1));
      state.selectedFileIndex = clampedIndex;
      updatePickerHints();
      renderVirtualRows();
      ensureSelectedVisible(clampedIndex);

      const selectedEntry = state.pickerSelectable[clampedIndex];
      if (selectedEntry?.kind === 'file' && !selectedEntry.file?.isFolder) {
        schedulePreview(selectedEntry.path);
      }
    }

    function normalizePreviewResult(result) {
      if (typeof result === 'string') {
        return { success: true, preview: result };
      }
      if (result && typeof result === 'object') {
        const previewText = typeof result.preview === 'string'
          ? result.preview
          : (typeof result.content === 'string' ? result.content : '');
        return {
          success: result.success !== false,
          preview: previewText,
        };
      }
      return { success: false, preview: '' };
    }

    async function loadPreview(filePath) {
      if (!isFilePickerVisible()) return;
      const preview = document.getElementById('preview-content');
      const previewFile = document.getElementById('preview-file');
      previewFile.textContent = filePath.split('/').pop() || '';

      if (state.previewCache.has(filePath)) {
        const cached = state.previewCache.get(filePath);
        preview.textContent = cached || '(empty file)';
        return;
      }

      preview.textContent = 'Loading...';

      // Track request ID to prevent race conditions
      const requestId = ++state.previewRequestId;
      let result;
      try {
        result = await electronAPI.readPreview(filePath, 40);
      } catch (err) {
        if (requestId !== state.previewRequestId) return;
        preview.textContent = 'Failed to load preview';
        return;
      }

      // Only update if this is still the current request
      if (requestId !== state.previewRequestId || !isFilePickerVisible()) return;

      const normalized = normalizePreviewResult(result);
      if (normalized.success) {
        const previewText = normalized.preview || '';
        cachePreview(filePath, previewText);
        preview.textContent = previewText || '(empty file)';
      } else {
        preview.textContent = 'Failed to load preview';
      }
    }

    async function openSelectedFile(path = null) {
      if (path) {
        hideFilePicker();
        await openFile(path);
        return;
      }

      const selectedEntry = state.pickerSelectable[state.selectedFileIndex];
      if (!selectedEntry) return;

      if (selectedEntry.kind === 'create-file') {
        await createNewFile();
        return;
      }
      if (selectedEntry.kind === 'create-project') {
        await createNewProject();
        return;
      }
      if (selectedEntry.kind === 'scope-up') {
        exitFolderContext();
        return;
      }
      if (selectedEntry.kind === 'folders-more') {
        showMoreFolders();
        return;
      }

      if (selectedEntry.kind !== 'file') return;

      if (selectedEntry.file?.isFolder) {
        enterFolder(selectedEntry.path);
        return;
      }

      hideFilePicker();
      await openFile(selectedEntry.path);
    }

    function showMoreFolders() {
      if (state.pickerShowAllFolders) return;
      state.pickerShowAllFolders = true;
      const query = document.getElementById('file-search').value;
      scheduleFilter(query, { immediate: true, preserveSelection: true });
    }

    /**
     * Enter a folder context (browse inside)
     */
    function enterFolder(folderPath) {
      state.folderContext = folderPath;
      state.pickerShowAllFolders = false;
      const input = document.getElementById('file-search');
      input.value = '';
      input.focus();
      updatePickerContextUI();
      ensureScanCoverageForScope(state.folderContext);
      scheduleFilter('', { immediate: true });
    }

    /**
     * Exit folder context (go up one level)
     */
    function exitFolderContext() {
      const activeScope = getActiveScopePath();
      if (!activeScope) return;
      const parent = getPickerParentPath(activeScope);
      if (!parent) {
        state.folderContext = null;
      } else {
        state.folderContext = parent;
      }
      state.pickerShowAllFolders = false;

      updatePickerContextUI();
      ensureScanCoverageForScope(state.folderContext);
      scheduleFilter(document.getElementById('file-search').value, { immediate: true });
    }

    /**
     * Tab completion - complete selected item or enter folder
     */
    function tabComplete() {
      const selectedEntry = state.pickerSelectable[state.selectedFileIndex];
      if (!selectedEntry) return;
      if (selectedEntry.kind === 'create-file' || selectedEntry.kind === 'create-project') return;
      if (selectedEntry.kind === 'scope-up') {
        exitFolderContext();
        return;
      }
      if (selectedEntry.kind === 'folders-more') {
        showMoreFolders();
        return;
      }
      if (selectedEntry.kind !== 'file') return;

      if (selectedEntry.file?.isFolder) {
        enterFolder(selectedEntry.path);
      } else {
        const input = document.getElementById('file-search');
        input.value = selectedEntry.path.replace(state.homeDir, '~');
        scheduleFilter(input.value, { immediate: true });
      }
    }

    /**
     * Create a new file
     */
    async function createNewFile() {
      const query = document.getElementById('file-search').value;
      let fileName = ensureDocExtension(query);

      // Remove path prefixes for display
      fileName = fileName.replace(/^\.\//, '').replace(/^~\//, '');

      // Determine target path
      let targetPath;
      const modeInfo = detectPickerMode(query);
      const scopePath = getActiveScopePath();
      if (modeInfo.basePath) {
        targetPath = ensureDocExtension(modeInfo.basePath);
      } else if (scopePath) {
        targetPath = `${scopePath}/${fileName}`;
      } else if (state.project?.root) {
        // Create in project root
        targetPath = `${state.project.root}/${fileName}`;
      } else {
        console.warn('Cannot determine where to create file');
        return;
      }

      console.log('Creating file:', targetPath);

      try {
        // Use the file service
        const content = buildNewDocumentContentFromPath(targetPath);
        await electronAPI.file.create(targetPath, content);
        hideFilePicker();
        await openFile(targetPath);
      } catch (e) {
        console.error('Failed to create file:', e);
        alert('Failed to create file: ' + e.message);
      }
    }

    /**
     * Create a new project
     */
    async function createNewProject() {
      const query = document.getElementById('file-search').value;

      // Remove path prefixes
      let projectName = query.replace(/^\.\//, '').replace(/^~\//, '').replace(/\/$/, '');

      // Determine target path
      let targetPath;
      const modeInfo = detectPickerMode(query);
      const scopePath = getActiveScopePath();
      if (modeInfo.basePath) {
        targetPath = modeInfo.basePath;
      } else if (scopePath) {
        targetPath = `${scopePath}/${projectName}`;
      } else {
        if (state.homeDir) {
          // Default to ~/Projects/<name> or just home/<name>
          targetPath = `${state.homeDir}/Projects/${projectName}`;
        } else {
          console.warn('Cannot determine where to create project');
          return;
        }
      }

      console.log('Creating project:', targetPath);

      try {
        // Use the project service
        const project = await electronAPI.project.create(targetPath);

        hideFilePicker();

        // Open the project's index file
        const indexPath = `${targetPath}/01-index.md`;
        await openFile(indexPath);
      } catch (e) {
        console.error('Failed to create project:', e);
        alert('Failed to create project: ' + e.message);
      }
    }

    /**
     * Reset picker state when hiding
     */
    function resetPickerState() {
      state.folderContext = null;
      state.defaultScopeRoot = null;
      // Keep state.fileScanRoot - it indicates what's cached
      state.pickerMode = 'fuzzy';
      state.createTarget = null;
      state.pickerShowAllFolders = false;
      updatePickerContextUI();
    }

    // =========================================================================
    // VENV PICKER
    // =========================================================================

    async function showVenvPicker() {
      document.getElementById('venv-picker-overlay').classList.add('visible');
      state.venvs = [];
      state.filteredVenvs = [];
      state.filteredRuntimes = [];
      state.runningRuntimes = [];
      state.selectedVenvIndex = 0;
      state.venvQuery = '';

      const input = document.getElementById('venv-search');
      input.value = '';
      input.focus();

      document.getElementById('custom-python-path').value = '';

      renderVenvList();

      // Load running runtimes first (instant)
      const sessions = await electronAPI.runtime.list();
      // Map session format to runtime format for compatibility
      state.runningRuntimes = sessions.filter(s => s.alive).map(s => ({
        id: s.name,
        pid: s.pid,
        port: s.port,
        venv: s.venv,
        alive: s.alive
      }));
      filterVenvs(state.venvQuery);

      // Start discovery
      electronAPI.discoverVenvs(state.projectDir);
    }

    function hideVenvPicker() {
      document.getElementById('venv-picker-overlay').classList.remove('visible');
    }

    function filterVenvs(query) {
      state.venvQuery = query;
      const q = query.toLowerCase();

      // Filter runtimes
      state.filteredRuntimes = state.runningRuntimes.filter(rt => {
        if (!q) return true;
        return rt.id.toLowerCase().includes(q) ||
               (rt.venv || '').toLowerCase().includes(q);
      });

      // Filter venvs
      state.filteredVenvs = state.venvs.filter(v => {
        if (!q) return true;
        return v.projectName.toLowerCase().includes(q) ||
               v.path.toLowerCase().includes(q) ||
               (v.pythonVersion || '').toLowerCase().includes(q);
      });

      // Sort to match render order
      const sourceOrder = { system: 0, project: 1, recent: 2, conda: 3, pyenv: 4, discovered: 5 };
      state.filteredVenvs.sort((a, b) => {
        return (sourceOrder[a.source] ?? 6) - (sourceOrder[b.source] ?? 6);
      });

      state.selectedVenvIndex = 0;
      renderVenvList();
    }

    function addVenv(venv) {
      // Avoid duplicates
      if (!state.venvs.some(v => v.path === venv.path)) {
        state.venvs.push(venv);
        // Sort: project first, then recent, then discovered
        state.venvs.sort((a, b) => {
          const order = { project: 0, recent: 1, discovered: 2 };
          return (order[a.source] || 3) - (order[b.source] || 3);
        });
        filterVenvs(state.venvQuery);
      }
    }

    function renderVenvList() {
      const list = document.getElementById('venv-list');

      // Still loading
      if (state.runningRuntimes.length === 0 && state.venvs.length === 0) {
        list.innerHTML = '<div class="empty-state">Searching...</div>';
        return;
      }

      // No matches for search
      if (state.filteredRuntimes.length === 0 && state.filteredVenvs.length === 0) {
        list.innerHTML = '<div class="empty-state">No matching environments</div>';
        return;
      }

      let html = '';
      let globalIndex = 0;

      // Running runtimes section
      if (state.filteredRuntimes.length > 0) {
        html += '<div class="picker-section"><div class="picker-section-title">Running</div>';
        state.filteredRuntimes.forEach((rt) => {
          html += renderRuntimeItem(rt, globalIndex++);
        });
        html += '</div>';
      }

      const bySource = { system: [], project: [], recent: [], conda: [], pyenv: [], discovered: [] };
      state.filteredVenvs.forEach(v => {
        (bySource[v.source] || bySource.discovered).push(v);
      });

      // Render sections in order
      const sections = [
        { key: 'system', title: 'System' },
        { key: 'project', title: 'Project' },
        { key: 'recent', title: 'Recent' },
        { key: 'conda', title: 'Conda' },
        { key: 'pyenv', title: 'Pyenv' },
        { key: 'discovered', title: 'Discovered' },
      ];

      for (const { key, title } of sections) {
        if (bySource[key].length > 0) {
          html += `<div class="picker-section"><div class="picker-section-title">${title}</div>`;
          bySource[key].forEach(v => {
            html += renderVenvItem(v, globalIndex++);
          });
          html += '</div>';
        }
      }

      list.innerHTML = html;
    }

    function renderRuntimeItem(runtime, index) {
      const selected = index === state.selectedVenvIndex ? 'selected' : '';
      const venvDir = (runtime.venv || '').replace(/^\/home\/[^/]+/, '~');

      return `
        <div class="venv-item ${selected}" data-index="${index}" data-runtime-id="${runtime.id}"
             onclick="selectVenvItem(${index})" ondblclick="attachToRuntime('${runtime.id}')">
          <div class="venv-item-info">
            <div class="venv-item-name">${runtime.id}</div>
            <div class="venv-item-path">${venvDir} • port ${runtime.port}</div>
          </div>
          <span class="venv-item-version">pid ${runtime.pid}</span>
          <span class="venv-item-badge danger" onclick="event.stopPropagation(); killRuntimeAction('${runtime.id}')"
                style="cursor:pointer;">stop</span>
        </div>
      `;
    }

    function renderVenvItem(venv, index) {
      const selected = index === state.selectedVenvIndex ? 'selected' : '';
      const dir = venv.path.replace(/^\/home\/[^/]+/, '~');
      const isValid = venv.hasPython !== false;

      // Status: nothing if ready, "install" if needs mrmd-python, "invalid" if broken
      let status = '';
      if (!isValid) {
        status = '<span class="venv-item-badge" style="opacity:0.5">broken</span>';
      } else if (!venv.hasMrmdPython) {
        status = '<span class="venv-item-badge warning">install</span>';
      }

      return `
        <div class="venv-item ${selected}" data-index="${index}" data-path="${venv.path}"
             onclick="selectVenvItem(${index})" ondblclick="selectVenv()" style="${!isValid ? 'opacity:0.5' : ''}">
          <div class="venv-item-info">
            <div class="venv-item-name">${venv.projectName}</div>
            <div class="venv-item-path">${dir}</div>
          </div>
          ${venv.pythonVersion ? `<span class="venv-item-version">${venv.pythonVersion}</span>` : ''}
          ${status}
        </div>
      `;
    }

    function selectVenvItem(index) {
      state.selectedVenvIndex = index;
      renderVenvList();

      // Scroll selected item into view
      const selected = document.querySelector('#venv-list .venv-item.selected');
      if (selected) {
        selected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
      }
    }

    async function selectVenv() {
      const numRuntimes = state.filteredRuntimes.length;

      // Check if selected item is a running runtime
      if (state.selectedVenvIndex < numRuntimes) {
        const runtime = state.filteredRuntimes[state.selectedVenvIndex];
        return attachToRuntime(runtime.id);
      }

      // Otherwise it's a venv
      const venvIndex = state.selectedVenvIndex - numRuntimes;
      if (venvIndex >= state.filteredVenvs.length) return;

      const venv = state.filteredVenvs[venvIndex];

      // Check if valid
      if (venv.hasPython === false) {
        alert('This venv is invalid (no Python found). Please select a different one.');
        return;
      }

      hideVenvPicker();

      // Check if needs install
      if (!venv.hasMrmdPython) {
        updatePythonStatus('loading', 'Installing...');
        try {
          const installResult = await electronAPI.installMrmdPython(venv.path);
          if (!installResult.success) {
            updatePythonStatus('error', 'Install failed');
            alert('Failed to install mrmd-python: ' + installResult.error);
            return;
          }
        } catch (e) {
          updatePythonStatus('error', 'Install failed');
          alert('Failed to install mrmd-python: ' + e.message);
          return;
        }
      }

      // Start runtime
      updatePythonStatus('loading', 'Starting...');
      try {
        const result = await electronAPI.startPython(venv.path);

        if (result.success) {
          state.pythonPort = result.port;
          state.pythonVenv = { ...venv, runtimeId: result.runtimeId };
          const statusLabel = result.reused ? `${result.runtimeId} (reused)` : result.runtimeId;
          updatePythonStatus('ready', statusLabel);
          console.log(`Python ready: ${result.runtimeId} on port ${result.port}${result.reused ? ' (reused)' : ''}`);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            const docName = stripDocExtension(state.currentFile.split('/').pop());
            const pythonClient = new mrmd.MRPClient(
              `http://127.0.0.1:${result.port}/mrp/v1`,
              { languages: ['python', 'py', 'python3'] }
            );
            state.editor.registerRuntime('python', pythonClient);
            console.log('Registered Python runtime with existing editor');

            // Call pending retry callback if exists (from noRuntime prompt)
            if (window._pendingRuntimeRetry) {
              console.log('[venvPicker] Calling pending retry callback');
              const retryCallback = window._pendingRuntimeRetry;
              window._pendingRuntimeRetry = null;
              setTimeout(() => retryCallback(), 100);
            }
          }

          // Refresh runtimes list
          if (typeof refreshRuntimes === 'function') refreshRuntimes();
        } else {
          updatePythonStatus('error', 'Failed');
          alert('Failed to start Python: ' + result.error);
        }
      } catch (e) {
        updatePythonStatus('error', 'Failed');
        alert('Failed to start Python: ' + e.message);
      }
    }

    async function attachToRuntime(runtimeId, language = 'python') {
      console.log('Attaching to runtime:', runtimeId, 'language:', language);

      if (language === 'bash') {
        // Bash attach - just look up the session info
        try {
          const sessions = await electronAPI.runtime.list('bash');
          const session = sessions.find(s => s.name === runtimeId && s.alive);
          if (session) {
            state.bashPort = session.port;
            state.bashSession = { name: runtimeId, port: session.port, cwd: session.cwd };
            console.log('Attached to bash runtime on port', session.port);

            // Register bash runtime with existing editor if open (using auto-restart wrapper)
            if (state.editor && state.currentFile) {
              const bashClient = createAutoRestartingBashClient(session.port, runtimeId);
              state.editor.registerRuntime('bash', bashClient);
              console.log('Registered Bash runtime with existing editor');
            }

            // Update runtimes panel if open
            if (typeof renderRuntimesPanel === 'function') renderRuntimesPanel();
          } else {
            console.error('Bash session not found or not alive:', runtimeId);
          }
        } catch (e) {
          console.error('Failed to attach to bash runtime:', e);
        }
        return;
      }

      // Python attach (existing logic)
      hideVenvPicker();
      updatePythonStatus('loading', 'Attaching...');

      try {
        const result = await electronAPI.attachRuntime(runtimeId);
        if (result.success) {
          state.pythonPort = result.port;
          state.pythonVenv = { name: runtimeId, path: result.venv, runtimeId: runtimeId };
          updatePythonStatus('ready', runtimeId);
          console.log('Attached to runtime on port', result.port);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            const docName = stripDocExtension(state.currentFile.split('/').pop());
            const pythonClient = new mrmd.MRPClient(
              `http://127.0.0.1:${result.port}/mrp/v1`,
              { languages: ['python', 'py', 'python3'] }
            );
            state.editor.registerRuntime('python', pythonClient);
            console.log('Registered Python runtime with existing editor');

            // Call pending retry callback if exists (from noRuntime prompt)
            if (window._pendingRuntimeRetry) {
              console.log('[attachRuntime] Calling pending retry callback');
              const retryCallback = window._pendingRuntimeRetry;
              window._pendingRuntimeRetry = null;
              setTimeout(() => retryCallback(), 100);
            }
          }

          // Update runtimes panel if open
          if (typeof renderRuntimesPanel === 'function') renderRuntimesPanel();
        } else {
          updatePythonStatus('error', 'Failed');
          alert('Failed to attach: ' + result.error);
        }
      } catch (e) {
        updatePythonStatus('error', 'Failed');
        alert('Failed to attach: ' + e.message);
      }
    }

    async function startNewRuntime(venvPath) {
      console.log('Starting NEW runtime for:', venvPath);
      hideVenvPicker();
      updatePythonStatus('loading', 'Starting new...');

      try {
        const result = await electronAPI.startPython(venvPath, true); // forceNew = true

        if (result.success) {
          state.pythonPort = result.port;
          state.pythonVenv = { path: venvPath, runtimeId: result.runtimeId };
          updatePythonStatus('ready', result.runtimeId);
          console.log(`New Python runtime: ${result.runtimeId} on port ${result.port}`);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            const docName = stripDocExtension(state.currentFile.split('/').pop());
            const pythonClient = new mrmd.MRPClient(
              `http://127.0.0.1:${result.port}/mrp/v1`,
              { languages: ['python', 'py', 'python3'] }
            );
            state.editor.registerRuntime('python', pythonClient);
            console.log('Registered new Python runtime with editor');

            // Call pending retry callback if exists (from noRuntime prompt)
            if (window._pendingRuntimeRetry) {
              console.log('[startNewRuntime] Calling pending retry callback');
              const retryCallback = window._pendingRuntimeRetry;
              window._pendingRuntimeRetry = null;
              setTimeout(() => retryCallback(), 100);
            }
          }

          // Refresh runtimes list
          if (typeof refreshRuntimes === 'function') refreshRuntimes();
        } else {
          updatePythonStatus('error', 'Failed');
          alert('Failed to start Python: ' + result.error);
        }
      } catch (e) {
        updatePythonStatus('error', 'Failed');
        alert('Failed to start Python: ' + e.message);
      }
    }

    async function killRuntimeAction(runtimeId, language = 'python') {
      // Unified: all languages go through runtime.stop
      let result = await electronAPI.runtime.stop(runtimeId);
      if (result.success) {
        // Remove from running runtimes and re-filter
        state.runningRuntimes = state.runningRuntimes.filter(r => r.id !== runtimeId);
        filterVenvs(state.venvQuery);

        // If we were using this runtime, clear state AND unregister from editor
        if (language === 'python' && state.pythonVenv &&
            (state.pythonVenv.runtimeId === runtimeId || state.pythonVenv.name === runtimeId)) {
          state.pythonPort = null;
          state.pythonVenv = null;
          updatePythonStatus('', 'python');

          // Unregister from editor so it knows there's no runtime
          if (state.editor?.unregisterRuntime) {
            state.editor.unregisterRuntime('python');
            console.log('[killRuntime] Unregistered Python runtime from editor');
          }
        } else if (language === 'bash' && state.bashSession?.name === runtimeId) {
          state.bashPort = null;
          state.bashSession = null;

          if (state.editor?.unregisterRuntime) {
            state.editor.unregisterRuntime('bash');
            console.log('[killRuntime] Unregistered Bash runtime from editor');
          }
        } else if (language === 'r' && state.rSession?.name === runtimeId) {
          state.rSession = null;

          if (state.editor?.unregisterRuntime) {
            state.editor.unregisterRuntime('r');
            console.log('[killRuntime] Unregistered R runtime from editor');
          }
        } else if (language === 'julia' && state.juliaSession?.name === runtimeId) {
          state.juliaSession = null;

          if (state.editor?.unregisterRuntime) {
            state.editor.unregisterRuntime('julia');
            console.log('[killRuntime] Unregistered Julia runtime from editor');
          }
        }

        // Update hints (may show setup prompt again)
        updateSetupHints();
      }
    }

    // =========================================================================
    // PROJECT NAVIGATION (FSML Implementation)
    // =========================================================================

    // Navigation state
    const navState = {
      expandedFolders: new Set(),
      dragging: null,        // Path being dragged
      renaming: null,        // Path being renamed
      contextTarget: null,   // Path for context menu
    };

    const titleSyncState = {
      busy: false,
    };

    /**
     * Toggle folder expanded state
     */
    function toggleFolder(folderPath) {
      if (navState.expandedFolders.has(folderPath)) {
        navState.expandedFolders.delete(folderPath);
      } else {
        navState.expandedFolders.add(folderPath);
      }
      renderNavTreeFull();
    }

    /**
     * Expand all ancestors of a path
     */
    function expandToPath(filePath) {
      const parts = filePath.split('/');
      let current = '';
      for (let i = 0; i < parts.length - 1; i++) {
        current = current ? `${current}/${parts[i]}` : parts[i];
        navState.expandedFolders.add(current);
      }
    }

    /**
     * Get current file's relative path
     */
    function getCurrentRelativePath() {
      if (!state.currentFile || !state.project?.root) return null;
      return state.currentFile.replace(state.project.root + '/', '');
    }

    function humanTitleFromFilename(filename) {
      if (!filename) return '';
      const basename = stripDocExtension(filename).replace(/^\d+-/, '');
      if (!basename) return '';
      return basename
        .replace(/[-_]+/g, ' ')
        .split(/\s+/)
        .filter(Boolean)
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
    }

    function buildNewDocumentContentFromPath(filePath) {
      const filename = (filePath || '').split('/').pop() || '';
      const title = humanTitleFromFilename(filename) || 'Untitled';
      const escapedTitle = title.replace(/"/g, '\\"');
      return `---\ntitle: "${escapedTitle}"\n---\n\n# ${title}\n`;
    }

    function slugFromTitle(title) {
      if (!title) return '';
      return title
        .normalize('NFKD')
        .replace(/[\u0300-\u036f]/g, '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '')
        .replace(/-+/g, '-');
    }

    function parseFrontmatterInfo(content) {
      if (!content || !content.startsWith('---')) return null;
      const match = content.match(/^---\r?\n([\s\S]*?)\r?\n---(\r?\n|$)/);
      if (!match) return null;
      const body = match[1];
      const titleMatch = body.match(/^\s*title\s*:\s*(.+)\s*$/mi);
      const rawTitle = titleMatch ? titleMatch[1].trim() : null;
      const title = rawTitle ? rawTitle.replace(/^["']|["']$/g, '').trim() : null;
      return {
        body,
        fullMatch: match[0],
        title,
      };
    }

    function replaceFrontmatterTitle(content, newTitle) {
      const info = parseFrontmatterInfo(content);
      if (!info || !info.title) return content;
      const eol = info.fullMatch.includes('\r\n') ? '\r\n' : '\n';
      const escapedTitle = String(newTitle).replace(/"/g, '\\"');
      const nextBody = info.body.replace(
        /^\s*title\s*:\s*.+$/mi,
        `title: "${escapedTitle}"`
      );
      const nextFrontmatter = `---${eol}${nextBody}${eol}---${info.fullMatch.endsWith(eol) ? eol : ''}`;
      return content.replace(info.fullMatch, nextFrontmatter);
    }

    function shouldSyncTitleForFile(relativePath) {
      if (!relativePath) return false;
      if (relativePath === '.mrmd' || relativePath.startsWith('.mrmd/') || relativePath.includes('/.mrmd/')) {
        return false;
      }
      const filename = relativePath.split('/').pop() || '';
      const lower = filename.toLowerCase();
      if (lower === 'mrmd.md' || lower === 'index.md' || lower === 'index.qmd') return false;
      return isDocFile(filename);
    }

    function remapAbsolutePathForMove(absolutePath, fromRelativePath, toRelativePath) {
      if (!absolutePath || !state.project?.root || !fromRelativePath || !toRelativePath) return absolutePath;
      const root = state.project.root.replace(/\/+$/, '');
      const fromAbs = `${root}/${fromRelativePath}`.replace(/\/+/g, '/');
      const toAbs = `${root}/${toRelativePath}`.replace(/\/+/g, '/');

      if (absolutePath === fromAbs) return toAbs;
      if (absolutePath.startsWith(fromAbs + '/')) {
        return `${toAbs}${absolutePath.slice(fromAbs.length)}`.replace(/\/+/g, '/');
      }
      return absolutePath;
    }

    async function refreshProjectAfterNavMutation(anchorFilePath = null) {
      if (!state.project?.root) return;
      const anchor = anchorFilePath || state.currentFile || `${state.project.root}/mrmd.md`;
      const project = await electronAPI.project.get(anchor);
      if (!project) return;

      state.project = project;
      updateNavSidebar(project, state.currentFile || anchor);

      if (state.editor && project.files) {
        const parsedFiles = parseProjectFiles(project.files);
        state.editor.setProjectFiles(parsedFiles);
      }
    }

    async function maybeReopenMovedCurrentFile(fromRelativePath, toRelativePath) {
      const remapped = remapAbsolutePathForMove(state.currentFile, fromRelativePath, toRelativePath);
      const movedCurrent = Boolean(remapped && state.currentFile && remapped !== state.currentFile);
      if (!movedCurrent) return false;
      state.currentFile = remapped;
      await openFile(remapped);
      return true;
    }

    async function flushCurrentEditorToDiskIfAffected(affectedRelativePath) {
      if (!state.editor || !state.currentFile || !state.project?.root || !affectedRelativePath) return;
      const currentRelative = getCurrentRelativePath();
      if (!currentRelative) return;
      const isAffected = currentRelative === affectedRelativePath || currentRelative.startsWith(affectedRelativePath + '/');
      if (!isAffected) return;
      try {
        const content = state.editor.getContent ? state.editor.getContent() : '';
        await electronAPI.file.write(`${state.project.root}/${currentRelative}`, content);
      } catch (err) {
        console.warn('[nav] Failed to flush current editor content before move:', err.message);
      }
    }

    function syncFrontmatterTitleToCurrentFilename() {
      if (!state.editor || !state.currentFile || titleSyncState.busy) return;
      const relativePath = getCurrentRelativePath();
      if (!shouldSyncTitleForFile(relativePath)) return;

      const content = state.editor.getContent ? state.editor.getContent() : '';
      const info = parseFrontmatterInfo(content);
      if (!info || !info.title) return;

      const filename = relativePath.split('/').pop() || '';
      const desiredTitle = humanTitleFromFilename(filename);
      if (!desiredTitle || info.title === desiredTitle) return;

      const nextContent = replaceFrontmatterTitle(content, desiredTitle);
      if (nextContent === content) return;

      titleSyncState.busy = true;
      state.editor.setContent(nextContent);
      setTimeout(() => {
        titleSyncState.busy = false;
      }, 0);
    }

    async function renameCurrentFileFromFrontmatterTitle(titleValue) {
      if (titleSyncState.busy || !state.project?.root || !state.currentFile) return;

      const relativePath = getCurrentRelativePath();
      if (!shouldSyncTitleForFile(relativePath)) return;

      const normalizedTitle = String(titleValue || '').trim();
      const nextSlug = slugFromTitle(normalizedTitle);
      if (!nextSlug) return;

      const filename = relativePath.split('/').pop() || '';
      const ext = getDocExtension(filename) || '.md';
      const orderPrefix = (filename.match(/^(\d+-)/) || [])[1] || '';
      const currentSlug = stripDocExtension(filename).replace(/^\d+-/, '').toLowerCase();
      if (nextSlug === currentSlug) return;

      const parentDir = getParentPath(relativePath);
      const nextFilename = `${orderPrefix}${nextSlug}${ext}`;
      const nextRelative = parentDir ? `${parentDir}/${nextFilename}` : nextFilename;
      if (nextRelative === relativePath) return;

      try {
        titleSyncState.busy = true;
        await flushCurrentEditorToDiskIfAffected(relativePath);
        const result = await electronAPI.file.move(state.project.root, relativePath, nextRelative);
        const movedTo = result?.movedFile || nextRelative;
        const reopened = await maybeReopenMovedCurrentFile(relativePath, movedTo);
        if (!reopened) {
          await refreshProjectAfterNavMutation();
        }
      } catch (err) {
        console.warn('[title-sync] Frontmatter title rename failed:', err.message);
      } finally {
        titleSyncState.busy = false;
      }
    }

    /**
     * Render the navigation tree (incremental patching version)
     *
     * Instead of tearing down and rebuilding the entire DOM on every update,
     * this version diffs the existing DOM against the desired state and only
     * patches what changed. This avoids layout thrashing and keeps the tree
     * responsive even for large projects.
     */
    function renderNavTree(nodes, container, depth = 0) {
      const currentRelPath = getCurrentRelativePath();
      const existingItems = new Map(); // path -> { item, childContainer }

      // Index existing DOM children by path for O(1) lookup
      for (let i = 0; i < container.children.length; i++) {
        const child = container.children[i];
        const childPath = child.dataset?.path;
        if (childPath && child.classList.contains('nav-item')) {
          const nextSibling = container.children[i + 1];
          const childContainer = nextSibling?.classList?.contains('nav-children') ? nextSibling : null;
          existingItems.set(childPath, { item: child, childContainer, index: i });
        }
      }

      // Track which paths we've processed (for removal of stale entries)
      const processedPaths = new Set();
      let insertionIndex = 0;

      for (const node of nodes) {
        processedPaths.add(node.path);
        const isExpanded = navState.expandedFolders.has(node.path);
        const isSelected = node.path === currentRelPath;
        const isRenaming = node.path === navState.renaming;
        const hasChildren = node.children && node.children.length > 0;

        const existing = existingItems.get(node.path);

        if (existing) {
          // Patch existing item in-place
          const item = existing.item;
          patchNavItem(item, node, { isExpanded, isSelected, isRenaming, hasChildren, depth });

          // Move to correct position if needed
          const expectedChild = container.children[insertionIndex];
          if (expectedChild !== item) {
            container.insertBefore(item, expectedChild || null);
          }
          insertionIndex++;

          // Handle children container
          if (hasChildren && isExpanded) {
            let childContainer = existing.childContainer;
            if (!childContainer) {
              childContainer = document.createElement('div');
              childContainer.className = 'nav-children';
              childContainer.dataset.parent = node.path;
              const nextChild = container.children[insertionIndex];
              container.insertBefore(childContainer, nextChild || null);
            } else {
              // Ensure child container is in the right position
              const expectedPos = container.children[insertionIndex];
              if (expectedPos !== childContainer) {
                container.insertBefore(childContainer, expectedPos || null);
              }
            }
            childContainer.classList.remove('collapsed');
            renderNavTree(node.children, childContainer, depth + 1);
            insertionIndex++;
          } else if (existing.childContainer) {
            // Folder collapsed or no children - remove child container
            existing.childContainer.remove();
          }
        } else {
          // Create new item (node doesn't exist in DOM yet)
          const item = createNavItem(node, { isExpanded, isSelected, isRenaming, hasChildren, depth });
          const refChild = container.children[insertionIndex];
          container.insertBefore(item, refChild || null);
          insertionIndex++;

          if (hasChildren && isExpanded) {
            const childContainer = document.createElement('div');
            childContainer.className = 'nav-children';
            childContainer.dataset.parent = node.path;
            const refChild2 = container.children[insertionIndex];
            container.insertBefore(childContainer, refChild2 || null);
            renderNavTree(node.children, childContainer, depth + 1);
            insertionIndex++;
          }
        }
      }

      // Remove stale items (paths no longer in the tree)
      const toRemove = [];
      for (const [path, { item, childContainer }] of existingItems) {
        if (!processedPaths.has(path)) {
          toRemove.push(item);
          if (childContainer) toRemove.push(childContainer);
        }
      }
      for (const el of toRemove) el.remove();
    }

    /**
     * Patch an existing nav item DOM element to match new state.
     * Only touches attributes/classes that actually changed.
     * Also updates the stored node reference so event handlers use fresh data.
     */
    function patchNavItem(item, node, { isExpanded, isSelected, isRenaming, hasChildren, depth }) {
      // Store fresh node reference for event handlers
      item._navNode = node;

      // Update classes
      const wantFolder = node.isFolder;
      const hasFolder = item.classList.contains('folder');
      if (wantFolder !== hasFolder) {
        item.classList.toggle('folder', wantFolder);
      }
      const hasSelected = item.classList.contains('selected');
      if (isSelected !== hasSelected) {
        item.classList.toggle('selected', isSelected);
      }

      // Update padding
      const wantPadding = (8 + depth * 16) + 'px';
      if (item.style.paddingLeft !== wantPadding) {
        item.style.paddingLeft = wantPadding;
      }

      // Update draggable
      item.draggable = !isRenaming;

      // Update expand arrow
      const expand = item.querySelector('.nav-expand');
      if (expand) {
        const showExpand = node.isFolder && hasChildren;
        const wantClass = 'nav-expand' + (isExpanded ? ' expanded' : '') + (!showExpand ? ' hidden' : '');
        if (expand.className !== wantClass) {
          expand.className = wantClass;
        }
      }

      // Handle rename input vs label
      const existingInput = item.querySelector('.nav-rename-input');
      const existingLabel = item.querySelector('.nav-item-label');

      if (isRenaming && !existingInput) {
        // Switch from label to input
        if (existingLabel) existingLabel.remove();
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'nav-rename-input';
        input.value = node.title;
        input.dataset.path = node.path;
        input.onclick = (e) => e.stopPropagation();
        input.onkeydown = (e) => {
          if (e.key === 'Enter') finishRename(node.path, input.value);
          else if (e.key === 'Escape') cancelRename();
        };
        input.onblur = () => {
          setTimeout(() => {
            if (navState.renaming === node.path) finishRename(node.path, input.value);
          }, 100);
        };
        item.appendChild(input);
        setTimeout(() => { input.focus(); input.select(); }, 0);
      } else if (!isRenaming && existingInput) {
        // Switch from input to label
        existingInput.remove();
        const label = document.createElement('span');
        label.className = 'nav-item-label';
        label.textContent = node.title;
        item.appendChild(label);
      } else if (!isRenaming && existingLabel) {
        // Update label text if changed
        if (existingLabel.textContent !== node.title) {
          existingLabel.textContent = node.title;
        }
      }
    }

    /**
     * Create a new nav item DOM element from scratch.
     * Event handlers read from item._navNode so they always use fresh data
     * even after incremental patches.
     */
    function createNavItem(node, { isExpanded, isSelected, isRenaming, hasChildren, depth }) {
      const item = document.createElement('div');
      item._navNode = node; // Stored for event handlers
      item.className = 'nav-item' + (node.isFolder ? ' folder' : '') + (isSelected ? ' selected' : '');
      item.dataset.path = node.path;
      item.dataset.isFolder = node.isFolder ? 'true' : 'false';
      item.style.paddingLeft = (8 + depth * 16) + 'px';
      item.draggable = !isRenaming;

      // Expand arrow
      const expand = document.createElement('span');
      const showExpand = node.isFolder && hasChildren;
      expand.className = 'nav-expand' + (isExpanded ? ' expanded' : '') + (!showExpand ? ' hidden' : '');
      expand.textContent = '›';
      if (showExpand) {
        expand.onclick = (e) => {
          e.stopPropagation();
          toggleFolder(item._navNode.path);
        };
      }
      item.appendChild(expand);

      // Label or rename input
      if (isRenaming) {
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'nav-rename-input';
        input.value = node.title;
        input.dataset.path = node.path;
        input.onclick = (e) => e.stopPropagation();
        input.onkeydown = (e) => {
          if (e.key === 'Enter') finishRename(item._navNode.path, input.value);
          else if (e.key === 'Escape') cancelRename();
        };
        input.onblur = () => {
          setTimeout(() => {
            if (navState.renaming === item._navNode.path) finishRename(item._navNode.path, input.value);
          }, 100);
        };
        item.appendChild(input);
        setTimeout(() => { input.focus(); input.select(); }, 0);
      } else {
        const label = document.createElement('span');
        label.className = 'nav-item-label';
        label.textContent = node.title;
        item.appendChild(label);
      }

      // Click handler - reads from _navNode for fresh data
      item.onclick = (e) => {
        if (e.target.classList.contains('nav-expand')) return;
        const n = item._navNode;
        if (n.isFolder) {
          if (n.hasIndex) {
            const indexPath = state.project.root + '/' + n.path + '/index.md';
            openFile(indexPath);
          } else {
            toggleFolder(n.path);
          }
        } else {
          const fullPath = state.project.root + '/' + n.path;
          openFile(fullPath);
        }
      };

      // Double-click to rename
      item.ondblclick = (e) => {
        if (e.target.classList.contains('nav-expand')) return;
        e.preventDefault();
        startRename(item._navNode.path);
      };

      // Right-click context menu
      item.oncontextmenu = (e) => {
        e.preventDefault();
        const n = item._navNode;
        showNavContextMenu(e.clientX, e.clientY, n.path, n.isFolder);
      };

      // Drag handlers
      item.ondragstart = (e) => {
        navState.dragging = item._navNode.path;
        item.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', item._navNode.path);
      };

      item.ondragend = () => {
        navState.dragging = null;
        clearDropTargets();
      };

      item.ondragover = (e) => {
        e.preventDefault();
        if (navState.dragging === item._navNode.path) return;
        clearDropTargets();
        const rect = item.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const height = rect.height;
        const n = item._navNode;
        if (n.isFolder && y > height * 0.25 && y < height * 0.75) {
          item.classList.add('drop-target');
        } else if (y < height * 0.5) {
          item.classList.add('drop-above');
        } else {
          item.classList.add('drop-below');
        }
        e.dataTransfer.dropEffect = 'move';
      };

      item.ondragleave = () => {
        item.classList.remove('drop-target', 'drop-above', 'drop-below');
      };

      item.ondrop = async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const fromPath = navState.dragging;
        const n = item._navNode;
        if (!fromPath || fromPath === n.path) {
          clearDropTargets();
          return;
        }
        const rect = item.getBoundingClientRect();
        const y = e.clientY - rect.top;
        const height = rect.height;
        let dropType = 'below';
        if (n.isFolder && y > height * 0.25 && y < height * 0.75) {
          dropType = 'into';
        } else if (y < height * 0.5) {
          dropType = 'above';
        }
        clearDropTargets();
        navState.dragging = null;
        await handleNavDrop(fromPath, n.path, dropType, n.isFolder);
      };

      return item;
    }

    /**
     * Clear all drop target classes
     */
    function clearDropTargets() {
      document.querySelectorAll('.nav-item.drop-target, .nav-item.drop-above, .nav-item.drop-below, .nav-item.dragging')
        .forEach(el => el.classList.remove('drop-target', 'drop-above', 'drop-below', 'dragging'));
    }

    /**
     * Handle drop operation - reorder file with FSML conventions
     *
     * Uses FileService.reorder() which leverages FSML.computeNewPath()
     * to handle proper FSML ordering and sibling renumbering.
     */
    async function handleNavDrop(fromPath, toPath, dropType, toIsFolder) {
      if (!state.project?.root) return;

      // Don't drop on self
      if (fromPath === toPath) {
        console.log('Nav drop: same item, skipping');
        return;
      }

      // Map dropType to FSML position
      let position;
      if (dropType === 'into' && toIsFolder) {
        position = 'inside';
      } else if (dropType === 'above') {
        position = 'before';
      } else {
        position = 'after';
      }

      console.log(`Nav drop: ${fromPath} -> ${toPath} (${position})`);

      try {
        await flushCurrentEditorToDiskIfAffected(fromPath);
        // Use FileService.reorder which uses FSML.computeNewPath for proper ordering
        const result = await electronAPI.file.reorder(
          state.project.root,
          fromPath,
          toPath,
          position
        );

        console.log('Reorder result:', result);
        const movedTo = result?.movedFile || fromPath;
        const reopened = await maybeReopenMovedCurrentFile(fromPath, movedTo);
        if (!reopened) {
          await refreshProjectAfterNavMutation();
        }
      } catch (e) {
        console.error('Reorder failed:', e);
        alert('Failed to reorder: ' + e.message);
      }
    }

    /**
     * Start inline rename
     */
    function startRename(path) {
      navState.renaming = path;
      renderNavTreeFull();
    }

    /**
     * Cancel rename
     */
    function cancelRename() {
      navState.renaming = null;
      renderNavTreeFull();
    }

    /**
     * Finish rename - move file to new name
     */
    async function finishRename(oldPath, newTitle) {
      if (!navState.renaming || !state.project?.root) {
        navState.renaming = null;
        return;
      }

      navState.renaming = null;

      // Parse the old path to get directory and extract order prefix
      const lastSlash = oldPath.lastIndexOf('/');
      const dir = lastSlash >= 0 ? oldPath.substring(0, lastSlash) : '';
      const oldFilename = lastSlash >= 0 ? oldPath.substring(lastSlash + 1) : oldPath;

      // Extract order prefix if present (e.g., "01-" from "01-intro.md")
      const orderMatch = oldFilename.match(/^(\d+-)/);
      const orderPrefix = orderMatch ? orderMatch[1] : '';

      // Build new filename
      const extMatch = oldFilename.match(/\.[^.]+$/);
      const extension = extMatch ? extMatch[0] : '';
      const isFolder = !extMatch;

      // Convert title to filename (lowercase kebab-case)
      const newSlug = slugFromTitle(newTitle);
      if (!newSlug) {
        renderNavTreeFull();
        return;
      }
      const newFilename = orderPrefix + newSlug + (isFolder ? '' : extension);
      const newPath = dir ? `${dir}/${newFilename}` : newFilename;

      if (newPath === oldPath) {
        renderNavTreeFull();
        return;
      }

      console.log(`Rename: ${oldPath} -> ${newPath}`);

      try {
        await flushCurrentEditorToDiskIfAffected(oldPath);
        const result = await electronAPI.file.move(state.project.root, oldPath, newPath);
        const movedTo = result?.movedFile || newPath;
        const reopened = await maybeReopenMovedCurrentFile(oldPath, movedTo);
        if (!reopened) {
          await refreshProjectAfterNavMutation();
        } else {
          syncFrontmatterTitleToCurrentFilename();
        }
      } catch (e) {
        console.error('Rename failed:', e);
        alert('Failed to rename: ' + e.message);
        renderNavTreeFull();
      }
    }

    /**
     * Show context menu
     */
    function showNavContextMenu(x, y, path, isFolder) {
      navState.contextTarget = { path, isFolder };

      const menu = document.getElementById('nav-context-menu');
      menu.style.left = x + 'px';
      menu.style.top = y + 'px';
      menu.classList.add('visible');

      // Close on click outside
      const closeHandler = (e) => {
        if (!menu.contains(e.target)) {
          hideNavContextMenu();
          document.removeEventListener('click', closeHandler);
        }
      };
      setTimeout(() => document.addEventListener('click', closeHandler), 0);
    }

    /**
     * Hide context menu
     */
    function hideNavContextMenu() {
      document.getElementById('nav-context-menu').classList.remove('visible');
      navState.contextTarget = null;
    }

    /**
     * Handle context menu action
     */
    async function handleNavContextAction(action) {
      const target = navState.contextTarget;
      hideNavContextMenu();

      if (!target || !state.project?.root) return;

      switch (action) {
        case 'new-file':
          await createNavFile(target.isFolder ? target.path : getParentPath(target.path));
          break;
        case 'new-folder':
          await createNavFolder(target.isFolder ? target.path : getParentPath(target.path));
          break;
        case 'rename':
          startRename(target.path);
          break;
        case 'reveal':
          const fullPath = state.project.root + '/' + target.path;
          electronAPI.shell.showItemInFolder(fullPath);
          break;
        case 'delete':
          await deleteNavItem(target.path);
          break;
      }
    }

    /**
     * Get parent path
     */
    function getParentPath(path) {
      const lastSlash = path.lastIndexOf('/');
      return lastSlash >= 0 ? path.substring(0, lastSlash) : '';
    }

    /**
     * Create new file in nav with default name, then start inline rename
     */
    async function createNavFile(parentPath) {
      // Use default name - user can rename inline after creation
      const fileName = 'untitled.md';
      const relativePath = parentPath ? `${parentPath}/${fileName}` : fileName;

      try {
        const content = buildNewDocumentContentFromPath(relativePath);
        const result = await electronAPI.file.createInProject(state.project.root, relativePath, content);

        if (!result.success) {
          console.error('Create file failed:', result.error);
          return;
        }

        const actualPath = result.path;

        // Expand parent folder
        if (parentPath) {
          navState.expandedFolders.add(parentPath);
        }

        // Open the new file
        await openFile(state.project.root + '/' + actualPath);
        startRename(actualPath);
      } catch (e) {
        console.error('Create file failed:', e);
      }
    }

    /**
     * Create new folder in nav with default name, then start inline rename
     */
    async function createNavFolder(parentPath) {
      // Use default name
      const name = 'new-folder';
      const folderPath = parentPath ? `${parentPath}/${name}` : name;
      const indexPath = `${folderPath}/index.md`;

      try {
        const content = buildNewDocumentContentFromPath(indexPath);
        const result = await electronAPI.file.createInProject(state.project.root, indexPath, content);

        if (!result.success) {
          console.error('Create folder failed:', result.error);
          return;
        }

        // Extract actual folder path from the result (in case FSML added ordering prefix)
        const actualIndexPath = result.path;
        const actualFolderPath = actualIndexPath.replace(/\/index\.md$/, '');

        // Expand parent and new folder
        if (parentPath) {
          navState.expandedFolders.add(parentPath);
        }
        navState.expandedFolders.add(actualFolderPath);

        // Refresh project
        await refreshProjectAfterNavMutation();

        // Start inline rename for the new folder
        navState.renaming = actualFolderPath;
        renderNavTreeFull();
      } catch (e) {
        console.error('Create folder failed:', e);
      }
    }

    /**
     * Delete nav item
     */
    async function deleteNavItem(path) {
      const isFolder = !path.includes('.') || path.endsWith('/');
      const confirmMsg = isFolder
        ? `Delete folder "${path}" and all its contents?`
        : `Delete "${path}"?`;

      if (!confirm(confirmMsg)) return;

      try {
        const fullPath = state.project.root + '/' + path;
        await electronAPI.file.delete(fullPath);

        // If we deleted the current file, clear it
        if (state.currentFile && state.currentFile.startsWith(fullPath)) {
          // Try to open another file or just clear
          state.currentFile = null;
        }

        // Refresh
        const project = await electronAPI.project.get(state.project.root + '/mrmd.md');
        state.project = project;
        renderNavTreeFull();
      } catch (e) {
        console.error('Delete failed:', e);
        alert('Failed to delete: ' + e.message);
      }
    }

    /**
     * Full render of nav tree (now uses incremental patching)
     *
     * This no longer clears innerHTML - renderNavTree diffs the existing
     * DOM and only patches what changed.
     */
    function renderNavTreeFull() {
      const tree = document.getElementById('nav-tree');
      if (!tree || !state.project?.navTree) return;

      renderNavTree(state.project.navTree, tree, 0);
    }

    /**
     * Update the navigation sidebar
     */
    function updateNavSidebar(project, currentFilePath) {
      const sidebar = document.getElementById('nav-sidebar');
      const title = document.getElementById('nav-title');

      if (!project) {
        sidebar.classList.remove('visible');
        return;
      }

      // Show sidebar
      sidebar.classList.add('visible');
      // Use config name, or fallback to folder name
      const folderName = project.root.split('/').pop() || 'Project';
      title.textContent = project.config?.name || folderName;

      // Auto-expand to current file
      if (currentFilePath) {
        const relativePath = currentFilePath.replace(project.root + '/', '');
        expandToPath(relativePath);
      }

      // Render tree
      renderNavTreeFull();

      console.log('Nav sidebar updated:', project.navTree.length, 'top-level items');
    }

    // Context menu click handler
    document.getElementById('nav-context-menu').addEventListener('click', (e) => {
      const item = e.target.closest('.nav-context-item');
      if (item) {
        handleNavContextAction(item.dataset.action);
      }
    });

    // Header config button - opens mrmd.md
    document.getElementById('nav-config-btn').addEventListener('click', () => {
      if (state.project?.root) {
        openFile(state.project.root + '/mrmd.md');
      }
    });

    // Make project title clickable to open root index.md
    document.getElementById('nav-title').addEventListener('click', () => {
      if (state.project?.root) {
        openFile(state.project.root + '/index.md');
      }
    });

    // Header new button
    document.getElementById('nav-new-btn').addEventListener('click', () => {
      createNavFile('');
    });

    // =========================================================================
    // SIDEBAR TOGGLE HANDLERS
    // =========================================================================

    // Nav sidebar toggle
    document.getElementById('nav-toggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const sidebar = document.getElementById('nav-sidebar');
      const toggle = document.getElementById('nav-toggle');
      const floatingToggle = document.getElementById('nav-toggle-floating');
      sidebar.classList.add('collapsed');
      sidebar.classList.remove('visible');
      toggle.textContent = '›';
      floatingToggle.classList.add('visible');
      localStorage.setItem('mrmd-nav-collapsed', 'true');
    });

    document.getElementById('nav-toggle-floating').addEventListener('click', () => {
      const sidebar = document.getElementById('nav-sidebar');
      const toggle = document.getElementById('nav-toggle');
      const floatingToggle = document.getElementById('nav-toggle-floating');
      sidebar.classList.remove('collapsed');
      sidebar.classList.add('visible');
      toggle.textContent = '‹';
      floatingToggle.classList.remove('visible');
      localStorage.setItem('mrmd-nav-collapsed', 'false');
    });

    // TOC sidebar toggle
    document.getElementById('toc-toggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const sidebar = document.getElementById('toc-sidebar');
      const toggle = document.getElementById('toc-toggle');
      const floatingToggle = document.getElementById('toc-toggle-floating');
      sidebar.classList.add('collapsed');
      toggle.textContent = '‹';
      floatingToggle.classList.add('visible');
      localStorage.setItem('mrmd-toc-collapsed', 'true');
    });

    document.getElementById('toc-toggle-floating').addEventListener('click', () => {
      const sidebar = document.getElementById('toc-sidebar');
      const toggle = document.getElementById('toc-toggle');
      const floatingToggle = document.getElementById('toc-toggle-floating');
      sidebar.classList.remove('collapsed');
      toggle.textContent = '›';
      floatingToggle.classList.remove('visible');
      localStorage.setItem('mrmd-toc-collapsed', 'false');
    });

    // Restore sidebar states on load
    if (localStorage.getItem('mrmd-nav-collapsed') === 'true') {
      const sidebar = document.getElementById('nav-sidebar');
      const toggle = document.getElementById('nav-toggle');
      sidebar.classList.add('collapsed');
      toggle.textContent = '›';
      document.getElementById('nav-toggle-floating').classList.add('visible');
    }
    if (localStorage.getItem('mrmd-toc-collapsed') === 'true') {
      const sidebar = document.getElementById('toc-sidebar');
      const toggle = document.getElementById('toc-toggle');
      sidebar.classList.add('collapsed');
      toggle.textContent = '‹';
      document.getElementById('toc-toggle-floating').classList.add('visible');
    }

    // =========================================================================
    // NOTEBOOK HANDLING
    // =========================================================================

    /**
     * Show notebook open dialog and return user's choice
     * @param {string} ipynbPath - Path to the .ipynb file
     * @returns {Promise<'convert'|'sync'|null>} User's choice or null if cancelled
     */
    function showNotebookDialog(ipynbPath) {
      return new Promise((resolve) => {
        const overlay = document.getElementById('notebook-dialog-overlay');
        const filenameEl = document.getElementById('notebook-dialog-filename');
        const convertBtn = document.getElementById('notebook-convert-btn');
        const syncBtn = document.getElementById('notebook-sync-btn');
        const cancelBtn = document.getElementById('notebook-cancel-btn');

        // Show filename
        filenameEl.textContent = ipynbPath.split('/').pop();

        // Cleanup function
        const cleanup = () => {
          overlay.classList.remove('visible');
          convertBtn.onclick = null;
          syncBtn.onclick = null;
          cancelBtn.onclick = null;
          overlay.onclick = null;
        };

        convertBtn.onclick = () => { cleanup(); resolve('convert'); };
        syncBtn.onclick = () => { cleanup(); resolve('sync'); };
        cancelBtn.onclick = () => { cleanup(); resolve(null); };

        // Close on backdrop click
        overlay.onclick = (e) => {
          if (e.target === overlay) { cleanup(); resolve(null); }
        };

        overlay.classList.add('visible');
      });
    }

    /**
     * Convert notebook to markdown (deletes the .ipynb file)
     * @param {string} ipynbPath - Path to the .ipynb file
     * @returns {Promise<string|null>} Path to created .md file, or null if cancelled/failed
     */
    async function convertNotebookToMd(ipynbPath) {
      const confirmed = confirm(
        'This will convert the notebook to markdown and DELETE the .ipynb file.\n\n' +
        'This action cannot be undone. Continue?'
      );

      if (!confirmed) return null;

      try {
        const result = await electronAPI.notebook.convert(ipynbPath);
        if (!result.success) {
          alert('Conversion failed: ' + result.error);
          return null;
        }
        return result.mdPath;
      } catch (e) {
        alert('Conversion failed: ' + e.message);
        return null;
      }
    }

    /**
     * Start notebook sync (creates shadow .md file in .mrmd folder)
     * @param {string} ipynbPath - Path to the .ipynb file
     * @returns {Promise<string|null>} Path to shadow .md file, or null if failed
     */
    async function startNotebookSync(ipynbPath) {
      try {
        console.log('[notebook] startNotebookSync called with:', ipynbPath);
        const result = await electronAPI.notebook.startSync(ipynbPath);
        console.log('[notebook] startSync result:', result);
        if (!result.success) {
          alert('Failed to start notebook sync: ' + result.error);
          return null;
        }

        // Track the synced notebook
        console.log('[notebook] Adding to syncedNotebooks: key=', result.shadowPath, 'value=', ipynbPath);
        state.syncedNotebooks.set(result.shadowPath, ipynbPath);

        return result.shadowPath;
      } catch (e) {
        alert('Failed to start notebook sync: ' + e.message);
        return null;
      }
    }

    // =========================================================================
    // OPEN FILE
    // =========================================================================

    async function openFile(filePath) {
      // Normalize path - remove double slashes
      filePath = filePath.replace(/\/+/g, '/');
      console.log('Opening file:', filePath);
      titleSyncState.busy = false;

      // Cleanup: Stop any synced notebook bridge if we're switching away from it
      if (state.currentFile && state.syncedNotebooks.has(state.currentFile)) {
        const ipynbPath = state.syncedNotebooks.get(state.currentFile);
        // Only stop if we're not reopening the same notebook
        let isReopening = false;
        if (filePath.endsWith('.ipynb') && filePath === ipynbPath) {
          isReopening = true;
        }
        if (!isReopening && filePath !== state.currentFile) {
          console.log('Stopping notebook sync for:', ipynbPath);
          await electronAPI.notebook.stopSync(ipynbPath);
          state.syncedNotebooks.delete(state.currentFile);
        }
      }

      // Handle shadow .md files in .mrmd folder - auto-start sync
      if (filePath.includes('/.mrmd/') && filePath.endsWith('.md')) {
        const ipynbPath = filePath
          .replace('/.mrmd/', '/')
          .replace(/\.md$/, '.ipynb');

        // Check if corresponding .ipynb exists
        try {
          const fileInfo = await electronAPI.getFileInfo(ipynbPath);
          if (fileInfo.success) {
            console.log('Opening shadow file, starting sync for:', ipynbPath);
            const shadowPath = await startNotebookSync(ipynbPath);
            if (shadowPath) {
              filePath = shadowPath;
            }
          }
        } catch (e) {
          // .ipynb doesn't exist, just open the .md normally
          console.log('No corresponding .ipynb found, opening .md directly');
        }
      }

      // Handle Jupyter notebooks
      if (filePath.endsWith('.ipynb')) {
        // Check if already synced
        for (const [shadowPath, ipynb] of state.syncedNotebooks) {
          if (ipynb === filePath) {
            console.log('Notebook already synced, opening shadow:', shadowPath);
            filePath = shadowPath;
            break;
          }
        }

        // If still an .ipynb (not already synced), show dialog
        if (filePath.endsWith('.ipynb')) {
          const mode = await showNotebookDialog(filePath);
          if (!mode) return; // Cancelled

          if (mode === 'convert') {
            const mdPath = await convertNotebookToMd(filePath);
            if (!mdPath) return; // Conversion failed or cancelled
            filePath = mdPath;
          } else {
            const shadowPath = await startNotebookSync(filePath);
            if (!shadowPath) return; // Sync failed
            filePath = shadowPath;
          }
        }
      }

      document.getElementById('titlebar-title').textContent = 'Opening...';

      try {
        // === NEW: Get project info from service ===
        const project = await electronAPI.project.get(filePath);
        state.project = project;

        if (project) {
          console.log('Project detected:', project.root);
          console.log('Config:', project.config);
          console.log('Files:', project.files.length);
          console.log('NavTree:', project.navTree);
          updateNavSidebar(project, filePath);

          // Start watching for file changes
          electronAPI.project.watch(project.root);
        } else {
          console.log('No project found (standalone file)');
          updateNavSidebar(null);
          electronAPI.project.unwatch();
        }
        // === END NEW ===

        const result = await electronAPI.openFile(filePath);

        if (!result.success) {
          alert('Failed to open file: ' + (result.error || 'Unknown error'));
          return;
        }

        const { syncPort, docName, projectDir } = result;
        state.projectDir = projectDir;

        console.log('Sync on port', syncPort, 'doc:', docName);

        // Create drive
        if (state.drive) state.drive.destroy?.();
        state.drive = mrmd.drive(`ws://127.0.0.1:${syncPort}`);

        // Destroy existing editor
        if (state.editor) {
          state.variablesCellCompleteUnsub?.();
          state.variablesCellCompleteUnsub = null;
          state.variablesCellErrorUnsub?.();
          state.variablesCellErrorUnsub = null;
          // Clear cursor from awareness before destroying to prevent stale cursors
          // appearing as "anonymous" when navigating back to this document
          if (state.editor.awareness) {
            state.editor.awareness.setLocalStateField('cursor', null);
          }
          detachSyncStatusHandlers();
          state.editor.destroy?.();
          state.editor = null;
          document.getElementById('editor').innerHTML = '';
        }

        // Editor options
        const currentTheme = localStorage.getItem('mrmd-theme') || 'daylight';
        const editorOptions = {
          theme: currentTheme,
          cellControls: {
            enabled: true,
            position: 'line-start',
            buttons: { run: true, stop: true, clear: true },
            callbacks: {
              // Terminal launch callback - calls global handler set up by registerPtyWithEditor
              onLaunchTerminal: (block, blockIndex) => {
                if (window._mrmdLaunchTerminal) {
                  window._mrmdLaunchTerminal(block, blockIndex);
                } else {
                  console.warn('[cell-controls] Terminal launcher not ready');
                }
              },
            },
          },
          // Run JS in main window context (full DOM/console access)
          javascriptIsolation: 'none',
        };

        // Create JavaScript/HTML/CSS runtime (always available - runs in browser)
        // Isolation: 'none' = main window context (full DOM access), 'iframe' = sandboxed
        const jsRuntime = mrmd.createJavaScriptRuntime({
          defaultIsolation: editorOptions.javascriptIsolation === 'none' ? 'none' : 'iframe',
        });
        editorOptions.runtimes = { javascript: jsRuntime };
        state.jsRuntime = jsRuntime;

        // Add Python runtime if available
        if (state.pythonPort) {
          const runtimeDocName = stripDocExtension(filePath.split('/').pop());
          const pythonClient = new mrmd.MRPClient(
            `http://127.0.0.1:${state.pythonPort}/mrp/v1`,
            { languages: ['python', 'py', 'python3'] }
          );
          editorOptions.runtimes.python = pythonClient;
        }

        // Open document
        state.editor = await state.drive.open(docName, '#editor', editorOptions);
        attachSyncStatusHandlers(state.editor);
        state.currentFile = filePath;

        // Bidirectional title<->filename sync (frontmatter title only)
        if (typeof state.editor.onFrontmatterTitleCommit === 'function') {
          state.editor.onFrontmatterTitleCommit((title) => {
            renameCurrentFileFromFrontmatterTitle(title).catch((err) => {
              console.warn('[title-sync] Frontmatter commit rename failed:', err.message);
            });
          });
        }
        syncFrontmatterTitleToCurrentFilename();

        // Add runtime CodeLens extensions for yaml config blocks
        addRuntimeCodeLensToEditor(state.editor);

        // Setup handler for "no runtime" event (shows inline prompt)
        setupNoRuntimeHandler(state.editor);

        // Add AI integration extensions for visual feedback
        addAiIntegrationToEditor(state.editor);

        // Add Ctrl-K and comment syntax extensions (if AI client is connected)
        addCtrlKAndCommentExtensions();

        // Add image paste handler for the editor
        setupImagePasteHandler(state.editor, filePath);

        // Setup asset URL resolver so images load correctly
        setupAssetResolver(state.editor, filePath);

        // Setup asset handler for saving plots/images from code execution
        setupExecutionAssetHandler(state.editor, filePath);

        // Setup view source handler (F12)
        state.editor.onViewSource(showSource);

        // Setup artifact panel execution hook
        setupArtifactExecutionHook();
        setupVariablesAutoRefresh();

        // Setup wiki-link completion with project files
        if (project && project.files) {
          const parsedFiles = parseProjectFiles(project.files);
          state.editor.setProjectFiles(parsedFiles);
          console.log(`Wiki-link completion enabled with ${parsedFiles.length} files`);
        }

        // Setup link navigation handlers
        setupLinkNavigation(state.editor, filePath, project);

        // Update UI
        document.getElementById('editor-container').style.display = 'block';

        // Show notebook indicator if this is a synced notebook
        console.log('[notebook] Checking sync status for filePath:', filePath);
        console.log('[notebook] syncedNotebooks keys:', [...state.syncedNotebooks.keys()]);
        const isNotebookSync = state.syncedNotebooks.has(filePath);
        console.log('[notebook] isNotebookSync:', isNotebookSync);
        if (isNotebookSync) {
          const ipynbPath = state.syncedNotebooks.get(filePath);
          document.getElementById('titlebar-title').textContent = ipynbPath.split('/').pop() + ' (synced)';
          document.getElementById('status-file').textContent = ipynbPath.replace(/^\/home\/[^/]+/, '~') + ' ↔ .md';
        } else {
          document.getElementById('titlebar-title').textContent = filePath.split('/').pop();
          document.getElementById('status-file').textContent = filePath.replace(/^\/home\/[^/]+/, '~');
        }

        // Initialize Table of Contents
        initializeTOC();

        console.log('File opened successfully');

        // Check for missing configuration and show hints
        updateSetupHints();

        // Resolve session from project config and auto-start if configured
        await resolveProjectSession();

        // Register global bash runtime (always available)
        registerBashWithEditor();

        // Register R runtime if available
        registerRWithEditor();

        // Register Julia runtime if available
        registerJuliaWithEditor();

        // Register PTY for terminal blocks (```term)
        registerPtyWithEditor();

      } catch (e) {
        console.error('Error opening file:', e);
        alert('Error: ' + e.message);
      }
    }

    // =========================================================================
    // SIDE RAIL SYSTEM
    // =========================================================================

    const railState = {
      open: false,
      activePanel: null,
      pinnedPanel: null,  // Panel ID that is pinned
    };

    /**
     * Initialize the side rail system
     */
    function initSideRail() {
      const toggle = document.getElementById('rail-toggle');
      const rail = document.getElementById('side-rail');

      // Toggle button toggles the rail
      toggle?.addEventListener('click', () => {
        if (railState.open) {
          closeRail();
        } else {
          openRail();
        }
      });

      // Panel buttons
      document.querySelectorAll('.rail-btn[data-panel]').forEach(btn => {
        btn.addEventListener('click', () => {
          const panelId = btn.dataset.panel;
          togglePanel(panelId);
        });
      });

      // Close panel buttons
      document.querySelectorAll('[data-close-panel]').forEach(btn => {
        btn.addEventListener('click', () => {
          const panelId = btn.dataset.closePanel;
          unpinPanel(); // Unpin if pinned
          closePanel(panelId);
        });
      });

      // Pin panel buttons
      document.querySelectorAll('[data-pin-panel]').forEach(btn => {
        btn.addEventListener('click', () => {
          const panelId = btn.dataset.pinPanel;
          if (railState.pinnedPanel === panelId) {
            unpinPanel();
          } else {
            pinPanel(panelId);
          }
        });
      });

      // Keyboard shortcut: Ctrl+\ to toggle rail
      document.addEventListener('keydown', (e) => {
        if (e.ctrlKey && e.key === '\\') {
          e.preventDefault();
          if (railState.open) {
            closeRail();
          } else {
            openRail();
          }
        }
        // Escape closes active panel or rail
        if (e.key === 'Escape') {
          if (railState.activePanel) {
            closePanel(railState.activePanel);
          } else if (railState.open) {
            closeRail();
          }
        }
      });
    }

    /**
     * Open the side rail
     */
    function openRail() {
      const toggle = document.getElementById('rail-toggle');
      const rail = document.getElementById('side-rail');
      const content = document.querySelector('.content');

      railState.open = true;
      toggle?.classList.add('active');
      rail?.classList.add('open');
      content?.classList.add('rail-open');
    }

    /**
     * Close the side rail
     */
    function closeRail() {
      const toggle = document.getElementById('rail-toggle');
      const rail = document.getElementById('side-rail');
      const content = document.querySelector('.content');

      // Close any open panel first
      if (railState.activePanel) {
        closePanel(railState.activePanel);
      }

      railState.open = false;
      toggle?.classList.remove('active');
      rail?.classList.remove('open');
      content?.classList.remove('rail-open');
    }

    /**
     * Toggle a panel
     */
    function togglePanel(panelId) {
      if (railState.activePanel === panelId) {
        closePanel(panelId);
      } else {
        openPanel(panelId);
      }
    }

    /**
     * Open a panel
     */
    function openPanel(panelId) {
      // Close current panel if different
      if (railState.activePanel && railState.activePanel !== panelId) {
        closePanel(railState.activePanel);
      }

      const panel = document.getElementById(`panel-${panelId}`);
      const btn = document.querySelector(`.rail-btn[data-panel="${panelId}"]`);

      panel?.classList.add('open');
      btn?.classList.add('active');
      railState.activePanel = panelId;

      // Update settings theme display if settings panel
      if (panelId === 'settings') {
        const themeEl = document.getElementById('settings-theme');
        const statusTheme = document.getElementById('status-theme');
        if (themeEl && statusTheme) {
          themeEl.textContent = statusTheme.textContent;
        }
      }
    }

    /**
     * Close a panel
     */
    function closePanel(panelId) {
      const panel = document.getElementById(`panel-${panelId}`);
      const btn = document.querySelector(`.rail-btn[data-panel="${panelId}"]`);

      panel?.classList.remove('open');
      btn?.classList.remove('active');

      if (railState.activePanel === panelId) {
        railState.activePanel = null;
      }
    }

    /**
     * Pin a panel — keeps it open and pushes editor content left
     */
    function pinPanel(panelId) {
      const content = document.querySelector('.content');
      const panel = document.getElementById(`panel-${panelId}`);
      const pinBtn = panel?.querySelector(`[data-pin-panel="${panelId}"]`);

      // Unpin previous if different
      if (railState.pinnedPanel && railState.pinnedPanel !== panelId) {
        unpinPanel();
      }

      railState.pinnedPanel = panelId;
      panel?.classList.add('pinned');
      pinBtn?.classList.add('active');

      // Check if panel is wide variant
      const isWide = panel?.classList.contains('rail-panel-wide') ||
                     panel?.classList.contains('rail-panel-artifact');
      content?.classList.remove('panel-pinned', 'panel-pinned-wide');
      content?.classList.add(isWide ? 'panel-pinned-wide' : 'panel-pinned');
    }

    /**
     * Unpin the currently pinned panel
     */
    function unpinPanel() {
      if (!railState.pinnedPanel) return;

      const content = document.querySelector('.content');
      const panel = document.getElementById(`panel-${railState.pinnedPanel}`);
      const pinBtn = panel?.querySelector(`[data-pin-panel="${railState.pinnedPanel}"]`);

      panel?.classList.remove('pinned');
      pinBtn?.classList.remove('active');
      content?.classList.remove('panel-pinned', 'panel-pinned-wide');

      railState.pinnedPanel = null;
    }

    // Initialize rail on page load
    document.addEventListener('DOMContentLoaded', () => {
      initSideRail();
    });

    // =========================================================================
    // MOBILE NAVIGATION
    // On narrow screens, the titlebar button becomes a hamburger that opens
    // the nav sidebar as a full-screen slide-over overlay (Quarto/Astro pattern).
    // =========================================================================

    let mobileNavOpen = false;
    let mobileNavScrim = null;

    function isMobileLayout() {
      return window.matchMedia('(max-width: 768px)').matches;
    }

    function openMobileNav() {
      if (mobileNavOpen) return;
      mobileNavOpen = true;

      const sidebar = document.getElementById('nav-sidebar');
      if (!sidebar) return;

      sidebar.classList.add('mobile-open');

      // Create scrim backdrop
      mobileNavScrim = document.createElement('div');
      mobileNavScrim.className = 'mobile-nav-scrim';
      mobileNavScrim.addEventListener('click', closeMobileNav);
      document.body.appendChild(mobileNavScrim);

      // Prevent body scrolling while nav is open
      document.body.style.overflow = 'hidden';
    }

    function closeMobileNav() {
      if (!mobileNavOpen) return;
      mobileNavOpen = false;

      const sidebar = document.getElementById('nav-sidebar');
      sidebar?.classList.remove('mobile-open');

      if (mobileNavScrim) {
        mobileNavScrim.remove();
        mobileNavScrim = null;
      }

      document.body.style.overflow = '';
    }

    function toggleMobileNav() {
      if (mobileNavOpen) {
        closeMobileNav();
      } else {
        openMobileNav();
      }
    }

    // =========================================================================
    // MOBILE VISUAL VIEWPORT TRACKING
    // The virtual keyboard on phones shrinks the visual viewport but CSS `vh`
    // still refers to the full layout viewport. We track the visual viewport
    // height via a CSS custom property so panels stay above the keyboard.
    // =========================================================================
    if (typeof window.visualViewport !== 'undefined') {
      function updateMobileVh() {
        const vh = window.visualViewport.height;
        document.documentElement.style.setProperty('--mobile-vh', `${vh}px`);
      }
      window.visualViewport.addEventListener('resize', updateMobileVh);
      window.visualViewport.addEventListener('scroll', updateMobileVh);
      updateMobileVh();
    }

    // Wire up mobile titlebar buttons
    document.addEventListener('DOMContentLoaded', () => {

      // ---- Hamburger → nav sidebar ----
      document.getElementById('mobile-nav-btn')?.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleMobileNav();
      });

      // ---- Search → file picker (Ctrl+P equivalent) ----
      document.getElementById('mobile-search-btn')?.addEventListener('click', (e) => {
        e.stopPropagation();
        if (typeof showFilePicker === 'function') showFilePicker();
      });

      // ---- Image upload (camera/gallery picker) ----
      const imageBtn = document.getElementById('mobile-image-btn');
      const imageInput = document.getElementById('mobile-image-input');
      imageBtn?.addEventListener('click', (e) => {
        e.stopPropagation();
        imageInput?.click();
      });
      imageInput?.addEventListener('change', async (e) => {
        const file = e.target.files?.[0];
        if (!file || !file.type.startsWith('image/')) return;

        const view = state.editor?.view;
        const projectRoot = state.project?.root;
        if (!view || !projectRoot) return;

        try {
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);

          const ext = file.type.split('/')[1]?.replace('jpeg', 'jpg') || 'png';
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const filename = `photo-${timestamp}.${ext}`;

          console.log(`[MobileImage] Saving ${filename} (${uint8Array.length} bytes)`);

          const result = await electronAPI.asset.save(projectRoot, uint8Array, filename);
          const relativeDocPath = state.currentFile.replace(projectRoot + '/', '');
          const relativePath = await electronAPI.asset.relativePath(result.path, relativeDocPath);

          const pos = view.state.selection.main.head;
          const altText = filename.replace(/\.[^.]+$/, '');
          const markdown = `![${altText}](${relativePath})\n`;
          view.dispatch({
            changes: { from: pos, insert: markdown },
            selection: { anchor: pos + markdown.length },
          });

          console.log(`[MobileImage] Inserted: ${markdown.trim()}`);
        } catch (err) {
          console.error('[MobileImage] Error:', err);
          alert('Failed to upload image: ' + err.message);
        }

        // Reset input so the same file can be selected again
        imageInput.value = '';
      });

      // ---- AI → Ctrl+K modal ----
      document.getElementById('mobile-ai-btn')?.addEventListener('click', (e) => {
        e.stopPropagation();
        const view = state.editor?.view;
        if (!view) return;

        // Check if AI client exists (set by connectToAI)
        if (!aiClient) {
          // No AI connected — open the AI settings so user can add keys
          const aiSettingsBtn = document.getElementById('ai-settings-btn');
          if (aiSettingsBtn) aiSettingsBtn.click();
          else { openPanel('ai'); addMobileRailScrim('ai'); }
          return;
        }

        // Focus editor and scroll cursor into view
        view.focus();
        view.dispatch({ scrollIntoView: true });

        // Wait for focus + scroll + keyboard layout to fully settle
        setTimeout(() => {
          const ctrlK = mrmd.default?.ctrlK || mrmd.ctrlK;
          if (ctrlK?.showCtrlKModal) {
            ctrlK.showCtrlKModal(view);
          }
        }, 200);
      });

      // Close mobile nav on Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && mobileNavOpen) {
          closeMobileNav();
        }
      });

      // Close mobile nav when a nav item is clicked (file selected)
      document.getElementById('nav-tree')?.addEventListener('click', (e) => {
        if (isMobileLayout() && e.target.closest('.nav-item:not(.folder)')) {
          setTimeout(closeMobileNav, 150);
        }
      });

      // Handle orientation change / resize
      window.addEventListener('resize', () => {
        if (!isMobileLayout() && mobileNavOpen) {
          closeMobileNav();
        }
      });
    });

    // =========================================================================
    // MOBILE RAIL PANEL SCRIM
    // When a rail panel opens on mobile, add a backdrop scrim so the user
    // can tap outside to close it (same pattern as mobile nav).
    // =========================================================================

    let mobileRailScrim = null;

    function addMobileRailScrim(panelId) {
      if (!isMobileLayout()) return;
      removeMobileRailScrim();

      mobileRailScrim = document.createElement('div');
      mobileRailScrim.className = 'mobile-rail-scrim';
      mobileRailScrim.addEventListener('click', () => {
        closePanel(panelId);
        removeMobileRailScrim();
      });
      document.body.appendChild(mobileRailScrim);
    }

    function removeMobileRailScrim() {
      if (mobileRailScrim) {
        mobileRailScrim.remove();
        mobileRailScrim = null;
      }
    }

    // Patch openPanel / closePanel to manage scrim on mobile
    const _originalOpenPanel = openPanel;
    openPanel = function(panelId) {
      _originalOpenPanel(panelId);
      addMobileRailScrim(panelId);
    };

    const _originalClosePanel = closePanel;
    closePanel = function(panelId) {
      _originalClosePanel(panelId);
      removeMobileRailScrim();
    };

    // Also clean up scrim on resize out of mobile
    window.addEventListener('resize', () => {
      if (!isMobileLayout()) {
        removeMobileRailScrim();
      }
    });

    // =========================================================================
    // VARIABLES PANEL
    // =========================================================================

    const variablesState = {
      groups: [],     // [{ language, variables: [] }]
      loading: false,
      fetching: false,
      pending: false,
      pendingSilent: true,
      error: null,
      lastRefresh: null,
    };

    const VARIABLES_AUTO_REFRESH_MS = 1500;
    const VARIABLES_EXEC_REFRESH_DELAY_MS = 350;
    const variablesAutoRefreshState = {
      intervalId: null,
      timeoutId: null,
    };

    function shouldLiveRefreshVariables() {
      const panel = document.getElementById('panel-variables');
      return !!panel?.classList.contains('open');
    }

    function stopVariablesLiveRefresh() {
      if (variablesAutoRefreshState.intervalId) {
        clearInterval(variablesAutoRefreshState.intervalId);
        variablesAutoRefreshState.intervalId = null;
      }
      if (variablesAutoRefreshState.timeoutId) {
        clearTimeout(variablesAutoRefreshState.timeoutId);
        variablesAutoRefreshState.timeoutId = null;
      }
    }

    function startVariablesLiveRefresh() {
      if (variablesAutoRefreshState.intervalId) return;
      variablesAutoRefreshState.intervalId = setInterval(() => {
        if (!shouldLiveRefreshVariables()) {
          stopVariablesLiveRefresh();
          return;
        }
        fetchVariables({ silent: true });
      }, VARIABLES_AUTO_REFRESH_MS);
    }

    function queueVariablesRefresh(delayMs = VARIABLES_EXEC_REFRESH_DELAY_MS) {
      if (!shouldLiveRefreshVariables()) return;
      if (variablesAutoRefreshState.timeoutId) {
        clearTimeout(variablesAutoRefreshState.timeoutId);
      }
      variablesAutoRefreshState.timeoutId = setTimeout(() => {
        variablesAutoRefreshState.timeoutId = null;
        fetchVariables({ silent: true });
      }, delayMs);
    }

    /**
     * Fetch variables from all connected runtimes
     */
    async function fetchVariables(options = {}) {
      const { silent = false } = options;

      // Coalesce concurrent refresh requests into one follow-up fetch.
      if (variablesState.fetching) {
        variablesState.pending = true;
        variablesState.pendingSilent = variablesState.pendingSilent && !!silent;
        return;
      }
      variablesState.fetching = true;

      // Collect all connected runtimes with ports
      const runtimes = [];
      if (state.pythonPort) runtimes.push({ language: 'python', port: state.pythonPort });
      if (state.bashPort) runtimes.push({ language: 'bash', port: state.bashPort });
      if (state.rPort) runtimes.push({ language: 'r', port: state.rPort });
      if (state.juliaPort) runtimes.push({ language: 'julia', port: state.juliaPort });

      if (runtimes.length === 0 && !state.jsRuntime) {
        variablesState.groups = [];
        variablesState.error = 'No runtime connected';
        variablesState.fetching = false;
        renderVariables();
        return;
      }

      if (!silent) {
        variablesState.loading = true;
        renderVariables();
      }

      try {
        const results = await Promise.allSettled(
          runtimes.map(rt =>
            fetch(`http://127.0.0.1:${rt.port}/mrp/v1/variables`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ filter: { excludePrivate: true } })
            })
            .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
            .then(data => ({ language: rt.language, variables: data.variables || [] }))
          )
        );

        variablesState.groups = results
          .filter(r => r.status === 'fulfilled')
          .map(r => r.value)
          .filter(g => g.variables.length > 0);

        // Add JavaScript variables (in-browser runtime, no HTTP)
        if (state.jsRuntime) {
          try {
            const jsVars = state.jsRuntime.listVariables({ excludePrivate: true });
            if (jsVars.length > 0) {
              variablesState.groups.push({ language: 'javascript', variables: jsVars });
            }
          } catch (e) { /* ignore */ }
        }

        variablesState.error = null;
        variablesState.lastRefresh = Date.now();
      } catch (err) {
        console.error('Failed to fetch variables:', err);
        variablesState.error = err.message;
        variablesState.groups = [];
      } finally {
        variablesState.loading = false;
        variablesState.fetching = false;
        renderVariables();

        if (variablesState.pending) {
          const nextSilent = variablesState.pendingSilent;
          variablesState.pending = false;
          variablesState.pendingSilent = true;
          fetchVariables({ silent: nextSilent });
        }
      }
    }

    // Track which tab is active
    let variablesActiveTab = null;

    const LANG_LABELS = {
      python: '\u{1F40D} Python',
      bash: '$ Bash',
      r: '\u{1F4CA} R',
      julia: '\u{25D0} Julia',
      javascript: '\u{2B22} JavaScript',
    };

    /**
     * Classify a variable value for syntax coloring
     */
    function classifyValue(v) {
      if (!v.value) return '';
      const type = (v.type || '').toLowerCase();
      if (['int', 'float', 'double', 'number', 'int64', 'float64', 'numeric', 'integer', 'complex'].some(t => type.includes(t))) return 'number';
      if (['str', 'string', 'character', 'chr'].some(t => type.includes(t))) return 'string';
      if (['bool', 'logical'].some(t => type.includes(t))) return 'bool';
      // Detect by value content
      if (/^-?\d+(\.\d+)?$/.test(v.value)) return 'number';
      if (/^(True|False|TRUE|FALSE)$/.test(v.value)) return 'bool';
      return '';
    }

    /**
     * Format variable value for display (RStudio-style)
     */
    function formatVarValue(v) {
      if (!v.value) return '';
      let val = v.value;
      // Truncate long values
      if (val.length > 60) val = val.substring(0, 57) + '...';
      return val;
    }

    /**
     * Render the variables panel with language tabs and RStudio-style table
     */
    function renderVariables() {
      const container = document.getElementById('variables-list');
      const tabsEl = document.getElementById('variables-tabs');
      if (!container) return;

      // Loading state
      if (variablesState.loading) {
        container.innerHTML = '<div class="var-empty">Loading...</div>';
        return;
      }

      // No runtime connected
      const hasAnyRuntime = state.pythonPort || state.bashPort || state.rPort || state.juliaPort || state.jsRuntime;
      if (!hasAnyRuntime) {
        if (tabsEl) tabsEl.innerHTML = '';
        container.innerHTML = '<div class="var-empty">No runtime connected<br><span style="font-size:11px;opacity:0.6">Start a runtime to see variables</span></div>';
        return;
      }

      // Error state
      if (variablesState.error) {
        container.innerHTML = `<div class="var-empty" style="color:var(--error)">Error: ${escapeHtml(variablesState.error)}</div>`;
        return;
      }

      // No variables
      if (variablesState.groups.length === 0) {
        if (tabsEl) tabsEl.innerHTML = '';
        container.innerHTML = '<div class="var-empty">No variables<br><span style="font-size:11px;opacity:0.6">Run some code to create variables</span></div>';
        return;
      }

      // Render tabs
      if (tabsEl) {
        // Auto-select first tab if no active tab or active tab no longer exists
        const availableLangs = variablesState.groups.map(g => g.language);
        if (!variablesActiveTab || !availableLangs.includes(variablesActiveTab)) {
          variablesActiveTab = availableLangs[0];
        }

        tabsEl.innerHTML = variablesState.groups.map(g => {
          const label = LANG_LABELS[g.language] || g.language;
          const count = g.variables.length;
          const active = g.language === variablesActiveTab ? ' active' : '';
          return `<button class="var-tab${active}" data-var-lang="${g.language}">${label} <span style="opacity:0.5;font-size:10px">${count}</span></button>`;
        }).join('');

        // Wire up tab clicks
        tabsEl.querySelectorAll('.var-tab').forEach(btn => {
          btn.addEventListener('click', () => {
            variablesActiveTab = btn.dataset.varLang;
            renderVariables();
          });
        });
      }

      // Get active group
      const activeGroup = variablesState.groups.find(g => g.language === variablesActiveTab);
      if (!activeGroup || activeGroup.variables.length === 0) {
        container.innerHTML = '<div class="var-empty">No variables in this runtime</div>';
        return;
      }

      // Render table header + rows
      let html = `<div class="var-table-header">
        <span class="var-table-header-name">Name</span>
        <span class="var-table-header-value">Value</span>
        <span class="var-table-header-type">Type</span>
      </div>`;

      html += activeGroup.variables.map(v => {
        const valClass = classifyValue(v);
        const valCss = valClass ? ` var-row-value-${valClass}` : '';
        const typeInfo = v.shape ? `${v.type}[${v.shape.join('\u00D7')}]` : v.type;
        const sizeInfo = v.size ? `<span class="var-row-size">${escapeHtml(v.size)}</span>` : '';
        const displayVal = formatVarValue(v);

        return `<div class="var-row" title="${escapeHtml(v.value || '')}">
          <span class="var-row-name">${escapeHtml(v.name)}</span>
          <span class="var-row-value${valCss}">${escapeHtml(displayVal)}</span>
          <span class="var-row-type">${escapeHtml(typeInfo)}${sizeInfo}</span>
        </div>`;
      }).join('');

      container.innerHTML = html;
    }

    /**
     * Initialize variables panel - auto-refresh when panel opens
     */
    function initVariablesPanel() {
      // Refresh when panel opens
      if (!openPanel._variablesWrapped) {
        const originalOpenPanel = openPanel;
        openPanel = function(panelId) {
          originalOpenPanel(panelId);
          if (panelId === 'variables') {
            fetchVariables();
            startVariablesLiveRefresh();
          } else if (!shouldLiveRefreshVariables()) {
            stopVariablesLiveRefresh();
          }
        };
        openPanel._variablesWrapped = true;
      }

      if (!closePanel._variablesWrapped) {
        const originalClosePanel = closePanel;
        closePanel = function(panelId) {
          originalClosePanel(panelId);
          if (panelId === 'variables' && !shouldLiveRefreshVariables()) {
            stopVariablesLiveRefresh();
          }
        };
        closePanel._variablesWrapped = true;
      }

      // Add refresh button handler
      const refreshBtn = document.getElementById('variables-refresh');
      refreshBtn?.addEventListener('click', fetchVariables);
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      initVariablesPanel();
    });

    // Auto-refresh variables after code execution
    // Hook into editor's execution events if available
    function setupVariablesAutoRefresh() {
      if (!state.editor?.execution?.on) {
        setTimeout(setupVariablesAutoRefresh, 500);
        return;
      }

      // Rebind handlers when a new editor instance is created.
      state.variablesCellCompleteUnsub?.();
      state.variablesCellErrorUnsub?.();

      state.variablesCellCompleteUnsub = state.editor.execution.on('cellComplete', () => {
        queueVariablesRefresh();
      });
      state.variablesCellErrorUnsub = state.editor.execution.on('cellError', () => {
        queueVariablesRefresh();
      });
    }

    // =========================================================================
    // ARTIFACT PANEL - Multi-Artifact Support
    // =========================================================================

    /**
     * State for multiple named artifacts
     * Each artifact has: { html, css, scripts, initialized }
     */
    const artifactState = {
      artifacts: new Map(),  // name -> { html, css, scripts, initialized }
      activeArtifact: null,  // Currently displayed artifact name
    };

    /**
     * Get or create an artifact by name
     */
    function getOrCreateArtifact(name) {
      if (!artifactState.artifacts.has(name)) {
        artifactState.artifacts.set(name, {
          html: '',
          css: '',
          scripts: [],
          initialized: false,
        });
        renderArtifactTabs();
      }
      return artifactState.artifacts.get(name);
    }

    /**
     * Render the artifact tabs
     */
    function renderArtifactTabs() {
      const tabsContainer = document.getElementById('artifact-tabs');
      if (!tabsContainer) return;

      const names = Array.from(artifactState.artifacts.keys());
      tabsContainer.innerHTML = names.map(name => `
        <button class="artifact-tab ${name === artifactState.activeArtifact ? 'active' : ''}"
                data-artifact="${escapeHtml(name)}">
          ${escapeHtml(name)}
          <span class="artifact-tab-close" data-close-artifact="${escapeHtml(name)}">×</span>
        </button>
      `).join('');

      // Click handlers for tabs
      tabsContainer.querySelectorAll('.artifact-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
          if (e.target.classList.contains('artifact-tab-close')) {
            const name = e.target.dataset.closeArtifact;
            closeArtifact(name);
          } else {
            const name = tab.dataset.artifact;
            switchToArtifact(name);
          }
        });
      });
    }

    /**
     * Switch to displaying a specific artifact
     */
    function switchToArtifact(name) {
      if (!artifactState.artifacts.has(name)) return;

      artifactState.activeArtifact = name;
      renderArtifactTabs();

      const artifact = artifactState.artifacts.get(name);
      loadArtifactIntoIframe(artifact);
      updateArtifactStatus(`Viewing: ${name}`);
    }

    /**
     * Close/remove an artifact
     */
    function closeArtifact(name) {
      artifactState.artifacts.delete(name);

      if (artifactState.activeArtifact === name) {
        const remaining = Array.from(artifactState.artifacts.keys());
        artifactState.activeArtifact = remaining[0] || null;
        if (artifactState.activeArtifact) {
          switchToArtifact(artifactState.activeArtifact);
        } else {
          initEmptyArtifactIframe();
        }
      }

      renderArtifactTabs();
    }

    /**
     * Initialize the artifact iframe with empty content
     */
    function initEmptyArtifactIframe() {
      const iframe = document.getElementById('artifact-iframe');
      if (!iframe) return;

      const doc = iframe.contentDocument || iframe.contentWindow.document;
      doc.open();
      doc.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <style>
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
              margin: 0; padding: 16px; color: #666;
              display: flex; align-items: center; justify-content: center;
              min-height: 100vh; text-align: center;
            }
            code { background: #f1f5f9; padding: 2px 6px; border-radius: 4px; font-size: 12px; }
          </style>
        </head>
        <body>
          <div>
            <p>No artifact selected</p>
            <p style="font-size: 12px;">Use <code>html:name</code>, <code>css:name</code>, or <code>js:name</code> cells</p>
          </div>
        </body>
        </html>
      `);
      doc.close();
    }

    /**
     * Load an artifact's content into the iframe
     */
    function loadArtifactIntoIframe(artifact) {
      const iframe = document.getElementById('artifact-iframe');
      if (!iframe) return;

      const doc = iframe.contentDocument || iframe.contentWindow.document;
      doc.open();
      doc.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1">
          <style id="artifact-styles">
            body {
              font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
              margin: 0; padding: 16px; line-height: 1.5;
            }
            * { box-sizing: border-box; }
            ${artifact.css}
          </style>
        </head>
        <body id="artifact-body">
          <div id="artifact-content">${artifact.html}</div>
        </body>
        </html>
      `);
      doc.close();

      // Re-execute scripts after HTML is loaded
      artifact.scripts.forEach(code => {
        try {
          iframe.contentWindow.eval(code);
        } catch (err) {
          console.error('[artifact] JS replay error:', err);
        }
      });

      artifact.initialized = true;
    }

    /**
     * Update an artifact with new HTML content
     */
    function updateArtifactHtml(name, html) {
      const artifact = getOrCreateArtifact(name);
      artifact.html += html;

      if (artifactState.activeArtifact === name) {
        const iframe = document.getElementById('artifact-iframe');
        const doc = iframe?.contentDocument || iframe?.contentWindow?.document;
        const container = doc?.getElementById('artifact-content');
        if (container) {
          container.innerHTML = artifact.html;
        }
        updateArtifactStatus(`HTML updated: ${name}`);
      } else if (!artifactState.activeArtifact) {
        switchToArtifact(name);
      }
    }

    /**
     * Update an artifact with new CSS
     */
    function updateArtifactCss(name, css) {
      const artifact = getOrCreateArtifact(name);
      artifact.css += '\n' + css;

      if (artifactState.activeArtifact === name) {
        const iframe = document.getElementById('artifact-iframe');
        const doc = iframe?.contentDocument || iframe?.contentWindow?.document;
        const styleEl = doc?.getElementById('artifact-styles');
        if (styleEl) {
          styleEl.textContent += '\n' + css;
        }
        updateArtifactStatus(`CSS updated: ${name}`);
      } else if (!artifactState.activeArtifact) {
        switchToArtifact(name);
      }
    }

    /**
     * Execute JS in an artifact's context
     */
    function executeArtifactJs(name, code) {
      const artifact = getOrCreateArtifact(name);
      artifact.scripts.push(code);

      if (artifactState.activeArtifact === name) {
        try {
          const iframe = document.getElementById('artifact-iframe');
          iframe.contentWindow.eval(code);
          updateArtifactStatus(`JS executed: ${name}`);
        } catch (err) {
          console.error('[artifact] JS error:', err);
          updateArtifactStatus(`JS error: ${err.message}`);
        }
      } else if (!artifactState.activeArtifact) {
        switchToArtifact(name);
      }
    }

    /**
     * Execute JS in the main document context (js:dom)
     */
    function executeMainDomJs(code) {
      try {
        eval(code);
        updateArtifactStatus('JS executed in main DOM');
      } catch (err) {
        console.error('[artifact] Main DOM JS error:', err);
        updateArtifactStatus(`Main DOM error: ${err.message}`);
      }
    }

    /**
     * Update status bar
     */
    function updateArtifactStatus(text) {
      const statusEl = document.getElementById('artifact-status');
      if (statusEl) {
        const hasArtifacts = artifactState.artifacts.size > 0;
        statusEl.innerHTML = `
          <span class="artifact-status-indicator ${hasArtifacts ? 'active' : ''}"></span>
          <span class="artifact-status-text">${text}</span>
        `;
      }
    }

    /**
     * Clear the current artifact
     */
    function clearCurrentArtifact() {
      if (!artifactState.activeArtifact) return;
      const artifact = artifactState.artifacts.get(artifactState.activeArtifact);
      if (artifact) {
        artifact.html = '';
        artifact.css = '';
        artifact.scripts = [];
        artifact.initialized = false;
        loadArtifactIntoIframe(artifact);
        updateArtifactStatus(`Cleared: ${artifactState.activeArtifact}`);
      }
    }

    /**
     * Reload the current artifact
     */
    function reloadCurrentArtifact() {
      if (!artifactState.activeArtifact) return;
      const artifact = artifactState.artifacts.get(artifactState.activeArtifact);
      if (artifact) {
        loadArtifactIntoIframe(artifact);
        updateArtifactStatus(`Reloaded: ${artifactState.activeArtifact}`);
      }
    }

    /**
     * Initialize artifact panel
     */
    function initArtifactPanel() {
      const originalOpenPanel = openPanel;
      const wrappedOpenPanel = function(panelId) {
        originalOpenPanel(panelId);
        if (panelId === 'artifact') {
          if (artifactState.activeArtifact) {
            const artifact = artifactState.artifacts.get(artifactState.activeArtifact);
            if (artifact && !artifact.initialized) {
              loadArtifactIntoIframe(artifact);
            }
          } else {
            initEmptyArtifactIframe();
          }
          renderArtifactTabs();
        }
      };
      if (!openPanel._artifactWrapped) {
        openPanel = wrappedOpenPanel;
        openPanel._artifactWrapped = true;
      }

      document.getElementById('artifact-clear')?.addEventListener('click', clearCurrentArtifact);
      document.getElementById('artifact-reload')?.addEventListener('click', reloadCurrentArtifact);

      // Expose artifact API to window for JS cells to use
      window.artifact = {
        html: (name, html) => updateArtifactHtml(name, html),
        css: (name, css) => updateArtifactCss(name, css),
        js: (name, code) => executeArtifactJs(name, code),
        addHtml: (html) => updateArtifactHtml('default', html),
        addCss: (css) => updateArtifactCss('default', css),
        run: (code) => executeArtifactJs('default', code),
        dom: executeMainDomJs,
        list: () => Array.from(artifactState.artifacts.keys()),
        switch: switchToArtifact,
        close: closeArtifact,
        clear: clearCurrentArtifact,
        reload: reloadCurrentArtifact,
        getDocument: (name) => {
          if (artifactState.activeArtifact === name) {
            const iframe = document.getElementById('artifact-iframe');
            return iframe?.contentDocument || iframe?.contentWindow?.document;
          }
          return null;
        },
        show: (name) => {
          openPanel('artifact');
          if (name && artifactState.artifacts.has(name)) {
            switchToArtifact(name);
          }
        }
      };
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      initArtifactPanel();
    });

    /**
     * Hook into cell execution to update artifacts
     */
    function setupArtifactExecutionHook() {
      if (!state.editor?.execution?.on) {
        console.log('[artifact] Waiting for editor...');
        setTimeout(setupArtifactExecutionHook, 500);
        return;
      }

      // Listen for cell completion
      state.editor.execution.on('cellComplete', (cellIndex, result, execId) => {
        const cells = state.editor.getCells?.() || [];
        const cell = cells[cellIndex];
        if (!cell) return;

        // Check if this cell targets an artifact
        // Uses properties from cells.js: artifact, artifactName, mainDom, baseLanguage
        const isArtifact = cell.artifact;
        const artifactName = cell.artifactName;
        const isMainDom = cell.mainDom;
        const baseLang = cell.baseLanguage?.toLowerCase() || cell.language?.toLowerCase();

        console.log('[artifact] Cell complete:', cell.language, { isArtifact, artifactName, isMainDom, baseLang });

        // Handle main DOM execution (js:dom)
        if (isMainDom && (baseLang === 'javascript' || baseLang === 'js')) {
          executeMainDomJs(cell.code);
          return;
        }

        // Handle artifact-targeted cells (with :name suffix)
        if (isArtifact && artifactName) {
          // Open artifact panel if not already open
          if (railState.activePanel !== 'artifact') {
            openPanel('artifact');
          }

          if (baseLang === 'html' || baseLang === 'htm') {
            updateArtifactHtml(artifactName, cell.code);
          } else if (baseLang === 'css' || baseLang === 'style') {
            updateArtifactCss(artifactName, cell.code);
          } else if (baseLang === 'javascript' || baseLang === 'js') {
            executeArtifactJs(artifactName, cell.code);
          }
          return;
        }

        // Handle plain HTML/CSS cells (no :name) - send to "default" artifact
        // Only if artifact panel is open or has existing artifacts
        if (railState.activePanel === 'artifact' || artifactState.artifacts.size > 0) {
          if (baseLang === 'html' || baseLang === 'htm') {
            updateArtifactHtml('default', cell.code);
          } else if (baseLang === 'css' || baseLang === 'style') {
            updateArtifactCss('default', cell.code);
          }
        }
      });

      console.log('[artifact] Execution hook registered');
    }

    // =========================================================================
    // SOURCE PANEL
    // =========================================================================

    const sourceState = {
      history: [],      // Stack of {name, result} for back navigation
      currentIndex: -1, // Current position in history
    };

    /**
     * Show source code in the panel
     */
    function showSource(result) {
      if (!result || !result.found) {
        console.log('[source] No result to show');
        return;
      }

      // Add to history
      if (sourceState.currentIndex < sourceState.history.length - 1) {
        // If we navigated back and then view new source, truncate forward history
        sourceState.history = sourceState.history.slice(0, sourceState.currentIndex + 1);
      }
      sourceState.history.push({ name: result.name, result });
      sourceState.currentIndex = sourceState.history.length - 1;

      renderSource(result);
      openPanel('source');
    }

    /**
     * Navigate back in source history
     */
    function sourceBack() {
      if (sourceState.currentIndex > 0) {
        sourceState.currentIndex--;
        const entry = sourceState.history[sourceState.currentIndex];
        renderSource(entry.result);
      }
    }

    /**
     * Render source code with syntax highlighting and clickable types
     */
    function renderSource(result) {
      const titleEl = document.getElementById('source-title');
      const fileEl = document.getElementById('source-file');
      const codeEl = document.getElementById('source-code');
      const backBtn = document.getElementById('source-back');

      if (!titleEl || !fileEl || !codeEl) return;

      // Update title and file path
      titleEl.textContent = result.name || 'Source';
      fileEl.textContent = result.file || '';
      fileEl.title = result.file || '';

      // Update back button state
      if (backBtn) {
        backBtn.disabled = sourceState.currentIndex <= 0;
      }

      // Get source code or show message
      const sourceCode = result.sourceCode;
      if (!sourceCode) {
        codeEl.innerHTML = `<code>No source code available for ${result.name}.\n\nType: ${result.type || 'unknown'}\n${result.docstring ? '\nDocstring:\n' + result.docstring : ''}</code>`;
        return;
      }

      // Apply syntax highlighting and make types clickable
      const highlighted = highlightPythonSource(sourceCode);
      codeEl.innerHTML = `<code>${highlighted}</code>`;

      // Add click handlers for type references
      codeEl.querySelectorAll('.source-type-ref').forEach(el => {
        el.addEventListener('click', async () => {
          const typeName = el.dataset.type;
          if (typeName) {
            await drillIntoType(typeName);
          }
        });
      });
    }

    /**
     * Basic Python syntax highlighting with clickable type references
     */
    function highlightPythonSource(code) {
      // Escape HTML first
      let html = code
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      // Extract strings first to protect them (replace with placeholders)
      const strings = [];
      html = html.replace(/("""[\s\S]*?"""|'''[\s\S]*?'''|"[^"\\]*(?:\\.[^"\\]*)*"|'[^'\\]*(?:\\.[^'\\]*)*')/g, (match) => {
        strings.push(match);
        return `__STR${strings.length - 1}__`;
      });

      // Extract comments to protect them
      const comments = [];
      html = html.replace(/(#.*$)/gm, (match) => {
        comments.push(match);
        return `__CMT${comments.length - 1}__`;
      });

      // Keywords
      const keywords = ['class', 'def', 'return', 'if', 'else', 'elif', 'for', 'while', 'try', 'except', 'finally', 'with', 'as', 'import', 'from', 'raise', 'pass', 'break', 'continue', 'yield', 'async', 'await', 'lambda', 'and', 'or', 'not', 'in', 'is', 'None', 'True', 'False', 'self', 'cls'];
      const kwPattern = new RegExp(`\\b(${keywords.join('|')})\\b`, 'g');
      html = html.replace(kwPattern, '<span class=kw>$1</span>');

      // Decorators
      html = html.replace(/(@\w+)/g, '<span class=dec>$1</span>');

      // Numbers
      html = html.replace(/\b(\d+\.?\d*)\b/g, '<span class=num>$1</span>');

      // Function definitions
      html = html.replace(/(<span class=kw>def<\/span>\s+)(\w+)/g, '$1<span class=fn>$2</span>');

      // Class definitions with clickable base classes
      html = html.replace(/(<span class=kw>class<\/span>\s+)(\w+)(\s*\()([^)]+)(\))/g, (match, prefix, className, paren1, bases, paren2) => {
        // Make base classes clickable
        const clickableBases = bases.split(',').map(base => {
          const trimmed = base.trim();
          if (trimmed && !trimmed.startsWith('<span')) {
            return `<span class=source-type-ref data-type="${trimmed}">${trimmed}</span>`;
          }
          return base;
        }).join(',');
        return `${prefix}<span class=cls>${className}</span>${paren1}${clickableBases}${paren2}`;
      });

      // Type annotations (: TypeName) - make clickable
      html = html.replace(/:\s*([A-Z][A-Za-z0-9_]*(?:\[[^\]]+\])?)/g, (match, typeName) => {
        // Extract base type (before any brackets)
        const baseType = typeName.split('[')[0];
        return `: <span class="source-type-ref type" data-type="${baseType}">${typeName}</span>`;
      });

      // Return type annotations (-> TypeName)
      html = html.replace(/-&gt;\s*([A-Z][A-Za-z0-9_]*(?:\[[^\]]+\])?)/g, (match, typeName) => {
        const baseType = typeName.split('[')[0];
        return `-&gt; <span class="source-type-ref type" data-type="${baseType}">${typeName}</span>`;
      });

      // Restore comments with highlighting
      comments.forEach((cmt, i) => {
        html = html.replace(`__CMT${i}__`, `<span class=cm>${cmt}</span>`);
      });

      // Restore strings with highlighting
      strings.forEach((str, i) => {
        html = html.replace(`__STR${i}__`, `<span class=str>${str}</span>`);
      });

      return html;
    }

    /**
     * Drill into a type to view its source
     */
    async function drillIntoType(typeName) {
      console.log('[source] Drilling into:', typeName);

      if (!state.editor) {
        console.error('[source] No editor available');
        return;
      }

      try {
        const result = await state.editor.viewSourceByName(typeName, 'python');
        if (result && result.found) {
          // showSource is called via the onViewSource callback
        } else {
          console.log('[source] Type not found:', typeName);
          alert(`Could not find source for: ${typeName}`);
        }
      } catch (e) {
        console.error('[source] Error drilling into type:', e);
      }
    }

    /**
     * Initialize source panel
     */
    function initSourcePanel() {
      const backBtn = document.getElementById('source-back');
      if (backBtn) {
        backBtn.addEventListener('click', sourceBack);
      }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      initSourcePanel();
    });

    // =========================================================================
    // RUNTIMES PANEL
    // =========================================================================

    /**
     * Render the runtimes list in the panel.
     *
     * Notebook-scoped: only shows runtimes for languages that appear in
     * the current document's code blocks. Languages without a running
     * runtime are shown as "Not started" with a Start action.
     */
    function renderRuntimesPanel() {
      const listEl = document.getElementById('runtimes-list');
      if (!listEl) return;

      const runtimes = state.runningRuntimes || [];
      const attachedIds = {
        python: state.pythonVenv?.runtimeId || state.pythonVenv?.name || state.session?.name,
        bash: state.bashSession?.name,
        r: state.rSession?.name,
        julia: state.juliaSession?.name,
      };

      // --- Detect languages in the current document ---
      const docLanguages = getDocumentLanguagesFromEditor();

      // Language display config
      const LANG_DISPLAY = {
        python: { label: 'PYTHON', badge: 'python' },
        bash:   { label: 'BASH',   badge: 'bash' },
        r:      { label: 'R',      badge: 'r' },
        julia:  { label: 'JULIA',  badge: 'julia' },
        javascript: { label: 'JS', badge: 'javascript' },
      };

      // If no code blocks found, show helpful empty state
      if (docLanguages.size === 0) {
        listEl.innerHTML = `
          <div class="runtimes-empty">
            <div style="margin-bottom: 8px;">No code blocks in this document</div>
            <div style="font-size: 11px; color: var(--text-dim);">
              Add a code block (e.g. \`\`\`python) to see its runtime here.
            </div>
          </div>
        `;
        return;
      }

      // Build per-language sections
      let html = '';
      for (const lang of docLanguages) {
        const display = LANG_DISPLAY[lang] || { label: lang.toUpperCase(), badge: lang };
        const langRuntimes = runtimes.filter(rt => (rt.language || 'python') === lang);
        const attachedId = attachedIds[lang];

        html += `<div class="runtime-lang-section" data-language="${lang}">`;
        html += `<div class="runtime-lang-section-header">`;
        html += `  <span class="runtime-lang-badge ${display.badge}">${display.label}</span>`;
        html += `</div>`;

        if (langRuntimes.length === 0) {
          // No runtime running for this language
          html += `
            <div class="runtime-item runtime-item--inactive">
              <div class="runtime-item-status" style="background: var(--text-dim); opacity: 0.4;"></div>
              <div class="runtime-item-info">
                <div class="runtime-item-name" style="color: var(--text-muted);">Not started</div>
                <div class="runtime-item-meta">Starts on first cell execution</div>
              </div>
              <div class="runtime-item-actions" style="opacity: 1;">
                <button class="runtime-item-btn" onclick="event.stopPropagation(); startRuntimeForLanguage('${lang}')">start</button>
              </div>
            </div>
          `;
        } else {
          for (const rt of langRuntimes) {
            const isAttached = rt.id === attachedId;
            const venvShort = rt.venv ? rt.venv.split('/').slice(-2).join('/') : '';
            const cwdShort = rt.cwd ? rt.cwd.split('/').slice(-2).join('/') : '';

            html += `
              <div class="runtime-item ${isAttached ? 'attached' : ''}"
                   data-runtime-id="${rt.id}"
                   data-language="${lang}"
                   title="PID ${rt.pid}${rt.cwd ? ' · ' + rt.cwd : ''}">
                <div class="runtime-item-status"></div>
                <div class="runtime-item-info">
                  <div class="runtime-item-name">${rt.id}</div>
                  <div class="runtime-item-meta">
                    ${venvShort ? venvShort + ' · ' : ''}port ${rt.port}
                    ${cwdShort ? '<br>cwd: ' + cwdShort : ''}
                  </div>
                </div>
                <div class="runtime-item-actions">
                  ${isAttached ? '' : `<button class="runtime-item-btn" onclick="event.stopPropagation(); attachToRuntime('${rt.id}', '${lang}')">attach</button>`}
                  <button class="runtime-item-btn" onclick="event.stopPropagation(); toggleRuntimeConfig('${rt.id}', '${lang}')">⚙</button>
                  <button class="runtime-item-btn danger" onclick="event.stopPropagation(); killAndRefreshRuntime('${rt.id}', '${lang}')">stop</button>
                </div>
              </div>
              <div class="runtime-config-panel" id="runtime-config-${rt.id}" style="display: none;">
                <div class="runtime-config-field">
                  <label>Session</label>
                  <input type="text" value="${extractShortSessionName(rt.id, lang)}" data-field="name" data-runtime-id="${rt.id}" data-language="${lang}" />
                </div>
                ${lang === 'python' ? `
                <div class="runtime-config-field">
                  <label>Venv</label>
                  <div class="runtime-config-field-row">
                    <input type="text" value="${makeRelativePath(rt.venv, state.projectRoot) || '.venv'}" data-field="venv" data-runtime-id="${rt.id}" data-language="${lang}" />
                    <button class="runtime-item-btn" onclick="browseForVenv('${rt.id}', '${lang}')" title="Browse">📂</button>
                  </div>
                </div>
                ` : ''}
                <div class="runtime-config-field">
                  <label>CWD</label>
                  <div class="runtime-config-field-row">
                    <input type="text" value="${makeRelativePath(rt.cwd, state.projectRoot) || '.'}" data-field="cwd" data-runtime-id="${rt.id}" data-language="${lang}" />
                    <button class="runtime-item-btn" onclick="browseForCwd('${rt.id}', '${lang}')" title="Browse">📂</button>
                  </div>
                </div>
                <div class="runtime-config-actions">
                  <button class="runtime-item-btn" onclick="applyRuntimeConfig('${rt.id}', '${lang}')">Apply & Restart</button>
                </div>
              </div>
            `;
          }
        }

        html += `</div>`; // close runtime-lang-section
      }

      // Link to Home for full runtime management
      html += `
        <div style="padding: 12px 16px; border-top: 1px solid var(--border); margin-top: 8px;">
          <button class="runtime-item-btn" onclick="showHomeView()" style="width: 100%; text-align: center; padding: 6px;">
            All runtimes →
          </button>
        </div>
      `;

      listEl.innerHTML = html;

      // Add click handler to attach on row click
      listEl.querySelectorAll('.runtime-item:not(.runtime-item--inactive)').forEach(el => {
        el.addEventListener('click', () => {
          const runtimeId = el.dataset.runtimeId;
          const language = el.dataset.language || 'python';
          if (!el.classList.contains('attached')) {
            attachToRuntime(runtimeId, language);
          }
        });
      });
    }

    /**
     * Get the set of executable languages from the current document.
     * Scans for fenced code blocks and returns normalized language names.
     * @returns {Set<string>}
     */
    function getDocumentLanguagesFromEditor() {
      const languages = new Set();

      // Get document content from the editor — state.editor is the mrmd editor instance
      let content = '';
      try {
        if (state.editor?.getContent) {
          content = state.editor.getContent();
        } else if (state.editor?.view?.state?.doc) {
          content = state.editor.view.state.doc.toString();
        }
      } catch (e) {
        console.warn('Failed to get editor content for language detection:', e);
      }

      if (!content) return languages;

      // Language alias map
      const ALIASES = {
        py: 'python', python3: 'python',
        js: 'javascript', node: 'javascript', ts: 'javascript', typescript: 'javascript',
        jl: 'julia', sh: 'bash', shell: 'bash', zsh: 'bash', rlang: 'r',
      };

      // Non-executable languages to skip
      const SKIP = new Set([
        'yaml', 'json', 'toml', 'xml', 'html', 'css', 'mermaid',
        'output', 'markdown', 'md', 'text', 'txt', 'diff', 'csv',
        'sql', 'graphql', 'latex', 'tex', 'bibtex',
      ]);

      // Known runtime languages
      const RUNTIME_LANGS = new Set([
        'python', 'bash', 'javascript', 'julia', 'r', 'shell', 'node', 'typescript',
      ]);

      const fenceRegex = /^(`{3,}|~{3,})(\w+)(?:\s+(.*))?$/gm;
      let match;
      while ((match = fenceRegex.exec(content))) {
        const rawLang = match[2].toLowerCase();
        const extra = (match[3] || '').trim().toLowerCase();
        if (extra === 'config') continue;
        if (SKIP.has(rawLang)) continue;
        const normalized = ALIASES[rawLang] || rawLang;
        if (RUNTIME_LANGS.has(rawLang) || RUNTIME_LANGS.has(normalized)) {
          languages.add(normalized);
        }
      }

      return languages;
    }

    /**
     * Toggle the inline configuration panel for a runtime.
     */
    /**
     * Extract the short session name from a full resolved session ID.
     * Full ID format: "{project}:{language}:{name}" → returns "{name}"
     * E.g.: "mrmddemos:julia:default" → "default"
     *        "mrmddemos:default" → "default" (Python legacy format)
     */
    function extractShortSessionName(fullId, language) {
      if (!fullId) return 'default';
      // Try {project}:{language}:{name} format first
      const langPrefix = `:${language}:`;
      const langIdx = fullId.indexOf(langPrefix);
      if (langIdx >= 0) {
        return fullId.slice(langIdx + langPrefix.length) || 'default';
      }
      // Try {project}:{name} format (Python)
      const colonIdx = fullId.indexOf(':');
      if (colonIdx >= 0) {
        return fullId.slice(colonIdx + 1) || 'default';
      }
      return fullId;
    }

    /**
     * Make an absolute path relative to a base directory.
     * E.g.: makeRelativePath("/home/user/project/.venv", "/home/user/project") → ".venv"
     */
    function makeRelativePath(absPath, basePath) {
      if (!absPath || !basePath) return absPath || '';
      if (absPath.startsWith(basePath)) {
        let rel = absPath.slice(basePath.length);
        if (rel.startsWith('/')) rel = rel.slice(1);
        return rel || '.';
      }
      return absPath;
    }

    function toggleRuntimeConfig(runtimeId, language) {
      const panel = document.getElementById(`runtime-config-${runtimeId}`);
      if (!panel) return;
      const isVisible = panel.style.display !== 'none';
      panel.style.display = isVisible ? 'none' : 'block';
    }

    /**
     * Apply runtime configuration changes and persist to frontmatter.
     */
    async function applyRuntimeConfig(runtimeId, language) {
      const panel = document.getElementById(`runtime-config-${runtimeId}`);
      if (!panel) return;

      const config = {};
      panel.querySelectorAll('input[data-field]').forEach(input => {
        config[input.dataset.field] = input.value;
      });

      // Persist to frontmatter via custom event
      try {
        const event = new CustomEvent('mrmd:update-session-config', {
          detail: { language, config },
        });
        document.dispatchEvent(event);
      } catch (e) {
        console.warn('Failed to update frontmatter:', e);
      }

      // Kill and restart with new config
      await killRuntimeAction(runtimeId, language);

      // Start new runtime with updated config
      try {
        if (language === 'python') {
          await electronAPI.runtime.start({
            name: config.name || runtimeId,
            venv: config.venv,
            cwd: config.cwd,
          });
        }
      } catch (e) {
        console.error('Failed to restart runtime:', e);
      }

      await refreshRuntimes();
    }

    /**
     * Start a runtime for a language that has code blocks but no running session.
     */
    async function startRuntimeForLanguage(language) {
      try {
        // Use forDocument to get properly resolved config (session name, cwd, etc.)
        // This goes through mrmd-project's resolveSessionForLanguage which handles defaults.
        const docPath = state.currentFile;

        if (language === 'python') {
          // Python uses the venv picker / session flow
          const venv = state.pythonVenv?.path || '.venv';
          const cwd = state.projectRoot || '.';
          await electronAPI.runtime.start({ venv, cwd });
        } else if (['bash', 'r', 'julia'].includes(language) && docPath) {
          const config = await electronAPI.runtime.forDocumentLanguage(docPath, language);
          if (!config?.alive) {
            console.log(`[startRuntime] ${language} could not start (no project or not available)`);
          }
        } else if (!docPath) {
          console.log(`[startRuntime] No document open, cannot start ${language}`);
        }
        await refreshRuntimes();
      } catch (e) {
        console.error(`Failed to start ${language} runtime:`, e);
      }
    }

    /**
     * Browse for a virtual environment path (updates the config panel input).
     */
    async function browseForVenv(runtimeId, language) {
      try {
        const result = await electronAPI.dialog?.showOpenDialog?.({
          properties: ['openDirectory'],
          title: 'Select Virtual Environment',
          defaultPath: state.projectRoot || undefined,
        });
        if (result && !result.canceled && result.filePaths?.[0]) {
          const panel = document.getElementById(`runtime-config-${runtimeId}`);
          if (panel) {
            const input = panel.querySelector('input[data-field="venv"]');
            if (input) input.value = result.filePaths[0];
          }
        }
      } catch (e) {
        console.warn('Browse for venv not available:', e);
      }
    }

    /**
     * Browse for a working directory (updates the config panel input).
     */
    async function browseForCwd(runtimeId, language) {
      try {
        const result = await electronAPI.dialog?.showOpenDialog?.({
          properties: ['openDirectory'],
          title: 'Select Working Directory',
          defaultPath: state.projectRoot || undefined,
        });
        if (result && !result.canceled && result.filePaths?.[0]) {
          const panel = document.getElementById(`runtime-config-${runtimeId}`);
          if (panel) {
            const input = panel.querySelector('input[data-field="cwd"]');
            if (input) input.value = result.filePaths[0];
          }
        }
      } catch (e) {
        console.warn('Browse for CWD not available:', e);
      }
    }

    /**
     * Refresh runtimes list from backend
     */
    async function refreshRuntimes() {
      try {
        // Fetch all runtimes in one call
        const allSessions = await electronAPI.runtime.list();

        state.runningRuntimes = (allSessions || [])
          .filter(s => s.alive)
          .map(s => ({
            id: s.name,
            pid: s.pid,
            port: s.port,
            venv: s.venv,
            cwd: s.cwd,
            alive: s.alive,
            language: s.language || 'python',
          }));
        renderRuntimesPanel();
      } catch (e) {
        console.error('Failed to refresh runtimes:', e);
      }
    }

    /**
     * Kill a runtime and refresh the list
     */
    async function killAndRefreshRuntime(runtimeId, language = 'python') {
      await killRuntimeAction(runtimeId, language);
      renderRuntimesPanel();
    }

    /**
     * Initialize runtimes panel
     */
    function initRuntimesPanel() {
      // Refresh when panel opens
      const originalOpenPanel = openPanel;
      openPanel = function(panelId) {
        originalOpenPanel(panelId);
        if (panelId === 'runtimes') {
          refreshRuntimes();
        }
      };

      // Add refresh button handler
      const refreshBtn = document.getElementById('runtimes-refresh');
      refreshBtn?.addEventListener('click', refreshRuntimes);
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      renderJavaScriptImportHelpSnippet();
      initRuntimesPanel();
      initHomeView();
    });

    // =========================================================================
    // HOME VIEW
    // =========================================================================

    let homeViewActive = false;

    /**
     * Initialize the Home view: home button, keyboard shortcut.
     */
    function initHomeView() {
      const homeBtn = document.getElementById('home-btn');
      if (homeBtn) {
        homeBtn.addEventListener('click', toggleHomeView);
      }

      // Keyboard shortcut: Ctrl+Shift+H
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'H') {
          e.preventDefault();
          toggleHomeView();
        }
      });
    }

    /**
     * Toggle between Home view and editor view.
     */
    function toggleHomeView() {
      if (homeViewActive) {
        hideHomeView();
      } else {
        showHomeView();
      }
    }

    /**
     * Show the Home view — full-page takeover.
     * Hides nav sidebar, side rail, TOC, editor — everything.
     */
    function showHomeView() {
      const homeView = document.getElementById('home-view');
      const homeBtn = document.getElementById('home-btn');

      if (!homeView) return;

      homeView.classList.add('visible');
      homeBtn?.classList.add('active');
      homeViewActive = true;

      // Update titlebar to show we're on Home
      const titleEl = document.getElementById('titlebar-title');
      if (titleEl) titleEl.textContent = 'Home';

      // Set home content
      const projectName = state.projectName || state.project?.name || 'mrmd';
      const el = document.getElementById('home-title');
      if (el) el.textContent = projectName;
      const sub = document.getElementById('home-subtitle');
      if (sub) sub.textContent = state.projectRoot ? shortenPath(state.projectRoot, 60) : 'Welcome back';

      // Render all sections
      renderHomeRecentFiles();
      renderHomeRecentProjects();
      renderHomeRuntimes();
    }

    /**
     * Hide the Home view — restore editor chrome.
     */
    function hideHomeView() {
      const homeView = document.getElementById('home-view');
      const homeBtn = document.getElementById('home-btn');

      if (!homeView) return;

      homeView.classList.remove('visible');
      homeBtn?.classList.remove('active');
      homeViewActive = false;

      // Restore titlebar to current file
      const titleEl = document.getElementById('titlebar-title');
      if (titleEl) {
        const fileName = state.currentFile || 'mrmd';
        titleEl.textContent = fileName;
      }
    }

    /**
     * Render the recent files section in Home view.
     */
    async function renderHomeRecentFiles() {
      const container = document.getElementById('home-recent-files');
      if (!container) return;

      let recentFiles = [];
      try {
        recentFiles = await electronAPI.getRecentFiles?.() || [];
      } catch (e) {
        console.warn('Failed to get recent files:', e);
      }

      if (recentFiles.length === 0) {
        container.innerHTML = '<div class="home-empty">No recent files</div>';
        return;
      }

      container.innerHTML = recentFiles.slice(0, 15).map(file => {
        const name = file.name || file.path?.split('/').pop() || 'untitled';
        const displayName = name.replace(/\.md$/, '');
        const relativePath = file.path || '';
        const timeAgo = file.lastOpened ? formatTimeAgo(file.lastOpened) : '';

        return `
          <div class="home-file-item" onclick="openFileFromHome('${escapeAttr(file.path)}')" title="${escapeAttr(file.path)}">
            <span class="home-item-icon">📄</span>
            <div class="home-item-info">
              <div class="home-item-name">${escapeHtml(displayName)}</div>
              <div class="home-item-meta">${escapeHtml(timeAgo)}</div>
            </div>
          </div>
        `;
      }).join('');
    }

    /**
     * Render the recent projects section in Home view.
     */
    async function renderHomeRecentProjects() {
      const container = document.getElementById('home-recent-projects');
      if (!container) return;

      let recentProjects = [];
      try {
        recentProjects = await electronAPI.getRecentProjects?.() || [];
      } catch (e) {
        console.warn('Failed to get recent projects:', e);
      }

      if (recentProjects.length === 0) {
        container.innerHTML = '<div class="home-empty">No recent projects</div>';
        return;
      }

      container.innerHTML = recentProjects.slice(0, 10).map(project => {
        const name = project.name || project.path?.split('/').pop() || 'Unknown';
        const displayPath = project.path ? shortenPath(project.path, 40) : '';

        return `
          <div class="home-project-item" onclick="openProjectFromHome('${escapeAttr(project.path)}')" title="${escapeAttr(project.path)}">
            <span class="home-item-icon">📁</span>
            <div class="home-item-info">
              <div class="home-item-name">${escapeHtml(name)}</div>
              <div class="home-item-meta">${escapeHtml(displayPath)}</div>
            </div>
          </div>
        `;
      }).join('');
    }

    /**
     * Render the global runtimes section in Home view (fetches fresh data).
     */
    async function renderHomeRuntimes() {
      await refreshRuntimes();
      renderHomeRuntimesList();
    }

    /**
     * Render the runtimes list in Home view (uses cached state.runningRuntimes).
     */
    function renderHomeRuntimesList() {
      const container = document.getElementById('home-runtimes');
      const stopAllBtn = document.getElementById('home-stop-all');
      if (!container) return;

      const runtimes = state.runningRuntimes || [];

      if (runtimes.length === 0) {
        container.innerHTML = '<div class="home-empty">No runtimes running</div>';
        if (stopAllBtn) stopAllBtn.style.display = 'none';
        return;
      }

      if (stopAllBtn) stopAllBtn.style.display = 'block';

      // Group by language
      const byLang = {};
      for (const rt of runtimes) {
        const lang = rt.language || 'python';
        if (!byLang[lang]) byLang[lang] = [];
        byLang[lang].push(rt);
      }

      let html = '';
      for (const [lang, langRuntimes] of Object.entries(byLang)) {
        for (const rt of langRuntimes) {
          const venvShort = rt.venv ? rt.venv.split('/').slice(-2).join('/') : '';
          const cwdShort = rt.cwd ? shortenPath(rt.cwd, 30) : '';

          html += `
            <div class="home-runtime-item" title="PID ${rt.pid}${rt.cwd ? ' · ' + rt.cwd : ''}">
              <span class="home-runtime-status running"></span>
              <span class="runtime-lang-badge ${lang}">${lang}</span>
              <div class="home-item-info">
                <div class="home-item-name">${escapeHtml(rt.id)}</div>
                <div class="home-item-meta">
                  ${venvShort ? escapeHtml(venvShort) + ' · ' : ''}port ${rt.port} · PID ${rt.pid}
                  ${cwdShort ? '<br>cwd: ' + escapeHtml(cwdShort) : ''}
                </div>
              </div>
              <div class="home-item-actions">
                <button class="home-item-btn danger" onclick="event.stopPropagation(); killAndRefreshHomeRuntime('${escapeAttr(rt.id)}', '${lang}')">Stop</button>
              </div>
            </div>
          `;
        }
      }

      // Memory summary
      const totalRuntimes = runtimes.length;
      html += `
        <div style="padding: 8px 16px; color: var(--text-dim); font-size: 11px; text-align: center;">
          ${totalRuntimes} runtime${totalRuntimes > 1 ? 's' : ''} running
        </div>
      `;

      container.innerHTML = html;
    }

    /**
     * Kill a runtime and refresh the Home view.
     */
    async function killAndRefreshHomeRuntime(runtimeId, language) {
      await killRuntimeAction(runtimeId, language);
      await refreshRuntimes();
      renderHomeRuntimesList();
    }

    /**
     * Stop all runtimes.
     */
    async function stopAllRuntimes() {
      // Snapshot the list first (it mutates as we kill)
      const runtimes = [...(state.runningRuntimes || [])];
      for (const rt of runtimes) {
        try {
          await killRuntimeAction(rt.id, rt.language || 'python');
        } catch (e) {
          console.error('Failed to kill runtime:', rt.id, e);
        }
      }
      // Single refresh at the end
      await refreshRuntimes();
      renderHomeRuntimesList();
    }

    /**
     * Refresh the Home view runtimes section.
     */
    async function refreshHomeRuntimes() {
      await renderHomeRuntimes();
    }

    /**
     * Open a file from the Home view.
     */
    function openFileFromHome(filePath) {
      hideHomeView();
      if (typeof openFile === 'function') {
        openFile(filePath);
      }
    }

    /**
     * Open a project from the Home view.
     */
    function openProjectFromHome(projectPath) {
      hideHomeView();
      if (typeof openProject === 'function') {
        openProject(projectPath);
      }
    }

    /**
     * Open the project picker dialog.
     */
    function openProjectPicker() {
      hideHomeView();
      if (typeof showFolderPickerDialog === 'function') {
        showFolderPickerDialog();
      }
    }

    // ---- Home view helpers ----

    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function escapeAttr(str) {
      if (!str) return '';
      return str.replace(/'/g, "\\'").replace(/"/g, '&quot;');
    }

    function shortenPath(path, maxLen = 25) {
      if (!path) return '';
      if (path.length <= maxLen) return path;
      return '...' + path.slice(-(maxLen - 3));
    }

    function formatTimeAgo(timestamp) {
      if (!timestamp) return '';
      const now = Date.now();
      const ts = typeof timestamp === 'string' ? new Date(timestamp).getTime() : timestamp;
      const diff = now - ts;
      const minutes = Math.floor(diff / 60000);
      if (minutes < 1) return 'just now';
      if (minutes < 60) return `${minutes} min ago`;
      const hours = Math.floor(minutes / 60);
      if (hours < 24) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
      const days = Math.floor(hours / 24);
      if (days < 7) return `${days} day${days > 1 ? 's' : ''} ago`;
      const weeks = Math.floor(days / 7);
      return `${weeks} week${weeks > 1 ? 's' : ''} ago`;
    }

    // Listen for session config updates from the runtimes panel
    document.addEventListener('mrmd:update-session-config', (e) => {
      const { language, config } = e.detail;
      // Use the state.editor instance to update frontmatter
      if (state.editor?.updateFrontmatterSession) {
        state.editor.updateFrontmatterSession(language, config);
      } else if (state.editor?.view) {
        // Fallback: use the mrmd-editor frontmatter-updater directly if available
        try {
          const mrmd = window.mrmd || window.MrmdEditor;
          if (mrmd?.updateFrontmatterSession) {
            mrmd.updateFrontmatterSession(state.editor.view, language, config);
          }
        } catch (err) {
          console.warn('Could not update frontmatter:', err);
        }
      }
    });

    // =========================================================================
    // AI COMMANDS PANEL
    // =========================================================================

    /**
     * Global AI client - set when AI server is connected
     * @type {import('mrmd-editor').AiClient|null}
     */
    let aiClient = null;

    /**
     * AI command definitions
     */
    const AI_COMMANDS = {
      'fix-grammar': {
        program: 'FixGrammarPredict',
        resultField: 'fixed_text',
        type: 'replace',
        requiresSelection: true,
        buildParams: (ctx) => ({
          text_to_fix: ctx.selectedText,
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'fix-transcription': {
        program: 'FixTranscriptionPredict',
        resultField: 'fixed_text',
        type: 'replace',
        requiresSelection: true,
        buildParams: (ctx) => ({
          text_to_fix: ctx.selectedText,
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'finish-sentence': {
        program: 'FinishSentencePredict',
        resultField: 'completion',
        type: 'insert',
        requiresSelection: false,
        buildParams: (ctx) => ({
          text_before_cursor: ctx.textBeforeCursor,
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'finish-paragraph': {
        program: 'FinishParagraphPredict',
        resultField: 'completion',
        type: 'insert',
        requiresSelection: false,
        buildParams: (ctx) => ({
          text_before_cursor: ctx.textBeforeCursor,
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'document-code': {
        program: 'DocumentCodePredict',
        resultField: 'documented_code',
        type: 'replace',
        requiresSelection: true,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code: ctx.selectedText,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'add-types': {
        program: 'AddTypeHintsPredict',
        resultField: 'typed_code',
        type: 'replace',
        requiresSelection: true,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code: ctx.selectedText,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'improve-names': {
        program: 'ImproveNamesPredict',
        resultField: 'improved_code',
        type: 'replace',
        requiresSelection: true,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code: ctx.selectedText,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'refactor': {
        program: 'RefactorCodePredict',
        resultField: 'refactored_code',
        type: 'replace',
        requiresSelection: true,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code: ctx.selectedText,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'finish-code-line': {
        program: 'FinishCodeLinePredict',
        resultField: 'completion',
        type: 'insert',
        requiresSelection: false,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code_before_cursor: ctx.textBeforeCursor,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'finish-code-section': {
        program: 'FinishCodeSectionPredict',
        resultField: 'completion',
        type: 'insert',
        requiresSelection: false,
        codeOnly: true,
        buildParams: (ctx, lang) => ({
          code_before_cursor: ctx.textBeforeCursor,
          language: lang || 'python',
          local_context: ctx.localContext,
          document_context: ctx.documentContext,
        }),
      },
      'document-continue': {
        program: 'DocumentResponsePredict',
        resultField: 'response',
        type: 'insert',
        requiresSelection: false,
        buildParams: (ctx) => ({
          document: ctx.documentContext,
        }),
        // Special: insert at end of document
        insertAtEnd: true,
      },
      // Comment commands
      'address-comment': {
        program: 'AddressNearbyCommentPredict',
        resultField: 'edits',
        type: 'edits',  // Special type for edit operations
        requiresSelection: false,
        buildParams: (ctx) => {
          const commentSyntax = mrmd.default?.commentSyntax || mrmd.commentSyntax;
          const nearbyComment = commentSyntax?.findNearestComment?.(ctx.documentContext, ctx.cursorPos);
          if (!nearbyComment) return null;
          return {
            full_document: ctx.documentContext,
            cursor_context_before: ctx.textBeforeCursor,
            cursor_context_after: ctx.textAfterCursor,
            nearby_comment: {
              text: nearbyComment.content,
              context_before: ctx.documentContext.slice(Math.max(0, nearbyComment.start - 200), nearbyComment.start),
              context_after: ctx.documentContext.slice(nearbyComment.end, Math.min(ctx.documentContext.length, nearbyComment.end + 200)),
            },
            nearby_comment_raw: nearbyComment.raw,
          };
        },
      },
      'address-all-comments': {
        program: 'AddressAllCommentsPredict',
        resultField: 'edits',
        type: 'edits',
        requiresSelection: false,
        buildParams: (ctx) => {
          const commentSyntax = mrmd.default?.commentSyntax || mrmd.commentSyntax;
          const comments = commentSyntax?.extractComments?.(ctx.documentContext) || [];
          if (comments.length === 0) return null;
          return {
            full_document: ctx.documentContext,
            comments: comments.map(c => ({
              text: c.content,
              context_before: ctx.documentContext.slice(Math.max(0, c.start - 200), c.start),
              context_after: ctx.documentContext.slice(c.end, Math.min(ctx.documentContext.length, c.end + 200)),
            })),
          };
        },
      },
    };

    /**
     * Connect to AI server
     * @param {string} serverUrl - AI server base URL (e.g., http://127.0.0.1:34251)
     */
    function connectAiServer(serverUrl) {
      // Create a simple client that calls mrmd-ai server directly
      // mrmd-ai endpoints are at /{program} not /api/ai/{program}
      aiClient = {
        baseUrl: serverUrl.replace(/\/$/, ''),
        juiceLevel: currentJuiceLevel, // Use current panel state
        reasoningLevel: currentReasoningLevel, // Use current panel state
        apiKeys: null, // Cached API keys (loaded lazily)
        qualityLevels: null, // Cached quality level configs

        /**
         * Load API keys and quality levels from settings
         */
        async loadSettings() {
          try {
            // Load API keys (unmasked)
            const keys = await electronAPI.settings.getApiKeys(false);
            this.apiKeys = keys;

            // Load quality levels
            this.qualityLevels = await electronAPI.settings.getQualityLevels();
          } catch (e) {
            console.warn('[AI] Failed to load settings:', e);
          }
        },

        /**
         * Reload settings (call after settings change)
         */
        async reloadSettings() {
          this.apiKeys = null;
          this.qualityLevels = null;
          await this.loadSettings();
        },

        /**
         * Get API key headers for requests
         */
        getApiKeyHeaders() {
          const headers = {};
          if (!this.apiKeys) return headers;

          // Map settings keys to header names
          const headerMap = {
            anthropic: 'X-Api-Key-Anthropic',
            openai: 'X-Api-Key-Openai',
            groq: 'X-Api-Key-Groq',
            gemini: 'X-Api-Key-Gemini',
            openrouter: 'X-Api-Key-Openrouter',
          };

          for (const [provider, headerName] of Object.entries(headerMap)) {
            const key = this.apiKeys[provider];
            if (key && key.length > 0) {
              headers[headerName] = key;
            }
          }

          return headers;
        },

        /**
         * Get model override for a juice level from settings
         */
        getModelOverride(juiceLevel) {
          if (!this.qualityLevels) return null;
          const config = this.qualityLevels[juiceLevel + 1]; // Settings uses 1-5, internal uses 0-4
          if (config && config.model) {
            return config.model;
          }
          return null;
        },

        async execute(program, params, options = {}) {
          // Ensure settings are loaded
          if (!this.apiKeys) {
            await this.loadSettings();
          }

          const juiceLevel = options.juiceLevel ?? this.juiceLevel;
          const reasoningLevel = options.reasoningLevel ?? this.reasoningLevel;

          // Build headers with API keys
          const headers = {
            'Content-Type': 'application/json',
            'X-Juice-Level': String(juiceLevel),
            'X-Reasoning-Level': String(reasoningLevel),
            ...this.getApiKeyHeaders(),
          };

          // Add model override if configured
          const modelOverride = this.getModelOverride(juiceLevel);
          if (modelOverride) {
            headers['X-Model-Override'] = modelOverride;
          }

          const response = await fetch(`${this.baseUrl}/${program}`, {
            method: 'POST',
            headers,
            body: JSON.stringify(params),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ detail: response.statusText }));
            throw new Error(error.detail || `AI request failed: ${response.status}`);
          }

          return response.json();
        },

        /**
         * Execute with streaming progress updates
         */
        async executeStream(program, params, callbacks = {}, options = {}) {
          // Ensure settings are loaded
          if (!this.apiKeys) {
            await this.loadSettings();
          }

          const juiceLevel = options.juiceLevel ?? this.juiceLevel;
          const reasoningLevel = options.reasoningLevel ?? this.reasoningLevel;

          // Build headers with API keys
          const headers = {
            'Content-Type': 'application/json',
            'X-Juice-Level': String(juiceLevel),
            'X-Reasoning-Level': String(reasoningLevel),
            'Accept': 'text/event-stream',
            ...this.getApiKeyHeaders(),
          };

          // Add model override if configured
          const modelOverride = this.getModelOverride(juiceLevel);
          if (modelOverride) {
            headers['X-Model-Override'] = modelOverride;
          }

          const response = await fetch(`${this.baseUrl}/${program}/stream`, {
            method: 'POST',
            headers,
            body: JSON.stringify(params),
          });

          if (!response.ok) {
            const error = await response.json().catch(() => ({ detail: response.statusText }));
            throw new Error(error.detail || `AI stream request failed: ${response.status}`);
          }

          // Parse SSE stream
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          let result = null;
          let currentEventType = null;

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop() || '';

            for (const line of lines) {
              // Track event type
              if (line.startsWith('event: ')) {
                currentEventType = line.slice(7).trim();
                continue;
              }

              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.slice(6));

                  // Route based on event type
                  if (currentEventType === 'model_start') {
                    callbacks.onModelStart?.(data.model, data);
                  } else if (currentEventType === 'model_complete') {
                    callbacks.onModelComplete?.(data.model, data);
                  } else if (currentEventType === 'status') {
                    callbacks.onStatus?.(data.step, data);
                  } else if (currentEventType === 'result') {
                    result = data;
                    callbacks.onResult?.(data);
                  } else if (currentEventType === 'error') {
                    callbacks.onError?.(new Error(data.message || data.error));
                  } else {
                    // Fallback: check data properties
                    if (data.step) {
                      callbacks.onStatus?.(data.step, data);
                    }
                    if (data.completion || data.fixed_text || data.response) {
                      result = data;
                      callbacks.onResult?.(data);
                    }
                  }

                  currentEventType = null; // Reset after processing
                } catch (e) {
                  // Skip invalid JSON
                }
              }
            }
          }

          return result;
        },

        cancel(requestId) {
          // Not implemented for simple client
        },

        cancelAll() {
          // Not implemented for simple client
        },
      };

      updateAiPanelStatus();
      console.log('[AI] Connected to AI server at', serverUrl);

      // Register custom programs with the backend
      registerCustomProgramsWithBackend();

      // Add Ctrl-K and comment syntax extensions now that aiClient is available
      addCtrlKAndCommentExtensions();

      // Render custom commands in the AI panel
      renderCustomCommandsInPanel();
    }

    /**
     * Register custom programs with the AI backend
     * Called when AI server connects and when settings change
     */
    async function registerCustomProgramsWithBackend() {
      if (!aiClient) return;

      try {
        // Get all custom commands from settings
        const commands = await electronAPI.settings.getAllCustomCommands();

        if (commands.length === 0) {
          console.log('[AI] No custom programs to register');
          return;
        }

        // Map to backend format
        const programs = commands.map(cmd => ({
          id: cmd.program || cmd.id,
          name: cmd.name,
          instructions: cmd.instructions,
          inputType: cmd.inputType || 'selection',
          outputType: cmd.outputType || 'replace',
        }));

        // Send to backend
        const response = await fetch(`${aiClient.baseUrl}/api/custom-programs/register`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ programs }),
        });

        if (response.ok) {
          const result = await response.json();
          console.log(`[AI] Registered ${result.count} custom programs`);
        } else {
          console.warn('[AI] Failed to register custom programs:', response.status);
        }
      } catch (e) {
        console.warn('[AI] Failed to register custom programs:', e.message);
      }
    }

    /**
     * Render custom commands in the AI panel sidebar
     */
    async function renderCustomCommandsInPanel() {
      const aiPanel = document.getElementById('panel-ai');
      if (!aiPanel) return;

      // Remove any existing custom sections
      aiPanel.querySelectorAll('.custom-commands-section').forEach(el => el.remove());

      // Get custom sections from settings
      const sections = await electronAPI.settings.getCustomSections();

      if (sections.length === 0) return;

      // Find where to insert (after the last built-in section)
      const panelContent = aiPanel.querySelector('.rail-panel-content');
      if (!panelContent) return;

      // Create HTML for custom sections
      for (const section of sections) {
        if (section.commands.length === 0) continue;

        const sectionEl = document.createElement('div');
        sectionEl.className = 'rail-panel-section custom-commands-section';
        sectionEl.dataset.sectionId = section.id;

        let html = `<div class="rail-panel-section-title">${section.name}</div>`;

        for (const cmd of section.commands) {
          const keyAttr = cmd.key ? `data-key="${cmd.key}"` : '';
          const keySpan = cmd.key ? `<span class="ai-cmd-key">${cmd.key}</span>` : '';
          const hint = cmd.inputType === 'selection' ? 'selection' :
                       cmd.inputType === 'cursor' ? 'cursor' : 'document';

          html += `
            <div class="ai-cmd custom-cmd" data-cmd="${cmd.program || cmd.id}" ${keyAttr}>
              ${keySpan}
              <span class="ai-cmd-label">${cmd.name}</span>
              <span class="ai-cmd-hint">${hint}</span>
            </div>
          `;
        }

        sectionEl.innerHTML = html;
        panelContent.appendChild(sectionEl);
      }

      // Add click handlers for custom commands
      aiPanel.querySelectorAll('.custom-cmd').forEach(el => {
        el.addEventListener('click', () => {
          const cmdId = el.dataset.cmd;
          if (!el.classList.contains('disabled') && !el.classList.contains('loading')) {
            executeCustomCommand(cmdId, el.dataset.key);
          }
        });
      });
    }

    /**
     * Execute a custom AI command
     */
    async function executeCustomCommand(programId, key) {
      if (!aiClient || !state?.editor?.view) {
        console.warn('[AI] Cannot execute custom command - no AI client or editor');
        return;
      }

      const view = state.editor.view;
      const doc = view.state.doc.toString();

      // Get command config from settings
      const commands = await electronAPI.settings.getAllCustomCommands();
      const cmdConfig = commands.find(c => (c.program || c.id) === programId);

      if (!cmdConfig) {
        console.warn('[AI] Custom command not found:', programId);
        return;
      }

      // Build context based on input type
      let params = {};
      const selection = view.state.selection.main;
      const cursorPos = selection.from;

      if (cmdConfig.inputType === 'selection') {
        if (selection.empty) {
          showAiProgress('Error', 'Please select text first');
          return;
        }
        params = {
          text: doc.slice(selection.from, selection.to),
          local_context: doc.slice(Math.max(0, selection.from - 500), Math.min(doc.length, selection.to + 500)),
          document_context: doc.slice(0, 5000),
        };
      } else if (cmdConfig.inputType === 'cursor') {
        params = {
          text_before_cursor: doc.slice(Math.max(0, cursorPos - 2000), cursorPos),
          local_context: doc.slice(Math.max(0, cursorPos - 500), Math.min(doc.length, cursorPos + 500)),
          document_context: doc.slice(0, 5000),
        };
      } else { // fullDoc
        params = {
          document_context: doc,
        };
      }

      // Show progress
      showAiProgress(cmdConfig.name, 'Processing...');

      try {
        const result = await aiClient.execute(programId, params);

        if (result.result) {
          // Apply the result
          if (cmdConfig.outputType === 'replace' && !selection.empty) {
            // Replace selection
            view.dispatch({
              changes: { from: selection.from, to: selection.to, insert: result.result },
            });
          } else {
            // Insert at cursor
            view.dispatch({
              changes: { from: cursorPos, insert: result.result },
            });
          }
          hideAiProgress();
        } else {
          showAiProgress('Error', 'No result from AI');
        }
      } catch (e) {
        console.error('[AI] Custom command error:', e);
        showAiProgress('Error', e.message);
      }
    }

    /**
     * Add Ctrl-K modal and comment syntax extensions to the editor
     * Called after aiClient is initialized
     */
    function addCtrlKAndCommentExtensions() {
      if (!state?.editor?.view || !aiClient) return;

      const editor = state.editor;

      // Create Ctrl-K modal extension (Mod-K to open AI command input at cursor)
      const ctrlK = mrmd.default?.ctrlK || mrmd.ctrlK;
      const ctrlKExtensions = ctrlK?.createCtrlKExtension?.({
        aiClient,
        juiceLevel: currentJuiceLevel,
        onError: (err) => {
          console.error('[Ctrl-K] Error:', err);
          showAiProgress('Error', err.message);
        },
      }) || [];

      // Create comment syntax extension (<!--! !--> markers)
      const commentSyntax = mrmd.default?.commentSyntax || mrmd.commentSyntax;
      const commentExtensions = commentSyntax?.createCommentSyntaxExtension?.({
        aiClient,
        juiceLevel: currentJuiceLevel,
      }) || [];

      if (ctrlKExtensions.length > 0 || commentExtensions.length > 0) {
        editor.view.dispatch({
          effects: mrmd.codemirror.StateEffect.appendConfig.of([
            ...ctrlKExtensions,
            ...commentExtensions,
          ].filter(Boolean)),
        });
        console.log('[AI] Ctrl-K and comment syntax extensions added');
      }
    }

    /**
     * Disconnect from AI server
     */
    function disconnectAiServer() {
      if (aiClient) {
        aiClient.cancelAll?.();
        aiClient = null;
        updateAiPanelStatus();
        console.log('[AI] Disconnected from AI server');
      }
    }

    /**
     * Update AI panel status display
     */
    function updateAiPanelStatus() {
      const statusEl = document.getElementById('ai-panel-status');
      if (!statusEl) return;

      if (aiClient) {
        statusEl.style.display = 'none';
      } else {
        statusEl.style.display = 'flex';
      }
    }

    /**
     * Show AI progress panel
     */
    function showAiProgress(title, model) {
      const progressEl = document.getElementById('ai-progress');
      const modelEl = document.getElementById('ai-progress-model');
      const modelsEl = document.getElementById('ai-progress-models');

      if (progressEl) {
        progressEl.style.display = 'block';
        progressEl.querySelector('.ai-progress-title').textContent = title || 'Working...';
      }
      if (modelEl) {
        modelEl.textContent = model || '';
      }
      if (modelsEl) {
        modelsEl.innerHTML = '';
      }
    }

    /**
     * Hide AI progress panel
     */
    function hideAiProgress() {
      const progressEl = document.getElementById('ai-progress');
      if (progressEl) {
        progressEl.style.display = 'none';
      }
    }

    /**
     * Update model progress chips
     */
    function updateModelProgress(modelName, status) {
      const modelsEl = document.getElementById('ai-progress-models');
      if (!modelsEl) return;

      // Shorten model name for display
      const shortName = modelName.replace(/^(claude-|gpt-|gemini-)/, '').slice(0, 12);

      // Find or create chip for this model
      let chip = modelsEl.querySelector(`[data-model="${modelName}"]`);
      if (!chip) {
        chip = document.createElement('span');
        chip.className = 'ai-progress-chip';
        chip.dataset.model = modelName;
        chip.textContent = shortName;
        modelsEl.appendChild(chip);
      }

      // Update status
      chip.classList.remove('running', 'done', 'pending');
      if (status === 'running') {
        chip.classList.add('running');
      } else if (status === 'done') {
        chip.classList.add('done');
      } else if (status === 'pending') {
        chip.classList.add('pending');
      }
    }

    const JS_RUNTIME_AI_HINT = [
      'JavaScript runtime note:',
      '- JS cells run in script/eval context, not ESM module mode.',
      '- Do NOT use static imports like: import x from "...";',
      '- Use dynamic imports instead: const mod = await import("https://...");',
      '- Prefer cached helper when available: globalThis.loadPkg(name, url).',
      '- For cross-cell variables, assign globally (e.g. d3 = await ...), not const/let.',
    ].join('\n');

    function isJavaScriptLanguage(language) {
      const lang = String(language || '').toLowerCase();
      return lang === 'javascript' || lang === 'js' || lang === 'node' || lang === 'typescript' || lang === 'ts';
    }

    function withRuntimeHintContext(context, language) {
      if (!isJavaScriptLanguage(language) || !context) return context;
      return {
        ...context,
        localContext: `${JS_RUNTIME_AI_HINT}\n\n${context.localContext || ''}`,
      };
    }

    /**
     * Execute an AI command
     * @param {string} cmdId - Command ID
     */
    async function executeAiCommand(cmdId) {
      const cmd = AI_COMMANDS[cmdId];
      if (!cmd) return;

      if (!aiClient) {
        console.warn('[AI] AI server not connected');
        return;
      }

      if (!state.editor?.view) {
        console.warn('[AI] No editor active');
        return;
      }

      const view = state.editor.view;
      const cmdEl = document.querySelector(`.ai-cmd[data-cmd="${cmdId}"]`);

      // Get AI context using mrmd.default.ai helpers
      const context = mrmd.default.ai.getAiContext(view);

      // Check requirements
      if (cmd.requiresSelection && !context.selectedText) {
        console.warn('[AI] This command requires selected text');
        return;
      }

      // Detect code language if needed
      let language = null;
      if (cmd.codeOnly) {
        language = detectCodeLanguageAtCursor(view);
      }
      const runtimeAwareContext = withRuntimeHintContext(context, language);

      const juiceLevel = currentJuiceLevel;
      const reasoningLevel = currentReasoningLevel;

      // Determine insert position
      let from, to;
      if (cmd.insertAtEnd) {
        // Insert at end of document
        const docLength = view.state.doc.length;
        from = docLength;
        to = docLength;
      } else if (cmd.type === 'insert') {
        from = context.cursorPos;
        to = context.cursorPos;
      } else {
        from = context.selectionFrom;
        to = context.selectionTo;
      }

      // Show loading state in panel
      cmdEl?.classList.add('loading');
      showAiProgress('Working...', '');

      // Get AI integration for editor shimmer
      const ai = mrmd.default?.ai || mrmd.ai;
      const opId = ai.generateOperationId();
      const originalText = cmd.type === 'replace' ? view.state.doc.sliceString(from, to) : '';

      // Check if this is Ultimate mode (juice=4) - use multi-response picker
      const isUltimateMode = juiceLevel === 4;

      // For Ultimate mode, start with multi-response picker immediately
      if (isUltimateMode) {
        view.dispatch({
          effects: ai.startAiOperationMulti.of({
            id: opId,
            type: cmd.type,
            from,
            to,
            originalText,
          }),
        });
      } else {
        // Regular mode - show loading shimmer
        view.dispatch({
          effects: ai.startAiOperation.of({
            id: opId,
            type: cmd.type,
            from,
            to,
            originalText,
          }),
        });
      }

      const params = cmd.buildParams(runtimeAwareContext, language);

      // Check if params is null (e.g., no comments to address)
      if (params === null) {
        console.log('[AI] Command has nothing to process');
        cmdEl?.classList.remove('loading');
        view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
        hideAiProgress();
        return;
      }

      try {
        // Track individual model responses as they complete
        const modelResponses = new Map(); // model -> response text

        // Use streaming for progress updates
        const result = await aiClient.executeStream(cmd.program, params, {
          onStatus: (step, data) => {
            console.log('[AI] Status:', step, data);
            if (step === 'starting_multi_model') {
              // Ultimate mode - add placeholder responses for each model
              showAiProgress('Multi-model synthesis...', `${data.total} models`);
              data.models?.forEach(m => {
                updateModelProgress(m, 'pending');
                // Add loading placeholder to picker
                view.dispatch({
                  effects: ai.addAiResponse.of({
                    id: opId,
                    model: m,
                    response: null,
                    status: 'loading',
                    isSynthesized: false,
                  }),
                });
              });
            } else if (step === 'calling_model') {
              showAiProgress('Working...', data.model || '');
            } else if (step === 'starting') {
              const title = data.juice_name || 'Working...';
              showAiProgress(title, data.model || '');
            } else if (step === 'synthesizing') {
              showAiProgress('Synthesizing...', 'Combining responses');
            }
          },
          onModelStart: (modelName, data) => {
            console.log('[AI] Model started:', modelName);
            updateModelProgress(modelName, 'running');
            // Update status in picker
            if (isUltimateMode) {
              view.dispatch({
                effects: ai.updateAiResponse.of({
                  id: opId,
                  model: modelName,
                  status: 'loading',
                }),
              });
            }
          },
          onModelComplete: (modelName, data) => {
            console.log('[AI] Model complete:', modelName, data);
            updateModelProgress(modelName, 'done');
            // If data contains response, update the picker
            if (isUltimateMode && data?.response) {
              // Extract the actual text from the response dict using resultField
              const responseDict = data.response;
              const responseText = responseDict[cmd.resultField] ||
                                   responseDict.completion ||
                                   responseDict.fixed_text ||
                                   responseDict.response ||
                                   (typeof responseDict === 'string' ? responseDict : JSON.stringify(responseDict));

              modelResponses.set(modelName, responseText);
              view.dispatch({
                effects: ai.updateAiResponse.of({
                  id: opId,
                  model: modelName,
                  response: responseText,
                  status: 'complete',
                }),
              });
            } else if (isUltimateMode && data?.success === false) {
              // Handle model error
              view.dispatch({
                effects: ai.updateAiResponse.of({
                  id: opId,
                  model: modelName,
                  error: data.error || 'Model failed',
                  status: 'error',
                }),
              });
            }
          },
          onError: (err) => {
            console.error('[AI] Stream error:', err);
          },
        }, { juiceLevel, reasoningLevel });

        hideAiProgress();

        if (!result) {
          console.warn('[AI] No result from AI');
          view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
          return;
        }

        // Handle 'edits' type commands (comment addressing)
        if (cmd.type === 'edits') {
          const edits = result.edits || result[cmd.resultField] || [];
          if (edits && edits.length > 0) {
            // Apply edits using the comment syntax module
            const commentSyntax = mrmd.default?.commentSyntax || mrmd.commentSyntax;
            const doc = view.state.doc.toString();
            const changes = [];

            for (const edit of edits) {
              if (edit.find === '' || edit.find === null) {
                // Insert at cursor
                changes.push({ from: context.cursorPos, insert: edit.replace });
              } else {
                // Find and replace
                const idx = doc.indexOf(edit.find);
                if (idx >= 0) {
                  changes.push({ from: idx, to: idx + edit.find.length, insert: edit.replace });
                } else {
                  console.warn('[AI] Could not find text to replace:', edit.find.slice(0, 50));
                }
              }
            }

            if (changes.length > 0) {
              view.dispatch({ changes });
            }
          }

          // Cancel the loading operation
          view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
          hideAiProgress();
          return;
        }

        // Extract the result text
        const newText = result[cmd.resultField] || result.completion || result.fixed_text || result.response || '';

        // Check if we have multiple individual responses to show
        const individualResponses = result._individual_responses;
        const hasMultipleResponses = individualResponses && individualResponses.length > 1;

        if (hasMultipleResponses || isUltimateMode) {
          // Use multi-response picker
          console.log('[AI] Using multi-response picker with', individualResponses?.length || 0, 'responses');

          // If not already in multi mode, switch to it
          if (!isUltimateMode) {
            // Cancel the loading operation and start multi
            view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
            const multiOpId = ai.generateOperationId();
            view.dispatch({
              effects: ai.startAiOperationMulti.of({
                id: multiOpId,
                type: cmd.type,
                from,
                to,
                originalText,
              }),
            });

            // Add all individual responses
            if (individualResponses) {
              individualResponses.forEach((resp, idx) => {
                view.dispatch({
                  effects: ai.addAiResponse.of({
                    id: multiOpId,
                    model: resp.model,
                    response: resp.response,
                    error: resp.error,
                    status: resp.error ? 'error' : 'complete',
                    isSynthesized: false,
                  }),
                });
              });
            }

            // Add synthesized response as last option
            if (newText) {
              view.dispatch({
                effects: ai.addAiResponse.of({
                  id: multiOpId,
                  model: 'Synthesized',
                  response: newText,
                  status: 'complete',
                  isSynthesized: true,
                }),
              });
            }
          } else {
            // Already in multi mode, just add final responses
            if (individualResponses) {
              individualResponses.forEach((resp) => {
                // Update or add responses
                view.dispatch({
                  effects: ai.updateAiResponse.of({
                    id: opId,
                    model: resp.model,
                    response: resp.response,
                    error: resp.error,
                    status: resp.error ? 'error' : 'complete',
                  }),
                });
              });
            }

            // Add synthesized response
            if (newText) {
              view.dispatch({
                effects: ai.addAiResponse.of({
                  id: opId,
                  model: 'Synthesized',
                  response: newText,
                  status: 'complete',
                  isSynthesized: true,
                }),
              });
              // Select the synthesized response by default
              const state = view.state.field(ai.aiState);
              const op = state.operations.get(opId);
              if (op) {
                const synthIndex = (op.responses?.length || 0);
                view.dispatch({
                  effects: ai.setSelectedResponse.of({ id: opId, index: synthIndex }),
                });
              }
            }
          }

          // Don't insert text yet - wait for user to pick
          return;
        }

        // Single response - use original inline approach
        if (!newText) {
          console.warn('[AI] Empty result from AI');
          view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
          return;
        }

        // Insert/replace text using AI integration for accept/reject UI
        if (cmd.type === 'insert') {
          view.dispatch({
            changes: { from, insert: newText },
            effects: ai.completeAiOperation.of({ id: opId, newText }),
          });
        } else {
          view.dispatch({
            changes: { from, to, insert: newText },
            effects: ai.completeAiOperation.of({ id: opId, newText }),
          });
        }
      } catch (err) {
        console.error('[AI] Command failed:', err);
        // Cancel the AI operation on error
        view.dispatch({ effects: ai.cancelAiOperation.of({ id: opId }) });
        hideAiProgress();
      } finally {
        cmdEl?.classList.remove('loading');
      }
    }

    /**
     * Detect the programming language at cursor position
     * @param {EditorView} view
     * @returns {string}
     */
    function detectCodeLanguageAtCursor(view) {
      // Look for ```language in nearby text
      const pos = view.state.selection.main.head;
      const text = view.state.doc.toString();
      const before = text.slice(Math.max(0, pos - 500), pos);
      const match = before.match(/```(\w+)[^\`]*$/);
      return match ? match[1] : 'python';
    }

    /**
     * Update command states based on selection
     */
    function updateAiCommandStates() {
      if (!state.editor?.view) return;

      const hasSelection = state.editor.view.state.selection.main.from !==
                           state.editor.view.state.selection.main.to;

      document.querySelectorAll('.ai-cmd').forEach(el => {
        const cmdId = el.dataset.cmd;
        const cmd = AI_COMMANDS[cmdId];
        if (cmd?.requiresSelection && !hasSelection) {
          el.classList.add('disabled');
        } else {
          el.classList.remove('disabled');
        }
      });
    }

    /**
     * Current juice level (0-4)
     */
    let currentJuiceLevel = 1;

    /**
     * Current reasoning level (0-5)
     */
    let currentReasoningLevel = 1;

    /**
     * Map of juice levels to whether they support reasoning
     * Level 0 (Groq/Kimi K2) does NOT support reasoning
     */
    const JUICE_SUPPORTS_REASONING = {
      0: false,  // Groq/Kimi K2 - no reasoning support
      1: true,   // Claude Sonnet 4.5
      2: true,   // Gemini 3 Pro
      3: true,   // Claude Opus 4.5
      4: true,   // Multi-model (all support reasoning)
    };

    /**
     * Set the juice level and update UI
     */
    function setJuiceLevel(level) {
      currentJuiceLevel = Math.max(0, Math.min(4, level));
      if (aiClient) {
        aiClient.juiceLevel = currentJuiceLevel;
      }
      // Update UI
      document.querySelectorAll('.ai-juice-btn').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.dataset.juice) === currentJuiceLevel);
      });

      // Enable/disable reasoning buttons based on model support
      const supportsReasoning = JUICE_SUPPORTS_REASONING[currentJuiceLevel] ?? true;
      document.querySelectorAll('.ai-reasoning-btn').forEach(btn => {
        btn.disabled = !supportsReasoning;
        btn.classList.toggle('disabled', !supportsReasoning);
      });

      // If reasoning not supported and currently set to non-zero, reset to 0
      if (!supportsReasoning && currentReasoningLevel > 0) {
        setReasoningLevel(0);
      }
    }

    /**
     * Set the reasoning level and update UI
     */
    function setReasoningLevel(level) {
      currentReasoningLevel = Math.max(0, Math.min(5, level));
      if (aiClient) {
        aiClient.reasoningLevel = currentReasoningLevel;
      }
      // Update UI
      document.querySelectorAll('.ai-reasoning-btn').forEach(btn => {
        btn.classList.toggle('selected', parseInt(btn.dataset.reasoning) === currentReasoningLevel);
      });
    }

    // =========================================================================
    // AI Panel Keyboard Mode
    // =========================================================================

    /**
     * State for AI panel keyboard mode
     */
    let aiPanelKeyboardMode = false;
    let aiPanelKeyHandler = null;

    /**
     * Map of keyboard shortcuts to command IDs
     * Built dynamically from data-key attributes
     */
    function buildAiKeyMap() {
      const keyMap = {};
      document.querySelectorAll('.ai-cmd[data-key]').forEach(el => {
        const key = el.dataset.key.toLowerCase();
        const cmdId = el.dataset.cmd;
        keyMap[key] = cmdId;
      });
      return keyMap;
    }

    /**
     * Handle keyboard events when AI panel is in keyboard mode
     */
    function handleAiPanelKeydown(e) {
      if (!aiPanelKeyboardMode) return;

      const key = e.key.toLowerCase();
      const code = e.code; // e.g., 'Digit1', 'KeyG', etc.
      const keyMap = buildAiKeyMap();

      // Escape to close panel and disable keyboard mode
      if (e.key === 'Escape') {
        e.preventDefault();
        e.stopPropagation();
        disableAiPanelKeyboardMode();
        closePanel('ai');
        // Return focus to editor
        state.editor?.view?.focus();
        return;
      }

      // Shift+1-5 for juice/quality level (use e.code since e.key gives '!@#$%')
      if (e.shiftKey && code >= 'Digit1' && code <= 'Digit5') {
        e.preventDefault();
        e.stopPropagation();
        const digit = parseInt(code.charAt(5), 10); // Extract digit from 'Digit1'
        setJuiceLevel(digit - 1); // 1-5 maps to 0-4
        return;
      }

      // 0-5 for reasoning level (without shift)
      if (!e.shiftKey && code >= 'Digit0' && code <= 'Digit5') {
        e.preventDefault();
        e.stopPropagation();
        const digit = parseInt(code.charAt(5), 10);
        setReasoningLevel(digit);
        return;
      }

      // Command keys
      if (keyMap[key]) {
        e.preventDefault();
        e.stopPropagation();
        const cmdId = keyMap[key];
        const cmdEl = document.querySelector(`.ai-cmd[data-cmd="${cmdId}"]`);
        if (cmdEl && !cmdEl.classList.contains('disabled') && !cmdEl.classList.contains('loading')) {
          disableAiPanelKeyboardMode();
          executeAiCommand(cmdId);
        }
        return;
      }
    }

    /**
     * Enable keyboard mode for the AI panel
     * Called when panel is opened via long-press 'j'
     */
    function enableAiPanelKeyboardMode() {
      if (aiPanelKeyboardMode) return;

      aiPanelKeyboardMode = true;

      // Add visual indicator
      const panel = document.getElementById('panel-ai');
      panel?.classList.add('keyboard-mode');

      // Show hint
      const hint = document.getElementById('ai-keyboard-hint');
      if (hint) hint.style.display = 'inline';

      // Add capture-phase handler to intercept all keys
      aiPanelKeyHandler = (e) => handleAiPanelKeydown(e);
      document.addEventListener('keydown', aiPanelKeyHandler, { capture: true });

      console.log('[AI] Keyboard mode enabled');
    }

    /**
     * Disable keyboard mode for the AI panel
     */
    function disableAiPanelKeyboardMode() {
      if (!aiPanelKeyboardMode) return;

      aiPanelKeyboardMode = false;

      // Remove visual indicator
      const panel = document.getElementById('panel-ai');
      panel?.classList.remove('keyboard-mode');

      // Hide hint
      const hint = document.getElementById('ai-keyboard-hint');
      if (hint) hint.style.display = 'none';

      // Remove handler
      if (aiPanelKeyHandler) {
        document.removeEventListener('keydown', aiPanelKeyHandler, { capture: true });
        aiPanelKeyHandler = null;
      }

      console.log('[AI] Keyboard mode disabled');
    }

    /**
     * Initialize the AI Commands panel
     */
    function initAiPanel() {
      // Attach click handlers to AI commands
      document.querySelectorAll('.ai-cmd').forEach(el => {
        el.addEventListener('click', () => {
          const cmdId = el.dataset.cmd;
          if (!el.classList.contains('disabled') && !el.classList.contains('loading')) {
            executeAiCommand(cmdId);
          }
        });
      });

      // Attach click handlers to juice level buttons
      document.querySelectorAll('.ai-juice-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          setJuiceLevel(parseInt(btn.dataset.juice));
        });
      });

      // Attach click handlers to reasoning level buttons
      document.querySelectorAll('.ai-reasoning-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          setReasoningLevel(parseInt(btn.dataset.reasoning));
        });
      });

      // Update command states when panel opens
      const originalOpenPanel = openPanel;
      openPanel = function(panelId) {
        originalOpenPanel(panelId);
        if (panelId === 'ai') {
          updateAiPanelStatus();
          updateAiCommandStates();
        }
      };

      // Disable keyboard mode when panel closes
      const originalClosePanel = closePanel;
      closePanel = function(panelId) {
        if (panelId === 'ai' || railState.activePanel === 'ai') {
          disableAiPanelKeyboardMode();
        }
        originalClosePanel(panelId);
      };

      // Update AI panel status initially
      updateAiPanelStatus();

      // Listen for editor selection changes (poll every 200ms when panel is open)
      setInterval(() => {
        if (railState.activePanel === 'ai') {
          updateAiCommandStates();
        }
      }, 200);
    }

    // Initialize AI panel on load
    document.addEventListener('DOMContentLoaded', () => {
      initAiPanel();
      initAiSettingsModal();
    });

    // =========================================================================
    // AI SETTINGS MODAL
    // =========================================================================

    /**
     * LiteLLM model format examples for documentation
     */
    const LITELLM_EXAMPLES = [
      { provider: 'Anthropic', format: 'anthropic/claude-sonnet-4-5', envVar: 'ANTHROPIC_API_KEY' },
      { provider: 'OpenAI', format: 'openai/gpt-4o', envVar: 'OPENAI_API_KEY' },
      { provider: 'Groq', format: 'groq/llama-3.3-70b-versatile', envVar: 'GROQ_API_KEY' },
      { provider: 'Google', format: 'gemini/gemini-2.0-flash', envVar: 'GEMINI_API_KEY' },
      { provider: 'OpenRouter', format: 'openrouter/anthropic/claude-3.5-sonnet', envVar: 'OPENROUTER_API_KEY' },
      { provider: 'Together', format: 'together_ai/meta-llama/Llama-3-70b', envVar: 'TOGETHERAI_API_KEY' },
      { provider: 'Fireworks', format: 'fireworks_ai/llama-v3-70b-instruct', envVar: 'FIREWORKS_API_KEY' },
    ];

    /**
     * Initialize the AI Settings Modal
     */
    function initAiSettingsModal() {
      const overlay = document.getElementById('ai-settings-overlay');
      const settingsBtn = document.getElementById('ai-settings-btn');
      const closeBtn = document.getElementById('ai-settings-close');
      const doneBtn = document.getElementById('ai-settings-done');
      const resetBtn = document.getElementById('ai-settings-reset');
      const tabs = document.querySelectorAll('.settings-tab');

      if (!overlay || !settingsBtn) return;

      // Open modal
      settingsBtn.addEventListener('click', () => {
        openAiSettingsModal();
      });

      // Close modal
      closeBtn.addEventListener('click', closeAiSettingsModal);
      doneBtn.addEventListener('click', closeAiSettingsModal);

      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          closeAiSettingsModal();
        }
      });

      // Close on Escape
      overlay.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeAiSettingsModal();
        }
      });

      // Tab switching
      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabId = tab.dataset.tab;
          switchSettingsTab(tabId);
        });
      });

      // Reset button
      resetBtn.addEventListener('click', async () => {
        if (confirm('Reset all AI settings to defaults? This will clear your API keys and custom commands.')) {
          await electronAPI.settings.reset();
          await loadAiSettings();
        }
      });

      // Add section button
      const addSectionBtn = document.getElementById('add-section-btn');
      if (addSectionBtn) {
        addSectionBtn.addEventListener('click', async () => {
          const name = prompt('Enter section name:');
          if (name && name.trim()) {
            await electronAPI.settings.addCustomSection(name.trim());
            await loadCustomSections();
          }
        });
      }

      // Initialize command form handlers
      initCommandForm();
    }

    /**
     * Open the AI Settings modal and load data
     */
    async function openAiSettingsModal() {
      const overlay = document.getElementById('ai-settings-overlay');
      overlay.classList.add('visible');
      await loadAiSettings();
    }

    /**
     * Close the AI Settings modal
     */
    function closeAiSettingsModal() {
      const overlay = document.getElementById('ai-settings-overlay');
      overlay.classList.remove('visible');

      // Reload settings into aiClient so changes take effect immediately
      if (aiClient) {
        aiClient.reloadSettings();

        // Re-register custom programs with backend and re-render in panel
        registerCustomProgramsWithBackend();
        renderCustomCommandsInPanel();
      }
    }

    /**
     * Switch between settings tabs
     */
    function switchSettingsTab(tabId) {
      // Update tab buttons
      document.querySelectorAll('.settings-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === tabId);
      });

      // Update tab content
      document.querySelectorAll('.settings-tab-content').forEach(content => {
        content.style.display = content.id === `tab-${tabId}` ? 'block' : 'none';
      });
    }

    /**
     * Load all AI settings into the modal
     */
    async function loadAiSettings() {
      await Promise.all([
        loadApiKeys(),
        loadQualityLevels(),
        loadCustomSections(),
      ]);
    }

    /**
     * Load API keys into the settings panel
     */
    async function loadApiKeys() {
      const container = document.getElementById('api-keys-list');
      if (!container) return;

      // Get all API keys from settings (includes any custom providers)
      const keys = await electronAPI.settings.getApiKeys(true); // masked
      const unmaskedKeys = await electronAPI.settings.getApiKeys(false); // for checking if set

      // Common providers (shown first even if empty)
      const commonProviders = ['anthropic', 'openai', 'groq', 'gemini', 'openrouter'];

      // Collect all providers: common ones + any others in settings
      const allProviders = new Set([...commonProviders, ...Object.keys(unmaskedKeys)]);

      let html = '';
      for (const providerId of allProviders) {
        const maskedKey = keys[providerId] || '';
        const hasKey = unmaskedKeys[providerId] && unmaskedKeys[providerId].length > 0;
        const isCustom = !commonProviders.includes(providerId);

        html += `
          <div class="api-key-row" data-provider="${providerId}">
            <div class="api-key-provider">${providerId}</div>
            <div class="api-key-input-wrap">
              <input type="password" class="api-key-input"
                     placeholder="Enter API key..."
                     data-provider="${providerId}"
                     value="${hasKey ? maskedKey : ''}"
                     ${hasKey ? 'data-has-key="true"' : ''}>
            </div>
            <div class="api-key-status ${hasKey ? 'valid' : 'empty'}">
              ${hasKey ? '✓ Set' : '—'}
            </div>
            ${isCustom ? `
              <button class="api-key-delete-btn" data-provider="${providerId}" title="Remove provider">
                <svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M4 4l8 8M12 4l-8 8"/>
                </svg>
              </button>
            ` : `
              <button class="api-key-test-btn" data-provider="${providerId}" ${!hasKey ? 'disabled' : ''}>
                Test
              </button>
            `}
          </div>
        `;
      }

      container.innerHTML = html;

      // Add event listeners for API key inputs
      container.querySelectorAll('.api-key-input').forEach(input => {
        // On focus, if key exists, clear to allow new input
        input.addEventListener('focus', function() {
          if (this.dataset.hasKey === 'true') {
            this.value = '';
            this.type = 'text';
          }
        });

        // On blur, save if changed
        input.addEventListener('blur', async function() {
          const provider = this.dataset.provider;
          const value = this.value.trim();

          // If user cleared the field and there was a key, don't save empty
          if (value === '' && this.dataset.hasKey === 'true') {
            // Restore masked value
            const keys = await electronAPI.settings.getApiKeys(true);
            this.value = keys[provider] || '';
            this.type = 'password';
            return;
          }

          // If user entered a new key (not the masked placeholder)
          if (value && !value.includes('•')) {
            await electronAPI.settings.setApiKey(provider, value);
            this.dataset.hasKey = 'true';
            this.type = 'password';

            // Update status
            const row = this.closest('.api-key-row');
            const status = row.querySelector('.api-key-status');
            const testBtn = row.querySelector('.api-key-test-btn');
            status.className = 'api-key-status valid';
            status.textContent = '✓ Set';
            testBtn.disabled = false;

            // Mask the value
            const keys = await electronAPI.settings.getApiKeys(true);
            this.value = keys[provider] || '';
          }
        });

        // Show as text while typing
        input.addEventListener('input', function() {
          if (!this.value.includes('•')) {
            this.type = 'text';
          }
        });
      });

      // Add test button listeners
      container.querySelectorAll('.api-key-test-btn').forEach(btn => {
        btn.addEventListener('click', async function() {
          const provider = this.dataset.provider;
          await testApiKey(provider, this);
        });
      });

      // Add delete button listeners (for custom providers)
      container.querySelectorAll('.api-key-delete-btn').forEach(btn => {
        btn.addEventListener('click', async function() {
          const provider = this.dataset.provider;
          if (confirm(`Remove ${provider} API key?`)) {
            await electronAPI.settings.setApiKey(provider, '');
            await loadApiKeys(); // Refresh the list
          }
        });
      });

      // Add Provider button handler
      const addBtn = document.getElementById('add-api-key-btn');
      if (addBtn && !addBtn._hasListener) {
        addBtn._hasListener = true;
        addBtn.addEventListener('click', async function() {
          const provider = prompt('Enter provider name (e.g., together_ai, fireworks_ai, mistral, deepseek, ollama):');
          if (provider && provider.trim()) {
            const providerId = provider.trim().toLowerCase().replace(/\s+/g, '_');
            // Add empty key to create the row
            await electronAPI.settings.setApiKey(providerId, '');
            await loadApiKeys(); // Refresh to show new row
            // Focus the new input
            const newInput = document.querySelector(`.api-key-input[data-provider="${providerId}"]`);
            if (newInput) {
              newInput.focus();
            }
          }
        });
      }
    }

    /**
     * Test an API key
     */
    async function testApiKey(provider, button) {
      const row = button.closest('.api-key-row');
      const status = row.querySelector('.api-key-status');

      button.disabled = true;
      button.textContent = 'Testing...';
      status.className = 'api-key-status testing';
      status.textContent = '...';

      try {
        // Get the actual key
        const key = await electronAPI.settings.getApiKey(provider);
        if (!key) {
          throw new Error('No key set');
        }

        // Test based on provider
        const providers = await electronAPI.settings.getApiProviders();
        const providerInfo = providers[provider];

        let testUrl = providerInfo.testEndpoint;
        let headers = { 'Content-Type': 'application/json' };

        // Set auth header based on provider
        if (provider === 'anthropic') {
          headers['x-api-key'] = key;
          headers['anthropic-version'] = '2023-06-01';
        } else if (provider === 'gemini') {
          testUrl = `${testUrl}?key=${key}`;
        } else {
          headers['Authorization'] = `Bearer ${key}`;
        }

        const response = await fetch(testUrl, {
          method: 'GET',
          headers,
        });

        if (response.ok || response.status === 200) {
          status.className = 'api-key-status valid';
          status.textContent = '✓ Valid';
        } else {
          throw new Error(`HTTP ${response.status}`);
        }
      } catch (e) {
        status.className = 'api-key-status invalid';
        status.textContent = '✗ Invalid';
        console.warn(`[Settings] API key test failed for ${provider}:`, e.message);
      }

      button.disabled = false;
      button.textContent = 'Test';
    }

    /**
     * Load quality levels into the settings panel
     */
    async function loadQualityLevels() {
      const container = document.getElementById('quality-levels-list');
      if (!container) return;

      const levels = await electronAPI.settings.getQualityLevels();

      let html = '';
      for (let i = 1; i <= 5; i++) {
        const level = levels[i];
        const isMulti = level.type === 'multi';

        html += `
          <div class="quality-level-row" data-level="${i}">
            <div class="quality-level-badge">${i}</div>
            <div class="quality-level-info">
              <div class="quality-level-name">${level.name}</div>
              <div class="quality-level-desc">${isMulti ? 'Multi-model synthesis' : 'Single model'}</div>
            </div>
            ${isMulti ? `
              <div style="font-size: 11px; color: var(--text-dim);">
                Multi-model (configure in code)
              </div>
            ` : `
              <input type="text" class="quality-level-input" data-level="${i}"
                     value="${level.model || ''}"
                     placeholder="provider/model-name">
            `}
          </div>
        `;
      }

      container.innerHTML = html;

      // Add blur listeners for text inputs (save on blur)
      container.querySelectorAll('.quality-level-input').forEach(input => {
        input.addEventListener('blur', async function() {
          const level = parseInt(this.dataset.level);
          const model = this.value.trim();
          if (model) {
            await electronAPI.settings.setQualityLevelModel(level, model);
          }
        });

        // Also save on Enter key
        input.addEventListener('keydown', async function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            this.blur();
          }
        });
      });
    }

    /**
     * Load custom sections into the settings panel
     */
    // Cache sections data for editing
    let cachedSections = [];

    async function loadCustomSections() {
      const container = document.getElementById('custom-sections-list');
      if (!container) return;

      const sections = await electronAPI.settings.getCustomSections();
      cachedSections = sections; // Cache for edit lookups

      if (sections.length === 0) {
        container.innerHTML = `
          <div style="color: var(--text-dim); font-size: 12px; padding: 16px; text-align: center;">
            No custom sections yet. Click "Add Section" to create one.
          </div>
        `;
        return;
      }

      let html = '';
      for (const section of sections) {
        html += `
          <div class="custom-section-row" data-section-id="${section.id}">
            <div class="custom-section-name">${section.name}</div>
            <div class="custom-section-count">${section.commands.length} command${section.commands.length !== 1 ? 's' : ''}</div>
            <button class="custom-section-delete" data-section-id="${section.id}" title="Delete section">
              <svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
                <path d="M4 4l8 8M12 4l-8 8"/>
              </svg>
            </button>
          </div>
        `;

        // Show commands in this section
        if (section.commands.length > 0) {
          html += '<div style="margin-left: 12px; margin-bottom: 8px;">';
          for (const cmd of section.commands) {
            const keyBadge = cmd.key ? `<span style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; background: var(--bg-tertiary); border-radius: 3px; font-size: 10px; font-weight: 600; color: var(--text-muted);">${cmd.key}</span>` : '';
            html += `
              <div class="custom-command-item" data-section-id="${section.id}" data-command-id="${cmd.id}">
                ${keyBadge}
                <div class="custom-command-name">${cmd.name}</div>
                <div class="custom-command-meta">${cmd.inputType} → ${cmd.outputType}</div>
                <div class="custom-command-actions">
                  <button class="custom-command-btn edit" data-section-id="${section.id}" data-command-id="${cmd.id}" title="Edit">
                    <svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M11.5 2.5l2 2L5 13l-2.5.5.5-2.5 8.5-8.5z"/>
                    </svg>
                  </button>
                  <button class="custom-command-btn delete" data-section-id="${section.id}" data-command-id="${cmd.id}" title="Delete">
                    <svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
                      <path d="M4 4l8 8M12 4l-8 8"/>
                    </svg>
                  </button>
                </div>
              </div>
            `;
          }
          html += '</div>';
        }

        // Add command button for this section
        html += `
          <button class="add-command-btn" data-section-id="${section.id}" style="margin-bottom: 16px;">
            <svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M8 3v10M3 8h10"/></svg>
            Add Command
          </button>
        `;
      }

      container.innerHTML = html;

      // Delete section handlers
      container.querySelectorAll('.custom-section-delete').forEach(btn => {
        btn.addEventListener('click', async function(e) {
          e.stopPropagation();
          const sectionId = this.dataset.sectionId;
          if (confirm('Delete this section and all its commands?')) {
            await electronAPI.settings.removeCustomSection(sectionId);
            await loadCustomSections();
          }
        });
      });

      // Edit command handlers
      container.querySelectorAll('.custom-command-btn.edit').forEach(btn => {
        btn.addEventListener('click', function(e) {
          e.stopPropagation();
          const sectionId = this.dataset.sectionId;
          const commandId = this.dataset.commandId;
          // Find the command data
          const section = cachedSections.find(s => s.id === sectionId);
          const command = section?.commands.find(c => c.id === commandId);
          if (command) {
            showCommandForm(sectionId, command);
          }
        });
      });

      // Delete command handlers
      container.querySelectorAll('.custom-command-btn.delete').forEach(btn => {
        btn.addEventListener('click', async function(e) {
          e.stopPropagation();
          const sectionId = this.dataset.sectionId;
          const commandId = this.dataset.commandId;
          if (confirm('Delete this command?')) {
            await electronAPI.settings.removeCustomCommand(sectionId, commandId);
            await loadCustomSections();
          }
        });
      });

      // Add command handlers
      container.querySelectorAll('.add-command-btn').forEach(btn => {
        btn.addEventListener('click', async function() {
          const sectionId = this.dataset.sectionId;
          await showAddCommandDialog(sectionId);
        });
      });
    }

    /**
     * Show dialog to add a custom command
     */
    // Track current command being edited
    let currentCommandEdit = null; // { sectionId, commandId } or null for new

    /**
     * Show the command form for creating or editing a command
     */
    function showCommandForm(sectionId, command = null) {
      const overlay = document.getElementById('command-form-overlay');
      const title = document.getElementById('command-form-title');
      const nameInput = document.getElementById('command-name');
      const inputTypeSelect = document.getElementById('command-input-type');
      const outputTypeSelect = document.getElementById('command-output-type');
      const instructionsInput = document.getElementById('command-instructions');
      const keyInput = document.getElementById('command-key');

      // Set up for new or edit
      if (command) {
        title.textContent = 'Edit Command';
        nameInput.value = command.name || '';
        inputTypeSelect.value = command.inputType || 'selection';
        outputTypeSelect.value = command.outputType || 'replace';
        instructionsInput.value = command.instructions || '';
        keyInput.value = command.key || '';
        currentCommandEdit = { sectionId, commandId: command.id };
      } else {
        title.textContent = 'New Command';
        nameInput.value = '';
        inputTypeSelect.value = 'selection';
        outputTypeSelect.value = 'replace';
        instructionsInput.value = '';
        keyInput.value = '';
        currentCommandEdit = { sectionId, commandId: null };
      }

      overlay.style.display = 'flex';
      nameInput.focus();
    }

    /**
     * Hide the command form
     */
    function hideCommandForm() {
      const overlay = document.getElementById('command-form-overlay');
      overlay.style.display = 'none';
      currentCommandEdit = null;
    }

    /**
     * Save the command from the form
     */
    async function saveCommandFromForm() {
      const nameInput = document.getElementById('command-name');
      const inputTypeSelect = document.getElementById('command-input-type');
      const outputTypeSelect = document.getElementById('command-output-type');
      const instructionsInput = document.getElementById('command-instructions');
      const keyInput = document.getElementById('command-key');

      const name = nameInput.value.trim();
      const inputType = inputTypeSelect.value;
      const outputType = outputTypeSelect.value;
      const instructions = instructionsInput.value.trim();
      const key = keyInput.value.trim().toLowerCase();

      // Validate
      if (!name) {
        alert('Please enter a command name');
        nameInput.focus();
        return;
      }
      if (!instructions) {
        alert('Please enter instructions for the AI');
        instructionsInput.focus();
        return;
      }

      const commandData = {
        name,
        inputType,
        outputType,
        instructions,
        key: key || undefined,
      };

      if (currentCommandEdit.commandId) {
        // Update existing
        await electronAPI.settings.updateCustomCommand(
          currentCommandEdit.sectionId,
          currentCommandEdit.commandId,
          commandData
        );
      } else {
        // Create new
        await electronAPI.settings.addCustomCommand(
          currentCommandEdit.sectionId,
          commandData
        );
      }

      hideCommandForm();
      await loadCustomSections();
    }

    /**
     * Initialize command form event handlers
     */
    function initCommandForm() {
      const overlay = document.getElementById('command-form-overlay');
      const closeBtn = document.getElementById('command-form-close');
      const cancelBtn = document.getElementById('command-form-cancel');
      const saveBtn = document.getElementById('command-form-save');

      closeBtn.addEventListener('click', hideCommandForm);
      cancelBtn.addEventListener('click', hideCommandForm);
      saveBtn.addEventListener('click', saveCommandFromForm);

      // Close on overlay click
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          hideCommandForm();
        }
      });

      // Close on Escape, save on Ctrl+Enter
      overlay.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          hideCommandForm();
        } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          saveCommandFromForm();
        }
      });
    }

    async function showAddCommandDialog(sectionId) {
      showCommandForm(sectionId, null);
    }

    // =========================================================================
    // TABLE OF CONTENTS
    // =========================================================================

    /**
     * Extract headings from markdown content
     * @param {string} content - The markdown content
     * @returns {Array<{level: number, text: string, line: number, pos: number}>}
     */
    function extractHeadings(content) {
      const headings = [];
      const lines = content.split('\n');
      let pos = 0;
      let inCodeBlock = false;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];

        // Check for code block delimiters (``` or ~~~)
        if (line.match(/^(`{3,}|~{3,})/)) {
          inCodeBlock = !inCodeBlock;
          pos += line.length + 1;
          continue;
        }

        // Skip heading detection inside code blocks
        if (inCodeBlock) {
          pos += line.length + 1;
          continue;
        }

        // Match markdown headings (# to ######)
        const match = line.match(/^(#{1,6})\s+(.+)$/);
        if (match) {
          const level = match[1].length;
          // Clean up the heading text (remove trailing #, inline code, etc.)
          let text = match[2].trim().replace(/\s*#+\s*$/, '');
          headings.push({
            level,
            text,
            line: i,
            pos: pos,
          });
        }
        pos += line.length + 1; // +1 for newline
      }

      return headings;
    }

    /**
     * Update the TOC sidebar with headings
     * @param {Array} headings - Array of heading objects
     */
    function updateTOC(headings) {
      const tocList = document.getElementById('toc-list');
      const tocSidebar = document.getElementById('toc-sidebar');

      if (!tocList) return;

      // Filter to show only h1-h3 by default for cleaner display
      const displayHeadings = headings.filter(h => h.level <= 3);

      if (displayHeadings.length === 0) {
        tocList.innerHTML = '<div class="toc-empty">No headings found</div>';
        tocSidebar.classList.remove('visible');
        return;
      }

      // Show the sidebar
      tocSidebar.classList.add('visible');

      // Build the TOC HTML
      tocList.innerHTML = displayHeadings.map((h, idx) => `
        <div class="toc-item" data-level="${h.level}" data-pos="${h.pos}" data-index="${idx}">
          ${escapeHtml(h.text)}
        </div>
      `).join('');

      // Add click handlers
      tocList.querySelectorAll('.toc-item').forEach(item => {
        item.addEventListener('click', () => {
          const pos = parseInt(item.dataset.pos, 10);
          jumpToPosition(pos);

          // Update active state
          tocList.querySelectorAll('.toc-item').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
        });
      });

      // Set first item as active by default
      const firstItem = tocList.querySelector('.toc-item');
      if (firstItem) firstItem.classList.add('active');
    }

    /**
     * Jump to a position in the editor
     * @param {number} pos - Character position
     */
    function jumpToPosition(pos) {
      if (!state.editor?.view) return;

      const view = state.editor.view;

      // Set cursor position
      view.dispatch({
        selection: { anchor: pos, head: pos },
        scrollIntoView: true,
      });

      // Focus the editor
      view.focus();
    }

    /**
     * Escape HTML special characters
     */
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Initialize TOC for the current editor
     */
    function initializeTOC() {
      if (!state.editor) return;

      // Get initial content and update TOC
      const content = state.editor.view?.state.doc.toString() || '';
      const headings = extractHeadings(content);
      updateTOC(headings);

      // Subscribe to content changes (debounced)
      let tocUpdateTimeout = null;
      state.editor.onChange((newContent) => {
        clearTimeout(tocUpdateTimeout);
        tocUpdateTimeout = setTimeout(() => {
          const headings = extractHeadings(newContent);
          updateTOC(headings);
        }, 300); // Debounce 300ms
      });

      // Update active heading based on scroll position
      const contentEl = document.querySelector('.content');
      if (contentEl) {
        contentEl.addEventListener('scroll', () => {
          updateActiveTOCItem();
        }, { passive: true });
      }
    }

    /**
     * Update the active TOC item based on scroll position
     */
    function updateActiveTOCItem() {
      if (!state.editor?.view) return;

      const view = state.editor.view;
      const tocItems = document.querySelectorAll('.toc-item');
      if (tocItems.length === 0) return;

      // Get the visible area's top position in document coordinates
      const visibleTop = view.documentTop;
      const scrollTop = view.scrollDOM.scrollTop;

      // Find which heading is currently visible
      let activeItem = tocItems[0];

      tocItems.forEach(item => {
        const pos = parseInt(item.dataset.pos, 10);
        try {
          const coords = view.coordsAtPos(pos);
          if (coords && coords.top <= 100) { // 100px from top of viewport
            activeItem = item;
          }
        } catch (e) {
          // Position might be invalid, skip
        }
      });

      // Update active class
      tocItems.forEach(item => item.classList.remove('active'));
      activeItem.classList.add('active');

      // Scroll TOC to keep active item visible
      activeItem.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
    }

    /**
     * Hide the TOC sidebar
     */
    function hideTOC() {
      const tocSidebar = document.getElementById('toc-sidebar');
      if (tocSidebar) {
        tocSidebar.classList.remove('visible');
      }
    }

    async function discoverProjectVenv(projectDir) {
      // If no python yet, check for obvious venv
      if (!state.pythonPort) {
        const venvPaths = [
          projectDir + '/.venv',
          projectDir + '/venv',
          projectDir + '/env',
        ];

        for (const vp of venvPaths) {
          // We can't check fs directly, but we can try to start and see
          // For now, just trigger discovery
        }

        // Start venv discovery in background
        electronAPI.discoverVenvs(projectDir);
      }
    }

    // =========================================================================
    // STATUS BAR & SESSION MANAGEMENT
    // =========================================================================

    /**
     * Update session status (state only, UI handled by CodeLens)
     * @param {'none'|'starting'|'connected'|'error'} status
     * @param {string} name - Session name (e.g., "thesis:default")
     */
    function updateSessionStatus(status, name) {
      state.session.status = status;
      state.session.name = name;

      // Log status change
      console.log(`[Session] Status: ${status}, Name: ${name || 'none'}`);

      // Rebuild CodeLens to reflect status change
      rebuildEditorCodeLens();
    }

    // Legacy wrapper for old code
    function updatePythonStatus(status, label) {
      const statusMap = { ready: 'connected', loading: 'starting', error: 'error' };
      updateSessionStatus(statusMap[status] || 'none', label);
    }

    /**
     * Get the correct electronAPI for a runtime language
     * @param {string} language - Runtime language (python, bash, r, julia, node)
     * @returns {{ start, stop, restart, list, forDocument } | null}
     */
    function getApiForLanguage(language) {
      // All languages use the unified runtime API
      return electronAPI.runtime;
    }

    /**
     * Update a session in the multi-session map and rebuild CodeLens
     * @param {string} sessionName
     * @param {object} entry - { language, status, config?, info? }
     */
    function setSessionEntry(sessionName, entry) {
      const existing = state.sessions.get(sessionName) || {};
      state.sessions.set(sessionName, { ...existing, ...entry });
      rebuildEditorCodeLens();
    }

    /**
     * Remove a session from the multi-session map
     * @param {string} sessionName
     */
    function removeSessionEntry(sessionName) {
      state.sessions.delete(sessionName);
      rebuildEditorCodeLens();
    }

    /**
     * Update legacy per-language port/session state for backwards compat
     * @param {string} language
     * @param {object|null} info - Session info (null to clear)
     */
    function updateLegacyState(language, info) {
      switch (language) {
        case 'python':
          state.pythonPort = info?.port || null;
          state.session.info = info;
          state.session.status = info ? 'connected' : 'none';
          state.session.name = info ? state.session.name : null;
          break;
        case 'bash': case 'sh': case 'shell':
          state.bashPort = info?.port || null;
          state.bashSession = info || null;
          break;
        case 'r': case 'rlang':
          state.rPort = info?.port || null;
          state.rSession = info || null;
          break;
        case 'julia': case 'jl':
          state.juliaPort = info?.port || null;
          state.juliaSession = info || null;
          break;
      }
    }

    /**
     * Language-aware session start
     * @param {object} config - { name, language, venv?, cwd?, projectRoot? }
     * @param {string} sessionName - Full session name for the map
     */
    async function startLanguageSession(config, sessionName) {
      const api = getApiForLanguage(config.language);
      if (!api) {
        console.error(`[Session] No API for language: ${config.language}`);
        return;
      }

      setSessionEntry(sessionName, { language: config.language, status: 'starting', config });

      try {
        const result = await api.start(config);

        if (result.success || result.pid) {
          setSessionEntry(sessionName, { status: 'connected', info: result });
          updateLegacyState(config.language, result);
          console.log(`[Session] Started ${config.language} session: ${sessionName} on port ${result.port} (PID ${result.pid})`);

          // Register runtime with editor
          if (state.editor && state.currentFile) {
            registerLanguageRuntimeWithEditor(config.language, result.port);
          }
          return result;
        } else {
          setSessionEntry(sessionName, { status: 'error' });
          console.error(`[Session] Failed to start ${config.language}:`, result.error);
        }
      } catch (e) {
        setSessionEntry(sessionName, { status: 'error' });
        console.error(`[Session] Start error for ${config.language}:`, e);
      }
    }

    /**
     * Language-aware session stop
     * @param {string} sessionName
     */
    async function stopLanguageSession(sessionName) {
      const entry = state.sessions.get(sessionName);
      if (!entry) {
        console.error(`[Session] Unknown session: ${sessionName}`);
        return;
      }

      const api = getApiForLanguage(entry.language);
      if (!api) return;

      try {
        const result = await api.stop(sessionName);
        if (result.success) {
          updateLegacyState(entry.language, null);
          removeSessionEntry(sessionName);
          console.log(`[Session] Stopped ${entry.language} session: ${sessionName}`);
        } else {
          console.error(`[Session] Failed to stop ${sessionName}:`, result.error);
        }
      } catch (e) {
        console.error(`[Session] Stop error for ${sessionName}:`, e);
      }
    }

    /**
     * Language-aware session restart
     * @param {string} sessionName
     */
    async function restartLanguageSession(sessionName) {
      const entry = state.sessions.get(sessionName);
      if (!entry) {
        console.error(`[Session] Unknown session: ${sessionName}`);
        return;
      }

      const api = getApiForLanguage(entry.language);
      if (!api) return;

      setSessionEntry(sessionName, { status: 'starting' });

      try {
        const result = await api.restart(sessionName);
        if (result.success || result.pid) {
          setSessionEntry(sessionName, { status: 'connected', info: result });
          updateLegacyState(entry.language, result);
          console.log(`[Session] Restarted ${entry.language} session: ${sessionName} on port ${result.port}`);

          // Re-register runtime with editor
          if (state.editor && state.currentFile) {
            registerLanguageRuntimeWithEditor(entry.language, result.port);
          }
        } else {
          setSessionEntry(sessionName, { status: 'error' });
          console.error(`[Session] Failed to restart ${sessionName}:`, result.error);
        }
      } catch (e) {
        setSessionEntry(sessionName, { status: 'error' });
        console.error(`[Session] Restart error for ${sessionName}:`, e);
      }
    }

    /**
     * Register a runtime with the editor by language and port
     * @param {string} language
     * @param {number} port
     */
    function registerLanguageRuntimeWithEditor(language, port) {
      if (!state.editor || !port) return;

      const docName = stripDocExtension(state.currentFile.split('/').pop());
      const langMap = {
        python: { key: 'python', langs: ['python', 'py', 'python3'] },
        bash: { key: 'bash', langs: ['bash', 'sh', 'shell'] },
        r: { key: 'r', langs: ['r', 'R', 'rlang'] },
        julia: { key: 'julia', langs: ['julia', 'jl'] },
        node: { key: 'javascript', langs: ['javascript', 'js', 'node', 'typescript', 'ts'] },
      };

      const mapping = langMap[language];
      if (!mapping) return;

      if (language === 'bash') {
        // Bash uses auto-restarting wrapper
        const bashClient = createAutoRestartingBashClient(port, docName);
        state.editor.registerRuntime(mapping.key, bashClient);
      } else if (language === 'python') {
        const pythonClient = createAutoRestartingPythonClient(port, docName);
        state.editor.registerRuntime(mapping.key, pythonClient);
      } else {
        const client = new mrmd.MRPClient(
          `http://127.0.0.1:${port}/mrp/v1`,
          { languages: mapping.langs }
        );
        state.editor.registerRuntime(mapping.key, client);
      }
      console.log(`[Session] Registered ${language} runtime with editor on port ${port}`);
    }

    function updateAiStatus(status) {
      const dot = document.getElementById('ai-dot');
      if (dot) {
        dot.className = 'status-dot ' + status;
      }
    }

    /**
     * Add AI integration extensions to the editor
     * Shows loading shimmer and accept/reject UI for AI operations
     * Also adds long-press 'j' detection to open AI panel
     * Note: Ctrl-K and comment syntax are added later via addCtrlKAndCommentExtensions()
     * @param {Object} editor - The mrmd editor instance
     */
    function addAiIntegrationToEditor(editor) {
      if (!editor?.view) return;

      // Get the AI integration module
      const ai = mrmd.default?.ai || mrmd.ai;
      if (!ai?.aiIntegration) {
        console.warn('[AI] aiIntegration not available');
        return;
      }

      // Create AI extensions
      const aiExtensions = ai.aiIntegration({
        // Could add onSparkClick here for inline AI menu
      });

      // Create long-press 'j' extension to open AI panel
      const longPressExtensions = ai.createLongPressExtension?.({
        onTrigger: (view) => {
          // Open the side rail first, then the AI panel
          openRail();
          openPanel('ai');
          // Enable keyboard mode for the AI panel
          enableAiPanelKeyboardMode();
        },
      }) || [];

      // Also add palette styles extension (for loading indicator)
      const paletteStyles = ai.aiPaletteStyles || [];

      // Combine all extensions
      const allExtensions = [
        ...aiExtensions,
        ...longPressExtensions,
        paletteStyles,
      ].filter(Boolean);

      // Add extensions to editor
      editor.view.dispatch({
        effects: mrmd.codemirror.StateEffect.appendConfig.of(allExtensions),
      });

      console.log('[AI] AI integration extensions added to editor (including long-press j)');
    }

    /**
     * Setup image paste handler for the editor.
     * Intercepts paste events, saves images to _assets/, and inserts markdown.
     *
     * @param {Object} editor - The mrmd editor instance
     * @param {string} documentPath - Absolute path to the current document
     */
    function setupImagePasteHandler(editor, documentPath) {
      if (!editor?.view) return;

      const editorDom = editor.view.dom;

      editorDom.addEventListener('paste', async (event) => {
        // Check if we have image data in clipboard
        const items = event.clipboardData?.items;
        if (!items) return;

        // Find image item
        let imageItem = null;
        for (const item of items) {
          if (item.type.startsWith('image/')) {
            imageItem = item;
            break;
          }
        }

        if (!imageItem) return;

        // Prevent default paste (we'll handle it)
        event.preventDefault();

        // Get project info
        const projectRoot = state.project?.root;
        if (!projectRoot) {
          console.warn('[ImagePaste] No project root available, cannot save asset');
          return;
        }

        try {
          // Get the image file from clipboard
          const file = imageItem.getAsFile();
          if (!file) {
            console.warn('[ImagePaste] Could not get file from clipboard');
            return;
          }

          // Read file as array buffer
          const arrayBuffer = await file.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);

          // Generate filename based on timestamp
          const ext = file.type.split('/')[1] || 'png';
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
          const filename = `paste-${timestamp}.${ext}`;

          console.log(`[ImagePaste] Saving ${filename} (${uint8Array.length} bytes)`);

          // Save asset via electron API
          const result = await electronAPI.asset.save(projectRoot, uint8Array, filename);
          console.log('[ImagePaste] Asset saved:', result);

          // Get relative path from document to asset
          const relativeDocPath = documentPath.replace(projectRoot + '/', '');
          const relativePath = await electronAPI.asset.relativePath(result.path, relativeDocPath);
          console.log('[ImagePaste] Relative path:', relativePath);

          // Insert markdown at cursor position
          const view = editor.view;
          const pos = view.state.selection.main.head;

          // Create markdown image syntax
          const altText = result.deduplicated ? 'image' : filename.replace(/\.[^.]+$/, '');
          const markdown = `![${altText}](${relativePath})`;

          // Insert the markdown
          view.dispatch({
            changes: { from: pos, insert: markdown },
            selection: { anchor: pos + markdown.length },
          });

          console.log(`[ImagePaste] Inserted: ${markdown}`);

        } catch (err) {
          console.error('[ImagePaste] Error:', err);
        }
      });

      console.log('[ImagePaste] Image paste handler installed');

      // Also handle drag and drop of images
      editorDom.addEventListener('dragover', (event) => {
        // Check if dragging files
        if (event.dataTransfer?.types?.includes('Files')) {
          event.preventDefault();
          event.dataTransfer.dropEffect = 'copy';
        }
      });

      editorDom.addEventListener('drop', async (event) => {
        const files = event.dataTransfer?.files;
        if (!files || files.length === 0) return;

        // Check if any file is an image
        const imageFile = Array.from(files).find(f => f.type.startsWith('image/'));
        if (!imageFile) return;

        event.preventDefault();

        const projectRoot = state.project?.root;
        if (!projectRoot) {
          console.warn('[ImageDrop] No project root available, cannot save asset');
          return;
        }

        try {
          // Read file as array buffer
          const arrayBuffer = await imageFile.arrayBuffer();
          const uint8Array = new Uint8Array(arrayBuffer);

          // Use original filename or generate one
          const filename = imageFile.name || `drop-${Date.now()}.png`;

          console.log(`[ImageDrop] Saving ${filename} (${uint8Array.length} bytes)`);

          // Save asset via electron API
          const result = await electronAPI.asset.save(projectRoot, uint8Array, filename);
          console.log('[ImageDrop] Asset saved:', result);

          // Get relative path from document to asset
          const relativeDocPath = documentPath.replace(projectRoot + '/', '');
          const relativePath = await electronAPI.asset.relativePath(result.path, relativeDocPath);
          console.log('[ImageDrop] Relative path:', relativePath);

          // Get drop position - try to get cursor position near drop location
          const view = editor.view;
          const dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY });
          const pos = dropPos ?? view.state.selection.main.head;

          // Create markdown image syntax
          const altText = result.deduplicated ? 'image' : filename.replace(/\.[^.]+$/, '');
          const markdown = `![${altText}](${relativePath})`;

          // Insert the markdown
          view.dispatch({
            changes: { from: pos, insert: markdown },
            selection: { anchor: pos + markdown.length },
          });

          console.log(`[ImageDrop] Inserted: ${markdown}`);

        } catch (err) {
          console.error('[ImageDrop] Error:', err);
        }
      });

      console.log('[ImageDrop] Image drop handler installed');
    }

    /**
     * Resolve special links (next, prev, home, up, toc)
     *
     * @param {string} target - Special link target
     * @param {string} documentPath - Absolute path to current document
     * @param {Object} project - Project info with root and files array
     * @returns {string | null} Resolved relative file path or null
     */
    function resolveSpecialLink(target, documentPath, project) {
      const { root, files } = project;
      if (!files || files.length === 0) return null;

      // Get current document path relative to project root
      const fromDocument = documentPath.startsWith(root + '/')
        ? documentPath.slice(root.length + 1)
        : documentPath;

      // Filter to only doc files (content files), excluding mrmd.md
      const docFiles = files.filter(f => isDocFile(f) && f !== 'mrmd.md');

      // Sort by FSML order (numeric prefix, then alphabetical)
      const sorted = [...docFiles].sort((a, b) => {
        // Extract first path segment's numeric prefix for top-level ordering
        const aSegments = a.split('/');
        const bSegments = b.split('/');

        // Compare path segments level by level
        const maxLen = Math.max(aSegments.length, bSegments.length);
        for (let i = 0; i < maxLen; i++) {
          const aSeg = aSegments[i] || '';
          const bSeg = bSegments[i] || '';

          // Extract numeric prefix
          const aMatch = aSeg.match(/^(\d+)-/);
          const bMatch = bSeg.match(/^(\d+)-/);
          const aOrder = aMatch ? parseInt(aMatch[1]) : Infinity;
          const bOrder = bMatch ? parseInt(bMatch[1]) : Infinity;

          if (aOrder !== bOrder) return aOrder - bOrder;
          if (aSeg !== bSeg) return aSeg.localeCompare(bSeg);
        }
        return 0;
      });

      const currentIndex = sorted.indexOf(fromDocument);

      switch (target.toLowerCase()) {
        case 'next':
          return currentIndex >= 0 && currentIndex < sorted.length - 1
            ? sorted[currentIndex + 1]
            : null;

        case 'prev':
          return currentIndex > 0
            ? sorted[currentIndex - 1]
            : null;

        case 'home':
          return sorted[0] || null;

        case 'up': {
          // Go to parent directory's index or first file
          const parts = fromDocument.split('/');
          if (parts.length > 1) {
            const parentDir = parts.slice(0, -1).join('/');
            const preferredExt = getDocExtension(fromDocument) || '.md';
            // Look for index in parent, preferring same extension
            let parentIndex = sorted.find(f => f === parentDir + '/index' + preferredExt);
            if (!parentIndex) {
              for (const ext of DOC_EXTENSIONS) {
                parentIndex = sorted.find(f => f === parentDir + '/index' + ext);
                if (parentIndex) break;
              }
            }
            if (parentIndex) return parentIndex;
            // Or first file in parent
            const parentFile = sorted.find(f => f.startsWith(parentDir + '/'));
            if (parentFile) return parentFile;
          }
          return sorted[0] || null;
        }

        case 'toc':
          // TODO: TOC should render inline, not navigate
          console.log('[LinkNav] TOC link - inline rendering not yet implemented');
          return null;

        default:
          return null;
      }
    }

    /**
     * Setup link navigation handlers for the editor.
     * Handles wiki-link and file-link navigation events.
     *
     * @param {Object} editor - The mrmd editor instance
     * @param {string} documentPath - Absolute path to the current document
     * @param {Object} project - Project info with files array
     */
    function setupLinkNavigation(editor, documentPath, project) {
      if (!editor?.view) return;

      const editorDom = editor.view.dom;

      // Handle wiki-link navigation: [[target]]
      editorDom.addEventListener('wiki-link-navigate', async (e) => {
        const target = e.detail?.target;
        if (!target) return;

        console.log(`[LinkNav] Wiki-link: ${target}`);

        // Handle special links
        if (target === 'next' || target === 'prev' || target === 'home' || target === 'up' || target === 'toc') {
          if (!project?.files || !documentPath) {
            console.warn('[LinkNav] Cannot resolve special link - missing project or document');
            return;
          }

          const resolved = resolveSpecialLink(target, documentPath, project);
          if (resolved) {
            const fullPath = project.root + '/' + resolved;
            console.log(`[LinkNav] Special link resolved: ${target} -> ${fullPath}`);
            openFile(fullPath);
          } else {
            console.warn(`[LinkNav] Could not resolve special link: ${target}`);
          }
          return;
        }

        // Resolve wiki-link to file path
        if (!project?.files) {
          console.warn('[LinkNav] No project files available');
          return;
        }

        // Find matching file (fuzzy match)
        const targetLower = target.toLowerCase();
        let matchedFile = null;

        for (const filePath of project.files) {
          if (!isDocFile(filePath)) continue;

          // Get filename without extension and order prefix
          const segments = filePath.split('/');
          const filename = segments[segments.length - 1];
          const name = stripDocExtension(filename).replace(/^\d+-/, '');

          // Check for match
          if (name.toLowerCase() === targetLower) {
            matchedFile = filePath;
            break;
          }

          // Also check full path match
          const pathWithoutExt = stripDocExtension(filePath);
          if (pathWithoutExt.toLowerCase().endsWith(targetLower)) {
            matchedFile = filePath;
            // Don't break - prefer exact name match
          }
        }

        if (matchedFile) {
          const fullPath = project.root + '/' + matchedFile;
          console.log(`[LinkNav] Resolved: ${target} -> ${fullPath}`);
          openFile(fullPath);
        } else {
          console.warn(`[LinkNav] Could not resolve wiki-link: ${target}`);
        }
      });

      // Handle file-link navigation: [text](./path)
      editorDom.addEventListener('file-link-navigate', async (e) => {
        const relativePath = e.detail?.path;
        if (!relativePath) return;

        console.log(`[LinkNav] File link: ${relativePath}`);

        // Resolve relative path from document directory
        const documentDir = documentPath.substring(0, documentPath.lastIndexOf('/'));
        let resolvedPath;

        if (relativePath.startsWith('/')) {
          // Absolute path
          resolvedPath = relativePath;
        } else if (relativePath.startsWith('../') || relativePath.startsWith('./')) {
          // Relative path
          const parts = documentDir.split('/');
          const urlParts = relativePath.split('/');

          for (const part of urlParts) {
            if (part === '..') {
              parts.pop();
            } else if (part !== '.') {
              parts.push(part);
            }
          }
          resolvedPath = parts.join('/');
        } else {
          // Relative without prefix
          resolvedPath = documentDir + '/' + relativePath;
        }

        console.log(`[LinkNav] Resolved: ${relativePath} -> ${resolvedPath}`);

        // Check if it's a markdown-like doc file
        if (isDocFile(resolvedPath)) {
          // Open in editor
          openFile(resolvedPath);
        } else {
          // Open with system default application
          try {
            await electronAPI.shell.openPath(resolvedPath);
          } catch (err) {
            console.error(`[LinkNav] Failed to open: ${resolvedPath}`, err);
          }
        }
      });

      console.log('[LinkNav] Link navigation handlers installed');
    }

    /**
     * Setup asset URL resolver for the editor.
     * Converts relative asset paths (like ../_assets/image.png) to absolute file:// URLs
     * so images can load correctly in the Electron renderer.
     *
     * @param {Object} editor - The mrmd editor instance
     * @param {string} documentPath - Absolute path to the current document
     */
    function setupAssetResolver(editor, documentPath) {
      if (!editor?.view) return;

      const projectRoot = state.project?.root;
      if (!projectRoot) {
        console.warn('[AssetResolver] No project root, asset resolution disabled');
        return;
      }

      // Get the document's directory (relative paths are resolved from here)
      const documentDir = documentPath.substring(0, documentPath.lastIndexOf('/'));

      // Get the assetResolverFacet from mrmd
      const assetResolverFacet = mrmd.assetResolverFacet;
      if (!assetResolverFacet) {
        console.warn('[AssetResolver] assetResolverFacet not available in mrmd');
        return;
      }

      // Create resolver function.
      // Desktop/Electron: relative asset path -> file:// URL
      // Sandbox/browser: relative asset path -> blob: URL from IndexedDB cache
      const resolver = (url) => {
        if (!url) return url;

        // Resolve relative path from document directory
        // Handle ../_assets/..., ./_assets/..., _assets/... patterns
        let resolvedPath;
        if (url.startsWith('/')) {
          // Absolute path:
          // - If already rooted at projectRoot, keep as-is
          // - If rooted at /_assets, make project-root absolute
          // - Else, treat as project-root absolute fallback
          if (url.startsWith(projectRoot + '/')) {
            resolvedPath = url;
          } else if (url.startsWith('/_assets/')) {
            resolvedPath = projectRoot + url;
          } else {
            resolvedPath = projectRoot + (url.startsWith('/') ? url : ('/' + url));
          }
        } else if (url.startsWith('../') || url.startsWith('./')) {
          // Relative path - resolve from document directory
          const parts = documentDir.split('/');
          const urlParts = url.split('/');

          for (const part of urlParts) {
            if (part === '..') {
              parts.pop();
            } else if (part !== '.') {
              parts.push(part);
            }
          }
          resolvedPath = parts.join('/');
        } else {
          // Relative path without ./ - resolve from document directory
          resolvedPath = documentDir + '/' + url;
        }

        // Sandbox/browser mode: resolve from IndexedDB asset cache.
        if (window.MRMD_SANDBOX && window._sandboxAssetCache) {
          const blobUrl = window._sandboxAssetCache.resolve(resolvedPath);
          if (blobUrl) {
            console.log(`[AssetResolver:sandbox] ${url} -> ${blobUrl}`);
            return blobUrl;
          }
          // Prevent browser security errors from file:// and keep UI clean while cache warms.
          console.warn(`[AssetResolver:sandbox] Cache miss for ${resolvedPath}`);
          return 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
        }

        // Desktop/Electron mode: use file://
        const fileUrl = 'file://' + resolvedPath;
        console.log(`[AssetResolver] ${url} -> ${fileUrl}`);
        return fileUrl;
      };

      // In sandbox mode, preload IndexedDB assets before/after install.
      if (window.MRMD_SANDBOX && window._sandboxAssetCache?.preload) {
        window._sandboxAssetCache.preload(projectRoot)
          .then(() => {
            // Re-append resolver to trigger a re-render after cache warmup.
            try {
              editor.view.dispatch({
                effects: mrmd.codemirror.StateEffect.appendConfig.of(
                  assetResolverFacet.of(resolver)
                ),
              });
            } catch { /* ignore */ }
          })
          .catch(() => {});
      }

      // Add the resolver extension to the editor
      editor.view.dispatch({
        effects: mrmd.codemirror.StateEffect.appendConfig.of(
          assetResolverFacet.of(resolver)
        ),
      });

      console.log('[AssetResolver] Asset resolver installed for', documentDir);
    }

    /**
     * Setup asset handler for saving generated plots/images from code execution.
     * When a code cell produces images (matplotlib plots, etc.), this handler:
     * 1. Fetches the image from the runtime server
     * 2. Saves it to _assets/generated/ in the project
     * 3. Returns the relative path for markdown insertion
     *
     * @param {Object} editor - The mrmd editor instance
     * @param {string} documentPath - Absolute path to the current document
     */
    function setupExecutionAssetHandler(editor, documentPath) {
      if (!editor?.execution) {
        console.warn('[AssetHandler] No execution manager, asset handler disabled');
        return;
      }

      const projectRoot = state.project?.root;
      if (!projectRoot) {
        console.warn('[AssetHandler] No project root, asset handler disabled');
        return;
      }

      // Get document name for relative path computation
      const docRelativePath = documentPath.replace(projectRoot + '/', '');

      // Set the asset handler on the execution manager
      editor.execution.assetHandler = async ({ execId, cellIndex, data, eventType, runtimeUrl, mimeType, url }) => {
        console.log('[AssetHandler] Processing asset:', { execId, eventType, mimeType, url });

        try {
          // Determine filename and fetch URL
          let fetchUrl;
          let filename;

          if (eventType === 'asset' && url) {
            // Asset event: url is like /mrp/v1/assets/exec-123_0001.png
            // Extract filename from URL
            filename = url.split('/').pop();
            fetchUrl = runtimeUrl ? `${runtimeUrl.replace('/mrp/v1', '')}${url}` : url;
          } else if (eventType === 'display' && data.data) {
            // Display event: base64-encoded data
            const imgData = data.data['image/png'] || data.data['image/jpeg'] || data.data['image/svg+xml'];
            if (imgData) {
              // Generate filename based on execId
              const ext = data.data['image/png'] ? '.png' : data.data['image/jpeg'] ? '.jpg' : '.svg';
              filename = `${execId}-${Date.now()}${ext}`;

              // Decode base64 and save directly
              const buffer = Uint8Array.from(atob(imgData), c => c.charCodeAt(0));
              const result = await window.electronAPI.asset.save(projectRoot, buffer, `generated/${filename}`);

              if (result.error) {
                console.error('[AssetHandler] Failed to save display asset:', result.error);
                return null;
              }

              // Compute relative path from document to asset
              // Note: result.path is already relative to _assets/ (e.g., "generated/xxx.png")
              // getRelativePath adds _assets/ prefix internally
              const relativePath = await window.electronAPI.asset.relativePath(
                result.path,
                docRelativePath
              );

              console.log('[AssetHandler] Saved display asset:', result.path, 'relative:', relativePath);
              return { assetPath: result.path, relativePath };
            }
            return null;
          } else {
            console.warn('[AssetHandler] Unknown asset type:', eventType, data);
            return null;
          }

          // Fetch from runtime
          console.log('[AssetHandler] Fetching from:', fetchUrl);
          const response = await fetch(fetchUrl);

          if (!response.ok) {
            console.error('[AssetHandler] Failed to fetch asset:', response.status, response.statusText);
            return null;
          }

          const arrayBuffer = await response.arrayBuffer();
          const buffer = new Uint8Array(arrayBuffer);

          // Save to _assets/generated/
          const result = await window.electronAPI.asset.save(projectRoot, buffer, `generated/${filename}`);

          if (result.error) {
            console.error('[AssetHandler] Failed to save asset:', result.error);
            return null;
          }

          // Compute relative path from document to asset
          // Note: result.path is already relative to _assets/ (e.g., "generated/xxx.png")
          // getRelativePath adds _assets/ prefix internally
          const relativePath = await window.electronAPI.asset.relativePath(
            result.path,
            docRelativePath
          );

          console.log('[AssetHandler] Saved asset:', result.path, 'relative:', relativePath, result.deduplicated ? '(deduplicated)' : '');
          return { assetPath: result.path, relativePath };
        } catch (err) {
          console.error('[AssetHandler] Error processing asset:', err);
          return null;
        }
      };

      console.log('[AssetHandler] Execution asset handler installed');
    }

    /**
     * Add runtime CodeLens extensions to the editor
     * Shows inline controls above yaml config blocks and frontmatter
     * @param {Object} editor - The mrmd editor instance
     */
    function addRuntimeCodeLensToEditor(editor) {
      if (!editor?.view) return;

      const projectName = state.project?.config?.name || 'default';

      // Create CodeLens extensions with callbacks
      const codeLensExtensions = mrmd.runtimeCodeLens.createExtensions({
        projectName,

        // Get session status by name (e.g., "thesis:default")
        getSessionStatus: (sessionName) => {
          // Check multi-session map first
          const entry = state.sessions.get(sessionName);
          if (entry && entry.status !== 'none') {
            return {
              alive: entry.status === 'connected',
              pid: entry.info?.pid,
              port: entry.info?.port,
              error: entry.status === 'error' ? 'Session failed' : undefined,
            };
          }
          // Fallback to legacy single session
          if (state.session.name === sessionName && state.session.status !== 'none') {
            return {
              alive: state.session.status === 'connected',
              pid: state.session.info?.pid,
              port: state.session.info?.port,
              error: state.session.status === 'error' ? 'Session failed' : undefined,
            };
          }
          return null;
        },

        // Start a runtime (receives full runtime config from yaml)
        onStart: async (runtime) => {
          console.log('[CodeLens] Start runtime:', runtime);
          const projectRoot = state.project?.root || '';

          // Resolve relative paths to absolute
          const resolvePath = (p) => {
            if (!p) return projectRoot;
            if (p.startsWith('/')) return p;
            return projectRoot ? `${projectRoot}/${p}`.replace(/\/+/g, '/') : p;
          };

          const config = {
            name: runtime.name,
            language: runtime.language,
            venv: resolvePath(runtime.venv),
            cwd: resolvePath(runtime.cwd),
            projectRoot,
          };
          console.log('[CodeLens] Resolved config:', config);

          const sessionName = `${projectName}:${runtime.name || 'default'}`;
          await startLanguageSession(config, sessionName);
        },

        // Stop a runtime by name
        onStop: async (sessionName) => {
          console.log('[CodeLens] Stop session:', sessionName);
          await stopLanguageSession(sessionName);
        },

        // Restart a runtime by name
        onRestart: async (sessionName) => {
          console.log('[CodeLens] Restart session:', sessionName);
          await restartLanguageSession(sessionName);
        },

        // Restart all runtimes (for multi-runtime configs)
        onRestartAll: async () => {
          console.log('[CodeLens] Restart all runtimes');
          const sessionNames = [...state.sessions.keys()];
          for (const name of sessionNames) {
            await restartLanguageSession(name);
          }
        },
      });

      // Add extensions to the editor dynamically
      editor.view.dispatch({
        effects: mrmd.codemirror.StateEffect.appendConfig.of(codeLensExtensions),
      });

      console.log('[CodeLens] Runtime CodeLens extensions added to editor');
    }

    /**
     * Rebuild CodeLens decorations in the editor
     * Call this when session status changes
     * Uses requestAnimationFrame to avoid "update during update" errors
     */
    function rebuildEditorCodeLens() {
      if (state.editor?.view) {
        // Defer to avoid calling dispatch during an update cycle
        requestAnimationFrame(() => {
          if (state.editor?.view) {
            mrmd.runtimeCodeLens.rebuild(state.editor.view);
          }
        });
      }
    }

    /**
     * Start session from project config
     */
    async function startSession() {
      if (!state.session.config) {
        console.error('No session config available');
        return;
      }

      const config = state.session.config;
      updateSessionStatus('starting', config.name);

      try {
        // Pass config directly - preload wraps it in { config }
        const result = await electronAPI.runtime.start(config);

        if (result.success || result.pid) {
          state.session.info = result;
          state.pythonPort = result.port;
          updateSessionStatus('connected', config.name);
          console.log(`Session started: ${config.name} on port ${result.port} (PID ${result.pid})`);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            registerSessionWithEditor(result.port);
          }
        } else {
          updateSessionStatus('error', config.name);
          console.error('Failed to start session:', result.error);
        }
      } catch (e) {
        updateSessionStatus('error', config.name);
        console.error('Session start error:', e);
      }
    }

    /**
     * Restart current session
     */
    async function restartSession() {
      if (!state.session.name) {
        console.error('No session to restart');
        return;
      }

      const sessionName = state.session.name;
      updateSessionStatus('starting', sessionName);

      try {
        const result = await electronAPI.runtime.restart(sessionName);

        if (result.success || result.pid) {
          state.session.info = result;
          state.pythonPort = result.port;
          updateSessionStatus('connected', sessionName);
          console.log(`Session restarted: ${sessionName} on port ${result.port}`);

          // Register runtime with existing editor if open
          if (state.editor && state.currentFile) {
            registerSessionWithEditor(result.port);
          }
        } else {
          updateSessionStatus('error', sessionName);
          console.error('Failed to restart session:', result.error);
        }
      } catch (e) {
        updateSessionStatus('error', sessionName);
        console.error('Session restart error:', e);
      }
    }

    /**
     * Stop current session
     */
    async function stopSession() {
      if (!state.session.name) {
        console.error('No session to stop');
        return;
      }

      const sessionName = state.session.name;

      try {
        const result = await electronAPI.runtime.stop(sessionName);

        if (result.success) {
          state.session.info = null;
          state.pythonPort = null;
          updateSessionStatus('none', null);
          console.log(`Session stopped: ${sessionName}`);
        } else {
          console.error('Failed to stop session:', result.error);
        }
      } catch (e) {
        console.error('Session stop error:', e);
      }
    }

    /**
     * Create an auto-recovering Python MRP client wrapper.
     * If execution fails due to lost runtime (502/connection), request runtime recovery,
     * refresh session mapping, and retry once.
     */
    function createAutoRestartingPythonClient(initialPort, sessionName) {
      let currentPort = initialPort;
      let isRecovering = false;
      const supportedLanguages = ['python', 'py', 'python3'];

      let realClient = new mrmd.MRPClient(
        `http://127.0.0.1:${currentPort}/mrp/v1`,
        { languages: supportedLanguages }
      );

      function updateClient(newPort) {
        currentPort = newPort;
        realClient = new mrmd.MRPClient(
          `http://127.0.0.1:${currentPort}/mrp/v1`,
          { languages: supportedLanguages }
        );
      }

      return new Proxy(realClient, {
        get(target, prop, receiver) {
          const value = realClient[prop];

          if (prop === 'supports') {
            return (language) => supportedLanguages.includes(String(language || '').toLowerCase());
          }

          if (prop === 'executeStreaming') {
            return async function(code, language, onChunk, onStdinRequest, options = {}) {
              try {
                return await realClient.executeStreaming(code, language, onChunk, onStdinRequest, options);
              } catch (error) {
                const msg = String(error?.message || '');
                const lower = msg.toLowerCase();
                const runtimeDown = lower.includes('execution failed: 502')
                  || lower.includes('failed to fetch')
                  || lower.includes('fetch failed')
                  || lower.includes('err_connection')
                  || lower.includes('econnrefused');

                if (!runtimeDown) throw error;

                if (isRecovering) {
                  onChunk?.('Python runtime is recovering...', 'Python runtime is recovering...', true);
                  throw new Error('Python runtime is recovering, please retry in a moment');
                }

                isRecovering = true;
                try {
                  const recoverRes = await fetch('/api/runtime/recover', {
                    method: 'POST',
                    credentials: 'include',
                    headers: { 'Content-Type': 'application/json' },
                  });

                  if (!recoverRes.ok) {
                    throw new Error(`Recovery failed (${recoverRes.status})`);
                  }

                  const recovered = await recoverRes.json();
                  if (!recovered?.ok) {
                    throw new Error(recovered?.error || 'Runtime recovery failed');
                  }

                  await new Promise(r => setTimeout(r, 150));
                  const runtimeResponse = await electronAPI.runtime.forDocument(state.currentFile);
                  const fresh = getPythonSessionFromRuntimeResponse(runtimeResponse);
                  if (!fresh?.alive || !fresh?.port) {
                    throw new Error('Runtime recovered but session is not ready yet');
                  }

                  updateClient(fresh.port);
                  state.pythonPort = fresh.port;
                  state.session.info = fresh;
                  console.log('[python] Runtime recovered on port', fresh.port);

                  isRecovering = false;
                  return await realClient.executeStreaming(code, language, onChunk, onStdinRequest, options);
                } catch (recoverError) {
                  isRecovering = false;
                  console.error('[python] Recovery failed:', recoverError);
                  throw recoverError;
                }
              }
            };
          }

          if (typeof value === 'function') {
            return value.bind(realClient);
          }
          return value;
        }
      });
    }

    /**
     * Register session with editor for code execution
     */
    function registerSessionWithEditor(port) {
      if (!state.editor || !port) return;

      const docName = stripDocExtension(state.currentFile.split('/').pop());
      const pythonClient = createAutoRestartingPythonClient(port, docName);
      state.editor.registerRuntime('python', pythonClient);
      console.log('Registered Python runtime with editor');
    }

    /**
     * Create an auto-restarting MRP client wrapper.
     * If execution fails due to connection error, restarts the session and retries.
     */
    function createAutoRestartingBashClient(initialPort, sessionName) {
      let currentPort = initialPort;
      let isRestarting = false;
      const supportedLanguages = ['bash', 'sh', 'shell'];

      // Create the underlying MRPClient
      let realClient = new mrmd.MRPClient(
        `http://127.0.0.1:${currentPort}/mrp/v1`,
        { languages: supportedLanguages }
      );

      // Helper to recreate client with new port
      function updateClient(newPort) {
        currentPort = newPort;
        realClient = new mrmd.MRPClient(
          `http://127.0.0.1:${currentPort}/mrp/v1`,
          { languages: supportedLanguages }
        );
      }

      // Use Proxy to delegate all method calls, intercepting executeStreaming for auto-restart
      return new Proxy(realClient, {
        get(target, prop, receiver) {
          // Always use current realClient (may have been updated)
          const value = realClient[prop];

          // For supports, use our list (faster, no async)
          if (prop === 'supports') {
            return (language) => supportedLanguages.includes(language.toLowerCase());
          }

          // Intercept executeStreaming to add auto-restart
          if (prop === 'executeStreaming') {
            return async function(code, language, onChunk, onStdinRequest, options = {}) {
              try {
                return await realClient.executeStreaming(code, language, onChunk, onStdinRequest, options);
              } catch (error) {
                // Check if it's a connection error
                if (error.message?.includes('Failed to fetch') || error.message?.includes('ERR_CONNECTION')) {
                  console.log('[bash] Connection failed, attempting to restart session...');

                  if (isRestarting) {
                    onChunk?.('Bash session is restarting...', 'Bash session is restarting...', true);
                    throw new Error('Bash session is restarting, please try again');
                  }

                  isRestarting = true;
                  try {
                    const newConfig = await electronAPI.runtime.forDocumentLanguage(state.currentFile, "bash");
                    if (newConfig?.alive && newConfig?.port) {
                      updateClient(newConfig.port);
                      state.bashPort = newConfig.port;
                      state.bashSession = newConfig;
                      console.log('[bash] Session restarted on port', currentPort);

                      isRestarting = false;
                      return await realClient.executeStreaming(code, language, onChunk, onStdinRequest, options);
                    } else {
                      throw new Error('Failed to restart bash session');
                    }
                  } catch (restartError) {
                    isRestarting = false;
                    console.error('[bash] Restart failed:', restartError);
                    throw restartError;
                  }
                }
                throw error;
              }
            };
          }

          // For all other properties, delegate to realClient
          if (typeof value === 'function') {
            return value.bind(realClient);
          }
          return value;
        }
      });
    }

    /**
     * Register bash runtime with editor for shell code execution.
     * Bash runtime is per-project, respects session.bash config in mrmd.md.
     */
    async function registerBashWithEditor() {
      console.log('[bash] registerBashWithEditor called');

      if (!state.editor || !state.currentFile) {
        console.log('[bash] No editor or currentFile, skipping');
        return;
      }

      // Check if electronAPI.bash exists (requires app restart after preload changes)
      if (!electronAPI.runtime) {
        console.error('[bash] electronAPI.runtime not available - restart the app!');
        return;
      }

      try {
        console.log('[bash] Calling bash.forDocument for:', state.currentFile);
        // Get or create bash session for this document
        const bashConfig = await electronAPI.runtime.forDocumentLanguage(state.currentFile, "bash");
        console.log('[bash] Got config:', bashConfig);

        if (!bashConfig) {
          console.log('No bash session config for this document');
          return;
        }

        // Check for errors
        if (bashConfig.error) {
          console.error('Bash session error:', bashConfig.error);
          return;
        }

        // Check if session is alive (auto-started or existing)
        if (bashConfig.alive && bashConfig.port) {
          state.bashPort = bashConfig.port;
          state.bashSession = bashConfig;

          // Track in multi-session map
          if (bashConfig.name) {
            setSessionEntry(bashConfig.name, {
              language: 'bash', status: 'connected',
              info: { pid: bashConfig.pid, port: bashConfig.port, cwd: bashConfig.cwd },
            });
          }

          // Use auto-restarting client wrapper
          const bashClient = createAutoRestartingBashClient(bashConfig.port, bashConfig.name);
          state.editor.registerRuntime('bash', bashClient);
          console.log('Registered Bash runtime with editor on port', bashConfig.port, 'cwd:', bashConfig.cwd);
        } else {
          console.log('Bash session not started (auto_start may be false)');
        }
      } catch (e) {
        console.error('Error registering bash runtime:', e);
      }
    }

    /**
     * Register R runtime with editor for R code execution.
     * R runtime is per-project, respects session.r config in mrmd.md.
     */
    async function registerRWithEditor() {
      console.log('[r] registerRWithEditor called');

      if (!state.editor || !state.currentFile) {
        console.log('[r] No editor or currentFile, skipping');
        return;
      }

      // Check if electronAPI.r exists (requires app restart after preload changes)
      if (!electronAPI.runtime) {
        console.log('[r] electronAPI.runtime not available - R runtime not supported');
        return;
      }

      try {
        console.log('[r] Calling r.forDocument for:', state.currentFile);
        // Get or create R session for this document
        const rConfig = await electronAPI.runtime.forDocumentLanguage(state.currentFile, "r");
        console.log('[r] Got config:', rConfig);

        if (!rConfig) {
          console.log('[r] No R session config for this document');
          return;
        }

        // Check for errors
        if (rConfig.error) {
          console.error('[r] R session error:', rConfig.error);
          return;
        }

        // Check if session is alive (auto-started or existing)
        if (rConfig.alive && rConfig.port) {
          state.rPort = rConfig.port;
          state.rSession = rConfig;

          // Track in multi-session map
          if (rConfig.name) {
            setSessionEntry(rConfig.name, {
              language: 'r', status: 'connected',
              info: { pid: rConfig.pid, port: rConfig.port, cwd: rConfig.cwd },
            });
          }

          // Create MRP client for R
          const rClient = new mrmd.MRPClient(
            `http://127.0.0.1:${rConfig.port}/mrp/v1`,
            { languages: ['r', 'R', 'rlang'] }
          );
          state.editor.registerRuntime('r', rClient);
          console.log('[r] Registered R runtime with editor on port', rConfig.port, 'cwd:', rConfig.cwd);
        } else {
          console.log('[r] R session not started (auto_start may be false)');
        }
      } catch (e) {
        console.error('[r] Error registering R runtime:', e);
      }
    }

    /**
     * Register Julia runtime with editor for Julia code execution.
     * Julia runtime is per-project, respects session.julia config in mrmd.md.
     */
    async function registerJuliaWithEditor() {
      console.log('[julia] registerJuliaWithEditor called');

      if (!state.editor || !state.currentFile) {
        console.log('[julia] No editor or currentFile, skipping');
        return;
      }

      // Check if electronAPI.julia exists
      if (!electronAPI.runtime) {
        console.log('[julia] electronAPI.runtime not available - Julia runtime not supported');
        return;
      }

      try {
        console.log('[julia] Calling julia.forDocument for:', state.currentFile);
        // Get or create Julia session for this document
        const juliaConfig = await electronAPI.runtime.forDocumentLanguage(state.currentFile, "julia");
        console.log('[julia] Got config:', juliaConfig);

        if (!juliaConfig) {
          console.log('[julia] No Julia session config for this document');
          return;
        }

        // Check for errors
        if (juliaConfig.error) {
          console.error('[julia] Julia session error:', juliaConfig.error);
          return;
        }

        // Check if session is alive (auto-started or existing)
        if (juliaConfig.alive && juliaConfig.port) {
          state.juliaPort = juliaConfig.port;
          state.juliaSession = juliaConfig;

          // Track in multi-session map
          if (juliaConfig.name) {
            setSessionEntry(juliaConfig.name, {
              language: 'julia', status: 'connected',
              info: { pid: juliaConfig.pid, port: juliaConfig.port, cwd: juliaConfig.cwd },
            });
          }

          // Create MRP client for Julia
          const juliaClient = new mrmd.MRPClient(
            `http://127.0.0.1:${juliaConfig.port}/mrp/v1`,
            { languages: ['julia', 'jl'] }
          );
          state.editor.registerRuntime('julia', juliaClient);
          console.log('[julia] Registered Julia runtime with editor on port', juliaConfig.port, 'cwd:', juliaConfig.cwd);
        } else {
          console.log('[julia] Julia session not started (auto_start may be false)');
        }
      } catch (e) {
        console.error('[julia] Error registering Julia runtime:', e);
      }
    }

    /**
     * Register PTY session with editor for terminal blocks (```term).
     * Starts mrmd-pty server and sets up terminal launch callback.
     */
    async function registerPtyWithEditor() {
      console.log('[pty] registerPtyWithEditor called');

      if (!state.editor || !state.currentFile) {
        console.log('[pty] No editor or currentFile, skipping');
        return;
      }

      // Check if electronAPI.pty exists
      if (!electronAPI.runtime) {
        console.error('[pty] electronAPI.runtime not available - restart the app!');
        return;
      }

      // Check if terminal functions are available in mrmd
      if (!mrmd.terminal?.launchTerminal) {
        console.log('[pty] Terminal functions not available in mrmd');
        return;
      }

      try {
        console.log('[pty] Calling pty.forDocument for:', state.currentFile);
        // Get or create PTY session for this document
        const ptyConfig = await electronAPI.runtime.forDocumentLanguage(state.currentFile, "pty");
        console.log('[pty] Got config:', ptyConfig);

        if (!ptyConfig) {
          console.log('[pty] No PTY session config for this document');
          return;
        }

        // Check for errors
        if (ptyConfig.error) {
          console.error('[pty] PTY session error:', ptyConfig.error);
          return;
        }

        // Store PTY config in state
        state.ptySession = ptyConfig;

        // Inject terminal overlay styles
        mrmd.terminal.injectTermWidgetStyles();

        // Create terminal config for launching terminals
        state.terminalConfig = {
          filePath: state.currentFile,
          cwd: ptyConfig.cwd,
          venv: ptyConfig.venv,
          baseUrl: ptyConfig.alive ? `http://127.0.0.1:${ptyConfig.port}` : null,
        };

        // Set up the global terminal launch handler for cell controls
        // This will be called when user clicks the terminal button on a ```term block
        window._mrmdLaunchTerminal = (block, blockIndex) => {
          console.log('[pty] Launching terminal for block:', blockIndex, block);
          if (state.terminalConfig && state.editor?.view) {
            mrmd.terminal.launchTerminal(block, state.terminalConfig, state.editor.view);
          } else {
            console.error('[pty] Terminal config or editor not available');
          }
        };

        // Add terminal widget extension (for inline terminal display)
        // and keymap (Ctrl+Enter/Shift+Enter to toggle terminal)
        const terminalExtensions = [];

        if (mrmd.terminal.terminalWidget) {
          terminalExtensions.push(...mrmd.terminal.terminalWidget(state.terminalConfig));
        }

        if (mrmd.terminal.terminalKeymap) {
          terminalExtensions.push(mrmd.terminal.terminalKeymap(state.terminalConfig));
        }

        if (terminalExtensions.length > 0) {
          state.editor.view.dispatch({
            effects: mrmd.codemirror.StateEffect.appendConfig.of(terminalExtensions),
          });
          console.log('[pty] Terminal extensions added (widget + keymap)');
        }

        if (ptyConfig.alive) {
          console.log('[pty] Registered PTY with editor, wsUrl:', ptyConfig.wsUrl);
        } else {
          console.log('[pty] PTY server not started (auto_start may be false)');
        }
      } catch (e) {
        console.error('[pty] Error registering PTY with editor:', e);
      }
    }

    /**
     * Try to auto-detect a venv in common locations near the current file.
     * This enables the "just works" experience without requiring explicit config.
     *
     * Checks (in order):
     * 1. .venv/ in file's directory
     * 2. venv/ in file's directory
     * 3. env/ in file's directory
     * 4. .venv/ in parent directory
     */
    async function tryAutoDetectVenv() {
      if (!state.currentFile) {
        state.session.config = null;
        updateSessionStatus('none', null);
        return;
      }

      const fileDir = state.currentFile.replace(/\/[^/]+$/, '');

      // Check common venv locations
      const candidatePaths = [
        `${fileDir}/.venv`,
        `${fileDir}/venv`,
        `${fileDir}/env`,
        `${fileDir.replace(/\/[^/]+$/, '')}/.venv`, // parent dir
      ];

      for (const venvPath of candidatePaths) {
        try {
          // Check if venv exists by looking for bin/python
          const checkResult = await electronAPI.getFileInfo(`${venvPath}/bin/python`);
          if (checkResult?.success) {
            console.log('[auto-detect] Found venv at:', venvPath);

            // Try to start the runtime
            try {
              updateSessionStatus('connecting', 'Auto-detected');
              const startResult = await electronAPI.startPython(venvPath);

              if (startResult?.success) {
                console.log('[auto-detect] Python runtime started on port:', startResult.port);

                state.pythonPort = startResult.port;
                state.pythonVenv = { path: venvPath, runtimeId: startResult.runtimeId };
                state.session.config = {
                  name: 'auto-detected',
                  venv: venvPath,
                  autoStart: true,
                };
                state.session.info = {
                  alive: true,
                  port: startResult.port,
                  venv: venvPath,
                };

                updateSessionStatus('connected', 'Auto-detected');
                registerSessionWithEditor(startResult.port);
                return;
              }
            } catch (e) {
              console.warn('[auto-detect] Failed to start runtime:', e.message);
              // Continue checking other paths
            }
          }
        } catch {
          // Path doesn't exist, try next
        }
      }

      // No venv found - that's OK, user can create one on first run
      console.log('[auto-detect] No venv found in common locations');
      state.session.config = null;
      updateSessionStatus('none', null);
    }

    /**
     * Normalize runtime.forDocument() response shape.
     * New unified API returns { python, bash, r, julia, pty }.
     * Legacy paths may return just the Python session object.
     */
    function getPythonSessionFromRuntimeResponse(runtimeResponse) {
      if (!runtimeResponse || typeof runtimeResponse !== 'object') return null;
      if (runtimeResponse.python && typeof runtimeResponse.python === 'object') {
        return runtimeResponse.python;
      }
      return runtimeResponse;
    }

    /**
     * Resolve and optionally auto-start session for current project
     * If no project exists, auto-detect common venv locations
     */
    async function resolveProjectSession() {
      // If no project, try auto-detecting venv in common locations
      if (!state.project) {
        await tryAutoDetectVenv();
        return;
      }

      try {
        // Get session config from project
        const runtimeResponse = await electronAPI.runtime.forDocument(state.currentFile);
        const sessionConfig = getPythonSessionFromRuntimeResponse(runtimeResponse);

        if (sessionConfig) {
          state.session.config = sessionConfig;

          // Check for errors (e.g., venv not found, auto-start failed)
          if (sessionConfig.error) {
            console.error('Session config error:', sessionConfig.error);
            updateSessionStatus('error', sessionConfig.name);
            showSessionError(sessionConfig.error);
            return;
          }

          // Check if already connected (either existing or auto-started)
          if (sessionConfig.alive && sessionConfig.port) {
            state.session.info = sessionConfig;
            state.pythonPort = sessionConfig.port;
            updateSessionStatus('connected', sessionConfig.name);
            registerSessionWithEditor(sessionConfig.port);

            // Track in multi-session map
            if (sessionConfig.name) {
              setSessionEntry(sessionConfig.name, {
                language: 'python', status: 'connected',
                info: { pid: sessionConfig.pid, port: sessionConfig.port, venv: sessionConfig.venv },
              });
            }
          } else {
            // Show as available but not started
            state.session.name = sessionConfig.name;
            updateSessionStatus('none', null);
          }
        } else {
          state.session.config = null;
          updateSessionStatus('none', null);
        }
      } catch (e) {
        console.error('Error resolving project session:', e);
        updateSessionStatus('error', 'Session error');
      }
    }

    /**
     * Show session error to user
     */
    function showSessionError(message) {
      // For now, log to console. Can enhance with a toast/banner later.
      console.error('Session error:', message);

      // Check for common errors and provide helpful messages
      if (message.includes('mrmd-python not installed')) {
        console.log('Hint: mrmd-python needs to be installed in the venv');
      } else if (message.includes('not found')) {
        console.log('Hint: Check that the venv path in mrmd.md is correct');
      }
    }

    // =========================================================================
    // NO RUNTIME INLINE PROMPT
    // =========================================================================

    /**
     * Current no-runtime prompt state
     */
    let noRuntimePrompt = null;

    /**
     * Show inline prompt when user tries to run code but no runtime is available.
     * This is the "moment of friction" approach from the Jobs/Ive UX discussion.
     *
     * @param {number} cellIndex - Index of the cell that failed
     * @param {Object} cell - Cell info {language, code, start, end}
     * @param {string} language - Language that needs a runtime
     * @param {function} retryCallback - Call this after runtime is set up to retry execution
     */
    function showNoRuntimePrompt(cellIndex, cell, language, retryCallback) {
      // Remove any existing prompt
      hideNoRuntimePrompt();

      // Create prompt element
      const prompt = document.createElement('div');
      prompt.className = 'no-runtime-prompt';
      prompt.id = 'no-runtime-prompt';

      // Position below the cell (approximate - we'll refine this)
      const editorRect = document.getElementById('editor').getBoundingClientRect();
      prompt.style.top = `${editorRect.top + 100}px`;

      // Get language-specific info
      const langLabel = language === 'python' || language === 'py' || language === 'python3'
        ? 'Python'
        : language.charAt(0).toUpperCase() + language.slice(1);

      const isPython = ['python', 'py', 'python3'].includes(language.toLowerCase());
      const isCloudRuntimeUX = Boolean(window.MRMD_SERVER_URL || (window.location?.pathname || '').includes('/u/'));

      prompt.innerHTML = `
        <button class="no-runtime-prompt-dismiss" onclick="hideNoRuntimePrompt()">×</button>
        <div class="no-runtime-prompt-header">
          <svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M8 1v8M8 12v2"/>
            <circle cx="8" cy="8" r="7"/>
          </svg>
          <span>No ${langLabel} runtime ready</span>
        </div>
        <div class="no-runtime-prompt-actions" id="no-runtime-actions">
          ${isPython ? `
            <button class="no-runtime-prompt-btn primary" onclick="startRuntimeAndRetry()">
              Start Python runtime
            </button>
            ${isCloudRuntimeUX ? `
              <button class="no-runtime-prompt-btn" onclick="toggleNoRuntimeAdvanced()">
                More options...
              </button>
              <div id="no-runtime-advanced" style="display:none; width: 100%; margin-top: 8px;">
                <button class="no-runtime-prompt-btn" onclick="restartRuntimesAndRetry()">
                  Restart runtimes
                </button>
                <button class="no-runtime-prompt-btn" onclick="createVenvAndRetry()">
                  Create .venv
                </button>
                <button class="no-runtime-prompt-btn" onclick="chooseVenvAndRetry()">
                  Choose existing...
                </button>
              </div>
            ` : `
              <button class="no-runtime-prompt-btn" onclick="restartRuntimesAndRetry()">
                Restart runtimes
              </button>
              <button class="no-runtime-prompt-btn" onclick="createVenvAndRetry()">
                Create .venv
              </button>
              <button class="no-runtime-prompt-btn" onclick="chooseVenvAndRetry()">
                Choose existing...
              </button>
            `}
            <button class="no-runtime-prompt-btn" onclick="hideNoRuntimePrompt()">
              Dismiss
            </button>
          ` : `
            <button class="no-runtime-prompt-btn primary" onclick="startRuntimeAndRetry()">
              Start ${langLabel} runtime
            </button>
            <button class="no-runtime-prompt-btn" onclick="hideNoRuntimePrompt()">
              Dismiss
            </button>
          `}
        </div>
      `;

      document.body.appendChild(prompt);

      // Store state for callbacks
      noRuntimePrompt = {
        element: prompt,
        language,
        cellIndex,
        cell,
        retryCallback,
      };

      console.log('[noRuntime] Showing prompt for', language, 'cell', cellIndex);
    }

    /**
     * Hide the no-runtime prompt
     */
    function hideNoRuntimePrompt() {
      const existing = document.getElementById('no-runtime-prompt');
      if (existing) {
        existing.remove();
      }
      noRuntimePrompt = null;
    }

    /**
     * Toggle advanced no-runtime actions (cloud UI keeps this collapsed by default)
     */
    function toggleNoRuntimeAdvanced() {
      const panel = document.getElementById('no-runtime-advanced');
      if (!panel) return;
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }

    /**
     * Create .venv in project directory and retry execution
     */
    async function createVenvAndRetry() {
      if (!noRuntimePrompt) return;

      const { retryCallback, language } = noRuntimePrompt;
      const actionsEl = document.getElementById('no-runtime-actions');

      // Show progress
      if (actionsEl) {
        actionsEl.innerHTML = `
          <div class="no-runtime-prompt-progress">
            <div class="no-runtime-prompt-spinner"></div>
            <span>Creating .venv...</span>
          </div>
        `;
      }

      try {
        const venvPath = state.projectDir
          ? `${state.projectDir}/.venv`
          : `${state.currentFile.replace(/\/[^/]+$/, '')}/.venv`;

        console.log('[noRuntime] Creating venv at:', venvPath);

        // Create venv using Python
        const createResult = await electronAPI.createVenv(venvPath);

        if (!createResult?.success) {
          throw new Error(createResult?.error || 'Failed to create venv');
        }

        // Update progress - installing mrmd-python
        if (actionsEl) {
          actionsEl.innerHTML = `
            <div class="no-runtime-prompt-progress">
              <div class="no-runtime-prompt-spinner"></div>
              <span>Installing mrmd-python...</span>
            </div>
          `;
        }

        // Install mrmd-python in the venv
        console.log('[noRuntime] Installing mrmd-python in:', venvPath);
        const installResult = await electronAPI.installMrmdPython(venvPath);

        if (!installResult?.success) {
          throw new Error(installResult?.error || 'Failed to install mrmd-python');
        }

        // Update progress - starting
        if (actionsEl) {
          actionsEl.innerHTML = `
            <div class="no-runtime-prompt-progress">
              <div class="no-runtime-prompt-spinner"></div>
              <span>Starting Python...</span>
            </div>
          `;
        }

        // Start runtime
        const startResult = await electronAPI.startPython(venvPath);

        if (!startResult?.success) {
          throw new Error(startResult?.error || 'Failed to start Python');
        }

        // Register with editor
        if (state.editor && state.currentFile) {
          const docName = stripDocExtension(state.currentFile.split('/').pop());
          const pythonClient = createAutoRestartingPythonClient(startResult.port, docName);
          state.editor.registerRuntime('python', pythonClient);
          state.pythonPort = startResult.port;
          state.pythonVenv = { path: venvPath, runtimeId: startResult.runtimeId };
          console.log('[noRuntime] Python runtime registered');
        }

        // Refresh runtimes panel and update hints
        if (typeof refreshRuntimes === 'function') refreshRuntimes();
        updateSetupHints();

        // Hide prompt and retry
        hideNoRuntimePrompt();

        if (retryCallback) {
          console.log('[noRuntime] Retrying execution...');
          retryCallback();
        }

      } catch (e) {
        console.error('[noRuntime] Failed to create venv:', e);
        if (actionsEl) {
          actionsEl.innerHTML = `
            <div class="no-runtime-prompt-progress" style="color: var(--error, #ef4444);">
              <span>Failed: ${e.message}</span>
            </div>
            <button class="no-runtime-prompt-btn" onclick="hideNoRuntimePrompt()" style="margin-top: 8px;">
              Dismiss
            </button>
          `;
        }
      }
    }

    /**
     * Open venv picker and retry execution after selection
     */
    async function chooseVenvAndRetry() {
      if (!noRuntimePrompt) return;

      const { retryCallback } = noRuntimePrompt;

      // Store retry callback for after venv selection
      window._pendingRuntimeRetry = retryCallback;

      // Hide the prompt
      hideNoRuntimePrompt();

      // Show venv picker
      showVenvPicker();
    }

    function normalizeRuntimeLanguage(language) {
      const raw = String(language || '').toLowerCase();
      if (['python', 'py', 'python3'].includes(raw)) return 'python';
      if (['bash', 'sh', 'shell'].includes(raw)) return 'bash';
      if (['r', 'rlang'].includes(raw)) return 'r';
      if (['julia', 'jl'].includes(raw)) return 'julia';
      if (['javascript', 'js', 'node', 'typescript', 'ts'].includes(raw)) return 'node';
      return raw;
    }

    /**
     * Start the missing runtime from the inline prompt and retry the failed cell.
     */
    async function startRuntimeAndRetry() {
      if (!noRuntimePrompt) return;

      const { language, retryCallback } = noRuntimePrompt;
      const normalized = normalizeRuntimeLanguage(language);
      const actionsEl = document.getElementById('no-runtime-actions');

      if (actionsEl) {
        actionsEl.innerHTML = `
          <div class="no-runtime-prompt-progress">
            <div class="no-runtime-prompt-spinner"></div>
            <span>Starting ${normalized} runtime...</span>
          </div>
        `;
      }

      try {
        if (normalized === 'python') {
          await resolveProjectSession();
          if (!(state.session?.info?.alive && state.session?.info?.port) && !state.pythonPort) {
            throw new Error('Python runtime is still unavailable. Try Create .venv or Choose existing.');
          }
        } else if (normalized === 'bash') {
          await registerBashWithEditor();
        } else if (normalized === 'r') {
          await registerRWithEditor();
        } else if (normalized === 'julia') {
          await registerJuliaWithEditor();
        } else if (normalized === 'node') {
          // JS runtime is client-side; just retry.
        } else {
          throw new Error(`Unsupported runtime: ${language}`);
        }

        hideNoRuntimePrompt();
        await new Promise(r => setTimeout(r, 120));
        if (typeof retryCallback === 'function') {
          await retryCallback();
        }
      } catch (e) {
        console.error('[noRuntime] Failed to start runtime:', e);
        if (actionsEl) {
          actionsEl.innerHTML = `
            <div class="no-runtime-prompt-progress" style="color: var(--error, #ef4444);">
              <span>Failed: ${e.message}</span>
            </div>
            <button class="no-runtime-prompt-btn primary" onclick="startRuntimeAndRetry()" style="margin-top: 8px;">
              Try again
            </button>
            <button class="no-runtime-prompt-btn" onclick="hideNoRuntimePrompt()" style="margin-top: 8px;">
              Dismiss
            </button>
          `;
        }
      }
    }

    /**
     * Restart all currently known runtimes, then retry failed execution.
     */
    async function restartRuntimesAndRetry() {
      if (!noRuntimePrompt) return;
      const { retryCallback } = noRuntimePrompt;
      const actionsEl = document.getElementById('no-runtime-actions');

      if (actionsEl) {
        actionsEl.innerHTML = `
          <div class="no-runtime-prompt-progress">
            <div class="no-runtime-prompt-spinner"></div>
            <span>Restarting runtimes...</span>
          </div>
        `;
      }

      try {
        const names = [...state.sessions.keys()];
        for (const name of names) {
          await restartLanguageSession(name);
        }

        // Re-register language runtimes for current document
        await Promise.allSettled([
          resolveProjectSession(),
          registerBashWithEditor(),
          registerRWithEditor(),
          registerJuliaWithEditor(),
        ]);

        hideNoRuntimePrompt();
        await new Promise(r => setTimeout(r, 180));
        if (typeof retryCallback === 'function') {
          await retryCallback();
        }
      } catch (e) {
        console.error('[noRuntime] Failed to restart runtimes:', e);
        if (actionsEl) {
          actionsEl.innerHTML = `
            <div class="no-runtime-prompt-progress" style="color: var(--error, #ef4444);">
              <span>Failed: ${e.message}</span>
            </div>
            <button class="no-runtime-prompt-btn" onclick="hideNoRuntimePrompt()" style="margin-top: 8px;">
              Dismiss
            </button>
          `;
        }
      }
    }

    /**
     * Hook up noRuntime event handler to editor
     */
    function setupNoRuntimeHandler(editor) {
      if (!editor?.execution?.on) {
        console.log('[noRuntime] Editor execution manager not available');
        return;
      }

      let autoRecovering = false;

      editor.execution.on('noRuntime', async (cellIndex, cell, language, retryCallback) => {
        console.log('[noRuntime] Event received for', language);
        const normalized = normalizeRuntimeLanguage(language);

        // Fast-path UX: auto-recover stopped runtimes once before showing a prompt.
        // This makes stopped Python/Bash/R/Julia runtimes feel self-healing.
        if (!autoRecovering && ['python', 'bash', 'r', 'julia'].includes(normalized)) {
          autoRecovering = true;
          try {
            if (normalized === 'python') await resolveProjectSession();
            if (normalized === 'bash') await registerBashWithEditor();
            if (normalized === 'r') await registerRWithEditor();
            if (normalized === 'julia') await registerJuliaWithEditor();

            // Only retry if the runtime was actually registered successfully.
            // Otherwise fall through to show the prompt (avoids infinite retry loop
            // when there's no project or the runtime can't start).
            const runtimeRegistered =
              (normalized === 'python' && state.pythonPort) ||
              (normalized === 'bash' && state.bashSession?.alive) ||
              (normalized === 'r' && state.rSession?.alive) ||
              (normalized === 'julia' && state.juliaSession?.alive);
            if (runtimeRegistered && typeof retryCallback === 'function') {
              await retryCallback();
              autoRecovering = false;
              return;
            } else {
              console.log('[noRuntime] Auto-recover did not register runtime for', normalized, '- showing prompt');
            }
          } catch (e) {
            console.warn('[noRuntime] Auto-recover failed:', e?.message || e);
          }
          autoRecovering = false;
        }

        showNoRuntimePrompt(cellIndex, cell, language, retryCallback);
      });

      console.log('[noRuntime] Handler registered');
    }

    // =========================================================================
    // SETUP HINTS
    // =========================================================================

    const dismissedHints = new Set();

    /**
     * Update setup hints based on current state
     */
    function updateSetupHints() {
      const hintsEl = document.getElementById('setup-hints');
      const sessionHoverTrigger = document.getElementById('session-hover-trigger');
      const hoverBtn = document.getElementById('session-hover-btn');
      const hoverText = document.getElementById('session-hover-text');
      const hoverIcon = document.getElementById('session-hover-icon');

      if (!hintsEl) return;

      const hints = [];

      // Check for missing project config
      const hasProjectConfig = state.project?.config?.name;
      if (!hasProjectConfig && !dismissedHints.has('no-project')) {
        hints.push('no-project');
      }

      // Check for missing session config in document
      const hasSessionConfig = checkDocumentHasSessionConfig();

      // Check for missing venv
      const hasVenv = state.project?.config?.venv || state.session?.config?.venv;
      if (!hasVenv && hasSessionConfig && !dismissedHints.has('no-venv')) {
        hints.push('no-venv');
      }

      // Show/hide individual hints
      document.getElementById('hint-no-project').style.display =
        hints.includes('no-project') ? 'flex' : 'none';
      document.getElementById('hint-no-venv').style.display =
        hints.includes('no-venv') ? 'flex' : 'none';

      // Show/hide hints container (for project/venv hints only)
      hintsEl.style.display = hints.length > 0 ? 'block' : 'none';

      // Update contextual hover trigger based on Python state
      if (sessionHoverTrigger && hoverText && hoverIcon) {
        const hasRuntime = state.pythonPort != null;
        const hasVenvDetected = state.pythonVenv || state.session?.config?.venv;

        if (hasRuntime) {
          // Python is running - hide the trigger (everything is working)
          sessionHoverTrigger.classList.remove('visible');
        } else if (hasVenvDetected) {
          // Venv exists but not running - show "Start Python"
          sessionHoverTrigger.classList.add('visible');
          hoverText.textContent = 'Start Python';
          hoverIcon.innerHTML = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <polygon points="5,3 13,8 5,13" fill="currentColor"/>
          </svg>`;
          hoverBtn.title = 'Start Python runtime';
        } else if (!hasSessionConfig) {
          // No config, no venv - show contextual prompt
          // But only if this looks like a Python-using document
          const doc = state.editor?.view?.state.doc.toString() || '';
          const hasPythonCode = /```python|```py/.test(doc);

          if (hasPythonCode) {
            sessionHoverTrigger.classList.add('visible');
            hoverText.textContent = 'Setup Python';
            hoverIcon.innerHTML = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="8" cy="8" r="7"/>
              <path d="M8 5v4M8 11v1"/>
            </svg>`;
            hoverBtn.title = 'Set up Python environment';
          } else {
            // No Python code - hide trigger
            sessionHoverTrigger.classList.remove('visible');
          }
        } else {
          // Has config but no venv detected - venv might be missing
          sessionHoverTrigger.classList.add('visible');
          hoverText.textContent = 'Create .venv';
          hoverIcon.innerHTML = `<svg viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M8 3v10M3 8h10"/>
          </svg>`;
          hoverBtn.title = 'Create Python virtual environment';
        }
      }
    }

    /**
     * Check if current document has session config in frontmatter
     * Supports both verbose (session:) and minimal syntax (python:, bash:, etc.)
     */
    function checkDocumentHasSessionConfig() {
      if (!state.editor?.view) return false;

      const doc = state.editor.view.state.doc.toString();

      // Patterns for both verbose and minimal syntax
      // Verbose: session:
      // Minimal: python:, bash:, node:, julia:, r:, term:
      const runtimePatterns = ['session:', 'python:', 'bash:', 'node:', 'julia:', 'r:', 'term:'];

      // Check for frontmatter
      const frontmatterMatch = doc.match(/^---\n([\s\S]*?)\n---/);
      if (frontmatterMatch) {
        const yaml = frontmatterMatch[1];
        return runtimePatterns.some(p => yaml.includes(p));
      }

      // Also check for ```yaml config blocks with session
      if (doc.includes('```yaml')) {
        return runtimePatterns.some(p => doc.includes(p));
      }

      return false;
    }

    /**
     * Dismiss a hint
     */
    function dismissHint(hintId) {
      dismissedHints.add(hintId);
      updateSetupHints();
    }

    /**
     * Initialize current directory as mrmd project
     */
    async function initializeProject() {
      if (!state.projectDir) {
        alert('No directory to initialize');
        return;
      }

      try {
        // Get folder name for project name
        const folderName = state.projectDir.split('/').pop() || 'project';

        // Create mrmd.md with complete config template
        const mrmdConfig = `# ${folderName}

Project configuration for mrmd.

\`\`\`yaml config
name: "${folderName}"

session:
  python:
    venv: .venv
    cwd: .
    name: default
    auto_start: true
  bash:
    cwd: .
    name: default
    auto_start: true

assets:
  directory: _assets
\`\`\`
`;

        const mrmdPath = state.projectDir + '/mrmd.md';
        await electronAPI.file.write(mrmdPath, mrmdConfig);

        console.log('Project initialized:', mrmdPath);

        // Refresh project info
        const project = await electronAPI.project.get(state.currentFile);
        state.project = project;
        updateNavSidebar(project);
        updateSetupHints();
      } catch (e) {
        console.error('Failed to initialize project:', e);
        alert('Failed to initialize project: ' + e.message);
      }
    }

    /**
     * Handle contextual click on the session hover button.
     * Action depends on current state:
     * - If venv exists but not running: start Python
     * - If no venv: create one
     * - If no config: show setup prompt
     */
    async function handleSessionHoverClick() {
      const hasRuntime = state.pythonPort != null;
      const hasVenvDetected = state.pythonVenv || state.session?.config?.venv;
      const hasSessionConfig = checkDocumentHasSessionConfig();

      if (hasRuntime) {
        // Already running - nothing to do
        return;
      }

      if (hasVenvDetected) {
        // Venv exists but not running - start it
        const venvPath = state.pythonVenv?.path || state.session?.config?.venv;
        if (venvPath) {
          try {
            const hoverText = document.getElementById('session-hover-text');
            if (hoverText) hoverText.textContent = 'Starting...';

            const startResult = await electronAPI.startPython(venvPath);
            if (startResult?.success) {
              state.pythonPort = startResult.port;
              state.pythonVenv = { path: venvPath, runtimeId: startResult.runtimeId };
              updateSessionStatus('connected', 'Started');
              registerSessionWithEditor(startResult.port);
              updateSetupHints();
            }
          } catch (e) {
            console.error('Failed to start Python:', e);
          }
        }
      } else if (!hasSessionConfig) {
        // No config, no venv - show inline prompt (same as noRuntime handler)
        const doc = state.editor?.view?.state.doc.toString() || '';
        const cell = { language: 'python', code: '' };
        showNoRuntimePrompt(0, cell, 'python', null);
      } else {
        // Has config but no venv - create one
        await createVenvAndRetry();
      }
    }

    /**
     * Insert session config at the top of the document.
     * Uses minimal frontmatter syntax: python: .venv
     */
    function insertSessionConfig() {
      if (!state.editor?.view) return;

      const view = state.editor.view;
      const doc = view.state.doc.toString();

      // Check if document already has frontmatter
      if (doc.startsWith('---\n')) {
        // Has frontmatter - add python: .venv line to it
        const endIndex = doc.indexOf('\n---', 3);
        if (endIndex !== -1) {
          // Check if python: already exists
          const frontmatter = doc.slice(4, endIndex);
          if (!frontmatter.includes('python:') && !frontmatter.includes('session:')) {
            // Insert python: .venv before closing ---
            const insertPos = endIndex;
            view.dispatch({
              changes: { from: insertPos, insert: 'python: .venv\n' },
            });
          }
        }
      } else {
        // No frontmatter - add minimal frontmatter at the top
        const minimalFrontmatter = `---
python: .venv
---

`;
        view.dispatch({
          changes: { from: 0, insert: minimalFrontmatter },
          selection: { anchor: minimalFrontmatter.length },
        });
      }

      // Update hints
      setTimeout(updateSetupHints, 100);
    }

    // Note: showVenvPicker() is defined earlier in the VENV PICKER section (line ~3488)
    // It shows the proper venv discovery overlay

    // =========================================================================
    // THEME MANAGEMENT
    // =========================================================================

    const THEMES = ['github', 'midnight', 'moonlight', 'nord', 'daylight', 'openresponses', 'grayscale-dark', 'grayscale-light'];
    let currentThemeIndex = 0;
    const CUSTOM_THEMES_KEY = 'mrmd-custom-themes';

    // Load custom themes from localStorage
    function loadCustomThemes() {
      try {
        const stored = localStorage.getItem(CUSTOM_THEMES_KEY);
        return stored ? JSON.parse(stored) : [];
      } catch (e) {
        console.warn('Failed to load custom themes:', e);
        return [];
      }
    }

    // Save custom themes to localStorage
    function saveCustomThemes(themes) {
      try {
        localStorage.setItem(CUSTOM_THEMES_KEY, JSON.stringify(themes));
      } catch (e) {
        console.warn('Failed to save custom themes:', e);
      }
    }

    // Register custom themes with mrmd
    function registerCustomThemes() {
      const customThemes = loadCustomThemes();
      for (const theme of customThemes) {
        try {
          if (mrmd.widgets?.registerTheme) {
            mrmd.widgets.registerTheme(theme);
          } else if (mrmd.registerTheme) {
            mrmd.registerTheme(theme);
          }
        } catch (e) {
          console.warn(`Failed to register custom theme "${theme.name}":`, e);
        }
      }
    }

    // Get all available theme names (built-in + custom)
    function getAllThemeNames() {
      const customNames = loadCustomThemes().map(t => t.name);
      return [...THEMES, ...customNames];
    }

    function applyTheme(themeName) {
      const theme = mrmd.getTheme(themeName);
      if (!theme) {
        console.error('Theme not found:', themeName);
        return;
      }

      // Inject font-face if theme has one
      if (theme.fontFace) {
        let fontStyle = document.getElementById('mrmd-theme-fonts');
        if (!fontStyle) {
          fontStyle = document.createElement('style');
          fontStyle.id = 'mrmd-theme-fonts';
          document.head.insertBefore(fontStyle, document.head.firstChild);
        }
        fontStyle.textContent = theme.fontFace;
      }

      // Apply all theme variables to :root
      const root = document.documentElement;
      for (const [key, value] of Object.entries(theme)) {
        if (key.startsWith('--')) {
          root.style.setProperty(key, value);
        }
      }

      // Set body class for light/dark mode (affects scrollbars, etc.)
      document.body.classList.toggle('light-theme', theme.isDark === false);
      document.body.classList.toggle('dark-theme', theme.isDark !== false);

      // Add theme-specific class for targeted styling
      THEMES.forEach(t => document.body.classList.remove(`theme-${t}`));
      document.body.classList.add(`theme-${themeName}`);

      // Update status bar and settings panel
      const statusThemeEl = document.getElementById('status-theme');
      const settingsThemeEl = document.getElementById('settings-theme');
      if (statusThemeEl) statusThemeEl.textContent = themeName;
      if (settingsThemeEl) settingsThemeEl.textContent = themeName;

      // Update editor if exists
      if (state.editor && state.editor.setTheme) {
        state.editor.setTheme(themeName);
      }

      // Dispatch theme change event for terminal and other listeners
      document.dispatchEvent(new CustomEvent('mrmd-theme-change', { detail: { theme: themeName } }));

      // Save preference
      localStorage.setItem('mrmd-theme', themeName);
      console.log('Applied theme:', themeName);
    }

    // Theme picker menu
    let themeMenuOpen = false;
    let themeMenuElement = null;

    function cycleTheme() {
      // Now opens a theme picker instead of cycling
      showThemePicker();
    }

    function showThemePicker() {
      if (themeMenuOpen && themeMenuElement) {
        closeThemePicker();
        return;
      }

      const allThemes = getAllThemeNames();
      const customThemeNames = loadCustomThemes().map(t => t.name);
      const currentTheme = localStorage.getItem('mrmd-theme') || 'daylight';

      // Create menu
      themeMenuElement = document.createElement('div');
      themeMenuElement.className = 'theme-picker-menu';
      themeMenuElement.innerHTML = `
        <div class="theme-picker-header">Select Theme</div>
        <div class="theme-picker-section">
          <div class="theme-picker-section-title">Dark</div>
          ${THEMES.filter(t => ['github', 'midnight', 'moonlight', 'nord', 'grayscale-dark'].includes(t))
            .map(t => `<div class="theme-picker-item${t === currentTheme ? ' selected' : ''}" data-theme="${t}">${t}</div>`).join('')}
        </div>
        <div class="theme-picker-section">
          <div class="theme-picker-section-title">Light</div>
          ${THEMES.filter(t => ['daylight', 'openresponses', 'grayscale-light'].includes(t))
            .map(t => `<div class="theme-picker-item${t === currentTheme ? ' selected' : ''}" data-theme="${t}">${t}</div>`).join('')}
        </div>
        ${customThemeNames.length > 0 ? `
        <div class="theme-picker-section">
          <div class="theme-picker-section-title">Custom</div>
          ${customThemeNames.map(t => `
            <div class="theme-picker-item${t === currentTheme ? ' selected' : ''}" data-theme="${t}">
              ${t}
              <span class="theme-picker-delete" data-delete="${t}" title="Delete theme">×</span>
            </div>
          `).join('')}
        </div>
        ` : ''}
        <div class="theme-picker-divider"></div>
        <div class="theme-picker-item theme-picker-import" data-action="import">
          Import Theme...
        </div>
        <div class="theme-picker-item theme-picker-help" data-action="help">
          <span>?</span> How to create themes
        </div>
      `;

      // Position menu near settings panel
      const settingsPanel = document.getElementById('panel-settings');
      const themeItem = settingsPanel?.querySelector('.rail-panel-item');
      if (themeItem) {
        const rect = themeItem.getBoundingClientRect();
        themeMenuElement.style.position = 'fixed';
        themeMenuElement.style.top = `${rect.bottom + 4}px`;
        themeMenuElement.style.left = `${rect.left}px`;
      }

      document.body.appendChild(themeMenuElement);
      themeMenuOpen = true;

      // Handle clicks
      themeMenuElement.addEventListener('click', (e) => {
        const deleteBtn = e.target.closest('[data-delete]');
        if (deleteBtn) {
          e.stopPropagation();
          const themeName = deleteBtn.getAttribute('data-delete');
          deleteCustomTheme(themeName);
          closeThemePicker();
          return;
        }

        const item = e.target.closest('[data-theme]');
        if (item) {
          const themeName = item.getAttribute('data-theme');
          applyTheme(themeName);
          closeThemePicker();
          return;
        }

        const importBtn = e.target.closest('[data-action="import"]');
        if (importBtn) {
          closeThemePicker();
          importThemeFile();
          return;
        }

        const helpBtn = e.target.closest('[data-action="help"]');
        if (helpBtn) {
          closeThemePicker();
          showThemeHelp();
          return;
        }
      });

      // Close on outside click
      setTimeout(() => {
        document.addEventListener('click', closeThemePickerOnOutsideClick);
      }, 0);
    }

    function closeThemePickerOnOutsideClick(e) {
      if (themeMenuElement && !themeMenuElement.contains(e.target)) {
        closeThemePicker();
      }
    }

    function closeThemePicker() {
      if (themeMenuElement) {
        themeMenuElement.remove();
        themeMenuElement = null;
      }
      themeMenuOpen = false;
      document.removeEventListener('click', closeThemePickerOnOutsideClick);
    }

    function importThemeFile() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json,application/json';
      input.style.display = 'none';

      input.onchange = async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;

        try {
          const text = await file.text();
          const theme = JSON.parse(text);

          // Validate
          if (!theme.name || typeof theme.name !== 'string') {
            alert('Invalid theme: must have a "name" property');
            return;
          }
          if (THEMES.includes(theme.name)) {
            alert(`Cannot use reserved theme name "${theme.name}"`);
            return;
          }

          // Register with mrmd
          if (mrmd.widgets?.registerTheme) {
            mrmd.widgets.registerTheme(theme);
          } else if (mrmd.registerTheme) {
            mrmd.registerTheme(theme);
          }

          // Save to localStorage
          const customThemes = loadCustomThemes();
          const existingIndex = customThemes.findIndex(t => t.name === theme.name);
          if (existingIndex >= 0) {
            customThemes[existingIndex] = theme;
          } else {
            customThemes.push(theme);
          }
          saveCustomThemes(customThemes);

          // Apply
          applyTheme(theme.name);
          alert(`Theme "${theme.name}" imported successfully!`);
        } catch (err) {
          console.error('Failed to import theme:', err);
          alert(`Failed to import theme: ${err.message}`);
        }
        input.remove();
      };

      document.body.appendChild(input);
      input.click();
    }

    function deleteCustomTheme(themeName) {
      if (!confirm(`Delete custom theme "${themeName}"?`)) return;

      const customThemes = loadCustomThemes();
      const filtered = customThemes.filter(t => t.name !== themeName);
      saveCustomThemes(filtered);

      // Switch to default if deleted current
      const current = localStorage.getItem('mrmd-theme');
      if (current === themeName) {
        applyTheme('github');
      }
    }

    function showThemeHelp() {
      const neonThemeExample = `{
  "name": "neon",
  "description": "Cyberpunk neon theme",
  "isDark": true,

  // ===================
  // CUSTOM FONTS (optional)
  // ===================
  // Use fontFace to load custom fonts. Paths are relative to your app.
  // "fontFace": "@font-face { font-family: 'MyFont'; src: url('./fonts/MyFont.woff2'); }",

  // ===================
  // EDITOR COLORS
  // ===================
  "--editor-background": "#0a0a1a",
  "--editor-foreground": "#e0e0ff",
  "--editor-line-number": "#444466",
  "--editor-line-number-active": "#00ffff",
  "--editor-selection": "#ff00ff33",
  "--editor-cursor": "#00ffff",
  "--editor-active-line": "rgba(0, 255, 255, 0.05)",

  // ===================
  // SYNTAX HIGHLIGHTING
  // ===================
  "--syntax-keyword": "#ff00ff",
  "--syntax-control": "#ff00ff",
  "--syntax-string": "#00ff88",
  "--syntax-number": "#ffee00",
  "--syntax-comment": "#555588",
  "--syntax-function": "#00ffff",
  "--syntax-variable": "#e0e0ff",
  "--syntax-property": "#00aaff",
  "--syntax-operator": "#ff00ff",
  "--syntax-type": "#ffaa00",
  "--syntax-class": "#ffaa00",

  // ===================
  // WIDGET/OUTPUT COLORS
  // ===================
  "--widget-surface": "#0a0a1a",
  "--widget-surface-hover": "#12122a",
  "--widget-text": "#e0e0ff",
  "--widget-text-muted": "#8888bb",
  "--widget-text-accent": "#00ffff",
  "--widget-border": "rgba(0, 255, 255, 0.15)",
  "--widget-border-accent": "#00ffff",

  // ===================
  // SEMANTIC COLORS
  // ===================
  "--widget-success": "#00ff88",
  "--widget-warning": "#ffaa00",
  "--widget-error": "#ff3366",
  "--widget-info": "#00aaff",

  // ===================
  // ANSI TERMINAL COLORS
  // ===================
  "--ansi-black": "#0a0a1a",
  "--ansi-red": "#ff3366",
  "--ansi-green": "#00ff88",
  "--ansi-yellow": "#ffee00",
  "--ansi-blue": "#00aaff",
  "--ansi-magenta": "#ff00ff",
  "--ansi-cyan": "#00ffff",
  "--ansi-white": "#e0e0ff",

  // ===================
  // SHELL UI (panels, menus)
  // ===================
  "--mrmd-panel-bg": "#0a0a1a",
  "--mrmd-popup-bg": "#0f0f24",
  "--mrmd-bg": "#0a0a1a",
  "--mrmd-fg": "#e0e0ff",
  "--mrmd-fg-muted": "#8888bb",
  "--mrmd-border": "#ff00ff44",
  "--mrmd-accent": "#00ffff",
  "--mrmd-hover-bg": "rgba(0, 255, 255, 0.08)"
}`;

      const overlay = document.createElement('div');
      overlay.className = 'theme-help-overlay';
      overlay.innerHTML = `
        <div class="theme-help-dialog theme-help-dialog-large">
          <div class="theme-help-header">
            <span>Theme Reference Guide</span>
            <button class="theme-help-close">&times;</button>
          </div>
          <div class="theme-help-content">
            <h3>Overview</h3>
            <p>Themes are JSON files containing CSS custom properties (variables). Save as <code>.json</code> and import via the theme picker.</p>

            <h3>Required Properties</h3>
            <table class="theme-help-table">
              <tr><td><code>name</code></td><td>Unique identifier (e.g., "my-theme")</td></tr>
              <tr><td><code>isDark</code></td><td><code>true</code> for dark themes, <code>false</code> for light</td></tr>
            </table>

            <h3>Optional Properties</h3>
            <table class="theme-help-table">
              <tr><td><code>description</code></td><td>Human-readable description</td></tr>
              <tr><td><code>fontFace</code></td><td>CSS @font-face rules for custom fonts</td></tr>
            </table>

            <h3>Token Categories</h3>

            <h4>Editor</h4>
            <p>Core editor appearance:</p>
            <table class="theme-help-table">
              <tr><td><code>--editor-background</code></td><td>Main editor background</td></tr>
              <tr><td><code>--editor-foreground</code></td><td>Default text color</td></tr>
              <tr><td><code>--editor-selection</code></td><td>Selection highlight</td></tr>
              <tr><td><code>--editor-cursor</code></td><td>Cursor color</td></tr>
              <tr><td><code>--editor-line-number</code></td><td>Line numbers</td></tr>
              <tr><td><code>--editor-active-line</code></td><td>Current line highlight</td></tr>
            </table>

            <h4>Syntax Highlighting</h4>
            <p>Code coloring:</p>
            <table class="theme-help-table">
              <tr><td><code>--syntax-keyword</code></td><td>if, else, function, class</td></tr>
              <tr><td><code>--syntax-string</code></td><td>String literals</td></tr>
              <tr><td><code>--syntax-number</code></td><td>Numbers</td></tr>
              <tr><td><code>--syntax-comment</code></td><td>Comments</td></tr>
              <tr><td><code>--syntax-function</code></td><td>Function names</td></tr>
              <tr><td><code>--syntax-variable</code></td><td>Variables</td></tr>
              <tr><td><code>--syntax-type</code></td><td>Type names</td></tr>
              <tr><td><code>--syntax-property</code></td><td>Object properties</td></tr>
              <tr><td><code>--syntax-operator</code></td><td>+, -, =, etc.</td></tr>
              <tr><td><code>--syntax-control</code></td><td>return, break, continue</td></tr>
            </table>

            <h4>Widgets & Output</h4>
            <p>Code output and UI widgets:</p>
            <table class="theme-help-table">
              <tr><td><code>--widget-surface</code></td><td>Widget background</td></tr>
              <tr><td><code>--widget-text</code></td><td>Primary text</td></tr>
              <tr><td><code>--widget-text-muted</code></td><td>Secondary text</td></tr>
              <tr><td><code>--widget-text-accent</code></td><td>Accent/link color</td></tr>
              <tr><td><code>--widget-border</code></td><td>Border color</td></tr>
              <tr><td><code>--widget-border-accent</code></td><td>Accent border (output left bar)</td></tr>
            </table>

            <h4>Semantic Colors</h4>
            <table class="theme-help-table">
              <tr><td><code>--widget-success</code></td><td>Success states (green)</td></tr>
              <tr><td><code>--widget-warning</code></td><td>Warnings (yellow/orange)</td></tr>
              <tr><td><code>--widget-error</code></td><td>Errors (red)</td></tr>
              <tr><td><code>--widget-info</code></td><td>Info (blue)</td></tr>
            </table>

            <h4>ANSI Terminal Colors</h4>
            <p>For terminal output. All have <code>--ansi-bright-*</code> variants too.</p>
            <table class="theme-help-table">
              <tr><td><code>--ansi-black</code>, <code>--ansi-red</code>, <code>--ansi-green</code>, <code>--ansi-yellow</code></td></tr>
              <tr><td><code>--ansi-blue</code>, <code>--ansi-magenta</code>, <code>--ansi-cyan</code>, <code>--ansi-white</code></td></tr>
            </table>

            <h4>Shell UI</h4>
            <p>Panels, menus, dialogs:</p>
            <table class="theme-help-table">
              <tr><td><code>--mrmd-bg</code></td><td>Main background</td></tr>
              <tr><td><code>--mrmd-fg</code></td><td>Main foreground</td></tr>
              <tr><td><code>--mrmd-panel-bg</code></td><td>Panel background</td></tr>
              <tr><td><code>--mrmd-popup-bg</code></td><td>Popup/menu background</td></tr>
              <tr><td><code>--mrmd-border</code></td><td>Border color</td></tr>
              <tr><td><code>--mrmd-accent</code></td><td>Accent color</td></tr>
              <tr><td><code>--mrmd-hover-bg</code></td><td>Hover state background</td></tr>
            </table>

            <h4>Typography</h4>
            <table class="theme-help-table">
              <tr><td><code>--widget-font-mono</code></td><td>Monospace font stack</td></tr>
              <tr><td><code>--widget-font-sans</code></td><td>Sans-serif font stack</td></tr>
              <tr><td><code>--editor-font-family</code></td><td>Editor font</td></tr>
              <tr><td><code>--widget-font-size</code></td><td>Base widget font size</td></tr>
            </table>

            <h4>Custom Fonts</h4>
            <p>Add a <code>fontFace</code> property with @font-face CSS:</p>
            <pre><code>"fontFace": "@font-face { font-family: 'MyFont'; font-weight: 100 900; src: url('./fonts/MyFont.woff2') format('woff2'); }",
"--widget-font-mono": "'MyFont', monospace"</code></pre>

            <h3>Complete Example (Neon Theme)</h3>
            <p>Copy this, save as <code>neon.json</code>, and import:</p>
            <div class="theme-help-example">
              <button class="theme-help-copy" onclick="navigator.clipboard.writeText(this.parentElement.querySelector('code').textContent.replace(/\\/\\/.*$/gm, '')); this.textContent='Copied!'; setTimeout(() => this.textContent='Copy', 1500)">Copy</button>
              <pre><code>${neonThemeExample.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</code></pre>
            </div>
            <p><em>Note: Remove comments before importing (JSON doesn't support comments).</em></p>
          </div>
        </div>
      `;

      overlay.querySelector('.theme-help-close').onclick = () => overlay.remove();
      overlay.onclick = (e) => { if (e.target === overlay) overlay.remove(); };

      document.body.appendChild(overlay);
    }

    function loadSavedTheme() {
      // Register custom themes first
      registerCustomThemes();

      const saved = localStorage.getItem('mrmd-theme') || 'daylight';
      const allThemes = getAllThemeNames();
      currentThemeIndex = allThemes.indexOf(saved);
      if (currentThemeIndex < 0) currentThemeIndex = 0;
      applyTheme(allThemes[currentThemeIndex] || 'daylight');
    }

    // =========================================================================
    // UTILITIES
    // =========================================================================

    const JS_IMPORT_HELPER_SNIPPET = `globalThis.loadPkg ??= async (name, url, pick = 'default') => {
  globalThis.__pkgCache ??= {};
  if (!globalThis.__pkgCache[name]) globalThis.__pkgCache[name] = import(url);
  const mod = await globalThis.__pkgCache[name];
  return pick === 'default' ? (mod.default ?? mod) : mod[pick];
};

// Example:
_ = await globalThis.loadPkg('lodash', 'https://cdn.skypack.dev/lodash');`;

    function renderJavaScriptImportHelpSnippet() {
      const codeEl = document.getElementById('help-js-import-code');
      if (codeEl) codeEl.textContent = JS_IMPORT_HELPER_SNIPPET;
    }

    function copyJavaScriptImportHelper(buttonEl) {
      navigator.clipboard.writeText(JS_IMPORT_HELPER_SNIPPET).then(() => {
        if (!buttonEl) return;
        const original = buttonEl.textContent;
        buttonEl.textContent = 'Copied!';
        setTimeout(() => {
          buttonEl.textContent = original || 'Copy';
        }, 1500);
      }).catch((err) => {
        console.error('[help] Failed to copy JS helper snippet:', err);
      });
    }

    function formatTimeAgo(date) {
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 60) return 'just now';
      if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
      if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
      if (seconds < 604800) return Math.floor(seconds / 86400) + 'd ago';
      return date.toLocaleDateString();
    }

    // =========================================================================
    // KEYBOARD NAVIGATION
    // =========================================================================

    document.addEventListener('keydown', (e) => {
      const filePickerVisible = document.getElementById('file-picker-overlay').classList.contains('visible');
      const venvPickerVisible = document.getElementById('venv-picker-overlay').classList.contains('visible');

      // Global shortcuts
      if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
        e.preventDefault();
        if (!filePickerVisible) showFilePicker();
        return;
      }

      if ((e.ctrlKey || e.metaKey) && e.key === 'r' && !e.shiftKey) {
        e.preventDefault();
        if (!venvPickerVisible) showVenvPicker();
        return;
      }

      // File picker navigation
      if (filePickerVisible) {
        if (e.key === 'Escape') {
          hideFilePicker();
          return;
        }

        const totalItems = state.pickerSelectable.length;
        const selectedEntry = state.pickerSelectable[state.selectedFileIndex];
        const pickerInput = document.getElementById('file-search');

        if (e.key === 'ArrowDown' || (e.ctrlKey && e.key === 'n') || (e.ctrlKey && e.key === 'j')) {
          e.preventDefault();
          if (state.selectedFileIndex < totalItems - 1) {
            selectFileItem(state.selectedFileIndex + 1);
          }
          return;
        }

        if (e.key === 'ArrowUp' || (e.ctrlKey && e.key === 'p') || (e.ctrlKey && e.key === 'k')) {
          e.preventDefault();
          if (state.selectedFileIndex > 0) {
            selectFileItem(state.selectedFileIndex - 1);
          }
          return;
        }

        if (e.key === 'ArrowRight') {
          if (selectedEntry?.kind === 'file' && selectedEntry.file?.isFolder) {
            e.preventDefault();
            enterFolder(selectedEntry.path);
            return;
          }
        }

        if (e.key === 'ArrowLeft') {
          if (pickerInput.value === '') {
            const activeScope = getActiveScopePath();
            if (activeScope) {
              e.preventDefault();
              exitFolderContext();
              return;
            }
          }
        }

        // Ctrl/Cmd+Enter: Create file/project (jump to create option)
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          const createIndex = state.pickerSelectable.findIndex(item =>
            item.kind === 'create-file' || item.kind === 'create-project'
          );
          if (createIndex !== -1) {
            selectFileItem(createIndex);
            const createEntry = state.pickerSelectable[createIndex];
            if (createEntry?.kind === 'create-file') createNewFile();
            if (createEntry?.kind === 'create-project') createNewProject();
          }
          return;
        }

        if (e.key === 'Enter') {
          e.preventDefault();
          openSelectedFile();
          return;
        }

        // Tab completion
        if (e.key === 'Tab') {
          e.preventDefault();
          if (e.shiftKey) {
            if (getActiveScopePath()) exitFolderContext();
            return;
          }
          tabComplete();
          return;
        }

        // Backspace at empty input exits folder context
        if (e.key === 'Backspace' && getActiveScopePath()) {
          if (pickerInput.value === '') {
            e.preventDefault();
            exitFolderContext();
            return;
          }
        }
      }

      // Venv picker navigation
      if (venvPickerVisible) {
        if (e.key === 'Escape') {
          hideVenvPicker();
          return;
        }

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          const totalItems = state.filteredRuntimes.length + state.filteredVenvs.length;
          if (state.selectedVenvIndex < totalItems - 1) {
            selectVenvItem(state.selectedVenvIndex + 1);
          }
          return;
        }

        if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (state.selectedVenvIndex > 0) {
            selectVenvItem(state.selectedVenvIndex - 1);
          }
          return;
        }

        if (e.key === 'Enter') {
          e.preventDefault();
          if (e.shiftKey) {
            // Shift+Enter: force new runtime for selected venv
            const numRuntimes = state.filteredRuntimes.length;
            const venvIndex = state.selectedVenvIndex - numRuntimes;
            if (venvIndex >= 0 && venvIndex < state.filteredVenvs.length) {
              startNewRuntime(state.filteredVenvs[venvIndex].path);
            }
          } else {
            selectVenv();
          }
          return;
        }
      }
    });

    // File search input handler
    document.getElementById('file-search').addEventListener('input', (e) => {
      scheduleFilter(e.target.value);
    });

    document.getElementById('venv-search').addEventListener('input', (e) => {
      filterVenvs(e.target.value);
    });

    document.getElementById('custom-python-path').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const customPath = e.target.value.trim();
        if (customPath) {
          // Expand ~ to home directory
          const expandedPath = customPath.replace(/^~/, '');
          startNewRuntime(expandedPath.startsWith('/') ? expandedPath : customPath);
        }
      }
      if (e.key === 'Escape') {
        hideVenvPicker();
      }
    });

    // =========================================================================
    // IPC EVENT HANDLERS
    // =========================================================================

    electronAPI.onFilesUpdate((data) => {
      const payload = data || {};
      const hasLegacyFiles = Array.isArray(payload.files);
      const hasChunkFiles = Array.isArray(payload.filesChunk);
      const hasChunkDirs = Array.isArray(payload.dirsChunk);

      if (payload.reset) {
        if (state._backgroundRescan) {
          // Background rescan: don't clear existing data, just accept the new token
          state._backgroundRescan = false;
        } else {
          state.files = [];
          state.scannedDirs = [];
          state.fileIndex.ready = false;
        }
      }

      if (payload.scanToken != null) {
        if (payload.reset || state.fileScanToken == null) {
          state.fileScanToken = payload.scanToken;
        } else if (state.fileScanToken !== payload.scanToken) {
          return;
        }
      }

      // Always accumulate data even if picker is hidden (for cache)
      if (hasLegacyFiles) {
        state.files = payload.files;
      } else if (hasChunkFiles && payload.filesChunk.length > 0) {
        state.files.push(...payload.filesChunk);
      }
      if (hasChunkDirs && payload.dirsChunk.length > 0) {
        state.scannedDirs.push(...payload.dirsChunk);
      }

      const isDone = payload.done === true || (hasLegacyFiles && payload.done == null);
      state.fileScanStatus = isDone ? 'ready' : 'scanning';

      if (!isFilePickerVisible()) {
        // Still rebuild the index so it's ready when picker opens
        if (isDone) rebuildFileIndex();
        return;
      }

      setPickerStatus(state.fileIndex.ready ? state.filteredFiles.length : state.files.length);
      scheduleFileIndexRefresh({ immediate: Boolean(isDone) });
    });

    electronAPI.onVenvFound((venv) => {
      addVenv(venv);
    });

    electronAPI.onVenvScanDone(() => {
      console.log('Venv scan complete');
    });

    // =========================================================================
    // DATA LOSS PREVENTION
    // =========================================================================
    // Added after investigating unexplained data loss on 2026-01-16.
    // The sync server crashed with OOM, but the editor kept running with no
    // indication that changes weren't being saved. User lost ~2.5 hours of work.
    // These safeguards ensure:
    // 1. User is immediately warned when sync fails
    // 2. Content is automatically backed up to localStorage
    // 3. User can easily recover their content
    // =========================================================================

    let syncHealthy = true;
    let lastBackupTime = null;
    let watchdogInterval = null;
    let syncWarningTimer = null;
    let syncWarningReason = null;
    let syncProvider = null;
    let syncStatusHandler = null;
    let syncErrorHandler = null;
    let syncHasEverConnected = false;

    const SYNC_CONNECT_GRACE_MS = 10000;
    const SYNC_RECONNECT_GRACE_MS = 5000;

    // Handle sync server death notification from main process
    electronAPI.onSyncServerDied((data) => {
      console.error('SYNC SERVER DIED:', data);
      syncHealthy = false;
      clearSyncWarningTimer();
      triggerSyncWarning(data?.reason || 'exited', 'sync-died');

      // Play alert sound (if available)
      try {
        const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleQAAe8Te3JZfGBBPsOT/1GscAGTC/tuoXgAAfsT/26deBzSG0+3ZmmQlPnK96uypcTtMdbLt6qx1P0x0tezrrHU/THS07OusdD9Mc7Xs66x0P0xztezrrHQ/THS17Ousc0BNdLXs66xzP0xztOzrrHM/THOz6+urcz9Mc7Tr7KtzP0xztOvrrHM/THO16+yrcz5Mc7Xr66tzP0xztevrrHM/THO16+uscz9MdLXr66xzP0x0tevsq3M/THO16+yrcz9MdLXr7KtzP0x0tevsq3M/THS16+yrcz5MdLXr7KtzP0x0tevsq3M/');
        audio.volume = 0.5;
        audio.play().catch(() => {});
      } catch (e) {}
    });

    // Handle file opened from OS (e.g., double-click .md file when MRMD is default app)
    // This opens the file exactly like selecting it from the Ctrl+P menu
    electronAPI.onOpenWithFile(async (data) => {
      console.log('[open-with-file] Received file from OS:', data.filePath);
      try {
        await openFile(data.filePath);
        console.log('[open-with-file] File opened successfully');
      } catch (e) {
        console.error('[open-with-file] Failed to open file:', e);
      }
    });

    function showSyncWarning(data) {
      const banner = document.getElementById('sync-warning-banner');
      const details = document.getElementById('sync-warning-details');
      const reason = data && data.reason ? data.reason : 'connection lost';

      details.textContent = ` Sync server ${reason}. Your current changes exist only in memory!`;
      banner.classList.add('visible');

      // Also update status bar
      const syncDot = document.querySelector('.status-dot');
      if (syncDot) {
        syncDot.className = 'status-dot error';
      }
    }

    function hideSyncWarning() {
      document.getElementById('sync-warning-banner').classList.remove('visible');
    }

    function clearSyncWarningTimer() {
      if (syncWarningTimer) {
        clearTimeout(syncWarningTimer);
        syncWarningTimer = null;
      }
    }

    function triggerSyncWarning(reason, backupReason = 'sync-offline') {
      clearSyncWarningTimer();
      syncHealthy = false;
      showSyncWarning({ reason });
      saveLocalBackup(backupReason);
    }

    function scheduleSyncWarning(reason, delayMs) {
      syncWarningReason = reason;
      if (syncWarningTimer) return;

      syncWarningTimer = setTimeout(() => {
        syncWarningTimer = null;
        triggerSyncWarning(syncWarningReason);
      }, delayMs);
    }

    function detachSyncStatusHandlers() {
      if (!syncProvider) return;

      if (syncStatusHandler) {
        syncProvider.off('status', syncStatusHandler);
      }
      if (syncErrorHandler) {
        syncProvider.off('connection-error', syncErrorHandler);
      }

      syncProvider = null;
      syncStatusHandler = null;
      syncErrorHandler = null;
      syncHasEverConnected = false;
      clearSyncWarningTimer();
    }

    function attachSyncStatusHandlers(editor) {
      detachSyncStatusHandlers();
      if (!editor || !editor.provider) return;

      syncProvider = editor.provider;
      const initialConnected = !!(syncProvider.wsconnected || syncProvider.synced);
      syncHasEverConnected = initialConnected;

      syncStatusHandler = ({ status }) => {
        if (status === 'connected') {
          syncHasEverConnected = true;
          syncHealthy = true;
          clearSyncWarningTimer();
          hideSyncWarning();
          return;
        }

        const delayMs = syncHasEverConnected ? SYNC_RECONNECT_GRACE_MS : SYNC_CONNECT_GRACE_MS;
        const reason = status === 'connecting' ? 'reconnecting' : 'connection lost';
        scheduleSyncWarning(reason, delayMs);
      };

      syncErrorHandler = (event) => {
        console.error('Sync connection error:', event?.message || event);
        triggerSyncWarning('connection error', 'sync-connection-error');
      };

      syncProvider.on('status', syncStatusHandler);
      syncProvider.on('connection-error', syncErrorHandler);

      if (initialConnected) {
        syncHealthy = true;
        clearSyncWarningTimer();
        hideSyncWarning();
      } else {
        // Guard against cases where the provider never reaches "connected"
        scheduleSyncWarning('connection not established', SYNC_CONNECT_GRACE_MS);
      }
    }

    function saveLocalBackup(reason) {
      if (!state.editor || !state.currentFile) return;

      try {
        // Get current content from the editor
        const content = state.editor.getContent ? state.editor.getContent() : '';
        if (!content) return;

        const backup = {
          file: state.currentFile,
          content: content,
          timestamp: new Date().toISOString(),
          reason: reason,
          charCount: content.length,
        };

        // Save to localStorage with timestamp key for history
        const backupKey = `mrmd-backup-${Date.now()}`;
        localStorage.setItem(backupKey, JSON.stringify(backup));

        // Also save as "latest" for quick access
        localStorage.setItem('mrmd-backup-latest', JSON.stringify(backup));

        // Keep only last 10 backups
        const allKeys = Object.keys(localStorage).filter(k => k.startsWith('mrmd-backup-') && k !== 'mrmd-backup-latest');
        if (allKeys.length > 10) {
          allKeys.sort().slice(0, allKeys.length - 10).forEach(k => localStorage.removeItem(k));
        }

        lastBackupTime = new Date();
        console.log(`Backup saved: ${content.length} chars at ${lastBackupTime.toISOString()} (${reason})`);
      } catch (e) {
        console.error('Failed to save backup:', e);
      }
    }

    function copyBackupToClipboard() {
      if (!state.editor) {
        alert('No editor content to copy');
        return;
      }

      try {
        const content = state.editor.getContent ? state.editor.getContent() : '';
        navigator.clipboard.writeText(content).then(() => {
          alert(`Copied ${content.length} characters to clipboard!`);
        }).catch(e => {
          alert('Failed to copy: ' + e.message);
        });
      } catch (e) {
        alert('Failed to get content: ' + e.message);
      }
    }

    function downloadBackup() {
      if (!state.editor || !state.currentFile) {
        alert('No content to download');
        return;
      }

      try {
        const content = state.editor.getContent ? state.editor.getContent() : '';
        const baseName = stripDocExtension(state.currentFile.split('/').pop());
        const ext = getDocExtension(state.currentFile) || '.md';
        const filename = `${baseName}-backup-${Date.now()}${ext}`;

        const blob = new Blob([content], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);

        console.log(`Downloaded backup: ${filename} (${content.length} chars)`);
      } catch (e) {
        alert('Failed to download: ' + e.message);
      }
    }

    async function attemptRecovery() {
      if (!state.currentFile) {
        alert('No file is currently open');
        return;
      }

      console.log('Attempting recovery...');

      // Save a backup first before any recovery attempt
      saveLocalBackup('pre-recovery');

      try {
        // Try to reopen the file (this will start a new sync server)
        await openFile(state.currentFile);

        // If successful, hide the warning
        hideSyncWarning();
        syncHealthy = true;

        alert('Recovery successful! Your document has been reconnected.');
      } catch (e) {
        alert('Recovery failed: ' + e.message + '\n\nPlease use Copy Content or Download Backup to save your work.');
      }
    }

    // Watchdog: periodically check sync health and save backups
    function startWatchdog() {
      if (watchdogInterval) return;

      watchdogInterval = setInterval(() => {
        // Save periodic backup if we have content (every 60 seconds)
        if (state.editor && state.currentFile) {
          saveLocalBackup('periodic');
        }

        // Check WebSocket connection health
        // This catches cases where the sync server is still running but
        // the WebSocket connection was silently dropped.
        if (syncProvider && syncHasEverConnected) {
          const isConnected = !!(syncProvider.wsconnected || syncProvider.synced);

          if (!isConnected && syncHealthy) {
            // Connection was healthy but now appears disconnected
            console.warn('[watchdog] WebSocket appears disconnected, scheduling warning...');
            scheduleSyncWarning('connection appears lost', SYNC_RECONNECT_GRACE_MS);
          } else if (isConnected && !syncHealthy) {
            // Connection was lost but now appears reconnected
            console.log('[watchdog] WebSocket reconnected');
            clearSyncWarningTimer();
            hideSyncWarning();
            syncHealthy = true;
          }
        }
      }, 60000); // Every 60 seconds

      console.log('Watchdog started: periodic backups every 60s, WebSocket health checks');
    }

    function stopWatchdog() {
      if (watchdogInterval) {
        clearInterval(watchdogInterval);
        watchdogInterval = null;
      }
    }

    // =========================================================================
    // INITIALIZATION
    // =========================================================================

    // Debounced project refresh
    let projectRefreshTimeout = null;
    function scheduleProjectRefresh() {
      if (projectRefreshTimeout) clearTimeout(projectRefreshTimeout);
      projectRefreshTimeout = setTimeout(async () => {
        if (state.project?.root) {
          console.log('[watch] Refreshing project nav...');
          const project = await electronAPI.project.get(state.currentFile || state.project.root + '/mrmd.md');
          if (project) {
            state.project = project;
            updateNavSidebar(project, state.currentFile);

            // Update wiki-link completion with new files
            if (state.editor && project.files) {
              const parsedFiles = parseProjectFiles(project.files);
              state.editor.setProjectFiles(parsedFiles);
              console.log(`[watch] Wiki-link completion updated with ${parsedFiles.length} files`);
            }

            // Keep Ctrl+P index fresh while picker is open
            if (isFilePickerVisible()) {
              state.previewCache.clear();
              const activeScope = getActiveScopePath()
                || state.folderContext
                || state.defaultScopeRoot
                || project.root;
              if (activeScope) {
                startFileScan(activeScope);
              } else {
                scheduleFileIndexRefresh({ immediate: true });
              }
            }
          }
        }
      }, 300); // 300ms debounce
    }

    async function init() {
      console.log('mrmd-electron ready');

      // Load home directory for path resolution
      state.homeDir = await electronAPI.getHomeDir();

      // Load saved theme (must be after mrmd.js is loaded)
      loadSavedTheme();

      // Set up project file change listener
      electronAPI.project.onChanged(({ projectRoot }) => {
        console.log('[watch] Project files changed:', projectRoot);
        scheduleProjectRefresh();
      });

      // Start AI in background
      electronAPI.getAi().then(result => {
        if (result.success) {
          state.aiPort = result.port;
          updateAiStatus('ready');
          // Connect AI client for AI Commands panel
          connectAiServer(`http://127.0.0.1:${result.port}`);
        }
      });

      // DATA LOSS PREVENTION: Start watchdog for periodic backups
      startWatchdog();

      // Show file picker on start
      setTimeout(showFilePicker, 100);
    }

    init();
  </script>
</body>
</html>
